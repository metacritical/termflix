#!/usr/bin/env bash
#
# Termflix - Torrent Streaming Tool - Stream torrents directly to mpv/vlc
# Usage: termflix [command] or termflix <magnet_link|torrent_file>
#

# Don't exit on error - we handle errors gracefully
set +e
# Suppress job control messages (like "Terminated: 15")
set +H 2>/dev/null || true

# Cleanup function for poster images and temp files
cleanup_on_exit() {
    # Kill background jobs
    jobs -p | xargs kill 2>/dev/null || true
    
    # Cleanup temp files
    rm -f /tmp/termflix_poster_* 2>/dev/null
    rm -f /tmp/termflix_search_* 2>/dev/null
    rm -rf /tmp/termflix_posters_* 2>/dev/null
    rm -f /tmp/torrent_* 2>/dev/null
    
    # Reset terminal
    tput cnorm 2>/dev/null || true
}
trap cleanup_on_exit EXIT INT TERM

# Resolve script directory (works even when called via PATH or symlinks)
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
TERMFLIX_SCRIPTS_DIR="$SCRIPT_DIR/scripts"
export TERMFLIX_SCRIPTS_DIR

# ============================================================
# MODULE LOADING
# ============================================================

# Core Modules
source "$SCRIPT_DIR/modules/core/colors.sh"
source "$SCRIPT_DIR/modules/core/config.sh"
source "$SCRIPT_DIR/modules/core/deps.sh"

# Load Configured Theme
# (theme.sh is loaded early by colors.sh with defaults, so we reload here if config overrides)
CFG_THEME=$(get_theme_preference)
if [[ -n "$CFG_THEME" && "$CFG_THEME" != "charm" ]]; then
    load_theme "$CFG_THEME"
fi

# UI Modules
source "$SCRIPT_DIR/modules/ui/status.sh"
source "$SCRIPT_DIR/modules/ui/help.sh"
source "$SCRIPT_DIR/modules/ui/fzf_catalog.sh"

# Feature Modules
source "$SCRIPT_DIR/modules/posters.sh"
source "$SCRIPT_DIR/modules/search.sh"
source "$SCRIPT_DIR/modules/catalog.sh"
source "$SCRIPT_DIR/modules/torrent.sh"
source "$SCRIPT_DIR/modules/streaming/player.sh"

# Initialize directories
init_termflix_dirs

# Export API keys for external scripts (required for get_poster.py)
export TMDB_API_KEY=$(get_tmdb_api_key)
export TMDB_READ_TOKEN=$(get_tmdb_read_token)
export OMDB_API_KEY=$(config_get "OMDB_API_KEY" "")

# ============================================================
# COMPATIBILITY & HELPERS
# ============================================================

# Wrapper for check_all_deps that sets TORRENT_TOOL global
check_deps() {
    check_all_deps
    TORRENT_TOOL=$(check_torrent_client)
    export TORRENT_TOOL
}
export -f check_deps

# Global debug flag
TORRENT_DEBUG=false

# ============================================================
# MAIN FUNCTION
# ============================================================

main() {
    local source=""
    local index=""
    local list_only=false
    local auto_quality=false
    local enable_subtitles=false
    local args=("$@")
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -l|--list)
                list_only=true
                shift
                ;;
            -i|--index)
                index="$2"
                shift 2
                ;;
            -q|--quality)
                auto_quality=true
                shift
                ;;
            -s|--subtitles)
                enable_subtitles=true
                shift
                ;;
            -v|--verbose)
                set -x
                shift
                ;;
            --debug)
                TORRENT_DEBUG=true
                export TORRENT_DEBUG
                shift
                ;;
            -g|--grid)
                # Enable legacy poster grid mode (viu/kitty)
                USE_GRID_MODE=true
                export USE_GRID_MODE
                shift
                ;;
            --clear)
                local cache_dir="$HOME/.config/termflix/cache"
                if [ -d "$cache_dir" ]; then
                    local deleted_count=$(find "$cache_dir" -name "catalog_*.txt" -type f | wc -l | tr -d ' ')
                    rm -rf "$cache_dir"/catalog_*.txt 2>/dev/null
                    if [ "$deleted_count" -gt 0 ]; then
                        echo -e "${GREEN}‚úì Cleared ${deleted_count} cache file(s)${RESET}"
                    else
                        echo -e "${YELLOW}No cache files found to clear${RESET}"
                    fi
                else
                    echo -e "${YELLOW}Cache directory does not exist${RESET}"
                fi
                exit 0
                ;;
            --remove)
                local torrent_dir="/tmp/torrent-stream"
                if [ -d "$torrent_dir" ]; then
                    local file_count=$(find "$torrent_dir" -maxdepth 1 -type f -o -type d | wc -l | tr -d ' ')
                    # Subtract 1 for the directory itself
                    file_count=$((file_count - 1))
                    rm -rf "$torrent_dir"/* 2>/dev/null
                    if [ "$file_count" -gt 0 ]; then
                        echo -e "${GREEN}‚úì Removed ${file_count} torrent temp file(s) from $torrent_dir${RESET}"
                    else
                        echo -e "${YELLOW}No torrent files found to remove${RESET}"
                    fi
                else
                    echo -e "${YELLOW}Torrent temp directory does not exist${RESET}"
                fi
                exit 0
                ;;
            player)
                # Change player preference
                if [ -z "$2" ]; then
                    echo -e "${RED}Error:${RESET} Please specify a player (mpv or vlc)"
                    echo "Usage: termflix player <mpv|vlc>"
                    exit 1
                fi
                local new_player="$2"
                if [[ "$new_player" =~ ^(mpv|vlc)$ ]]; then
                    init_termflix_dirs
                    local config_file=$(get_termflix_config_file)
                    echo "PLAYER=$new_player" > "$config_file"
                    echo -e "${GREEN}Player preference changed to:${RESET} $new_player"
                    echo -e "${CYAN}Config saved to:${RESET} $config_file"
                    exit 0
                else
                    echo -e "${RED}Error:${RESET} Invalid player. Use 'mpv' or 'vlc'"
                    exit 1
                fi
                ;;
            search)
                shift
                ;;
            *)
                if [ -z "$source" ]; then
                    source="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Helper function for simple catalog commands (latest/trending/popular)
    run_simple_catalog_command() {
        local icon="$1"
        local label="$2"
        local type="${routing_args[1]:-all}"
        
        check_jq
        
        case "$type" in
            movies)
                display_catalog "$icon $label Movies" get_latest_movies 50
                ;;
            shows)
                display_catalog "$icon $label TV Shows" get_latest_shows 50
                ;;
            all|*)
                display_catalog "$icon $label" get_latest_movies 50
                ;;
        esac
        exit $?
    }
    
    # Filter args for routing (remove --debug)
    local routing_args=()
    for arg in "${args[@]}"; do
        [[ "$arg" != "--debug" ]] && routing_args+=("$arg")
    done
    
    # Handle catalog modes FIRST (doesn't need streaming tool)
    case "${routing_args[0]}" in
        latest)
            run_simple_catalog_command "üé¨" "Latest"
            ;;
        trending)
            run_simple_catalog_command "üî•" "Trending"
            ;;
        popular)
            run_simple_catalog_command "‚≠ê" "Popular"
            ;;
        catalog)
            check_jq
            local genre="${routing_args[1]:-}"
            if [ -z "$genre" ]; then
                echo -e "${BOLD}Available Genres:${RESET}"
                echo "  action, adventure, animation, comedy, crime, documentary,"
                echo "  drama, family, fantasy, horror, mystery, romance,"
                echo "  sci-fi, thriller, war, western"
                echo
                echo "Usage: torrent catalog <genre>"
                exit 1
            fi
            # TPB only - YTS disabled for genre search
            display_catalog "üìö $genre Movies" get_latest_movies 50
            exit $?
            ;;
        search)
            check_jq
            local query="${routing_args[1]:-}"
            if [ -z "$query" ]; then
                echo -e "${RED}Error:${RESET} Please provide a search query"
                echo "Usage: termflix search <query>"
                exit 1
            fi
            search_torrent "$query"
            exit $?
            ;;
    esac
    
    # If we get here and no source, default to "latest movies" with category switching
    if [ -z "$source" ] && [ "$list_only" = false ]; then
        check_jq
        
        # Category switching loop - NEW DESIGN
        local current_category="movies"
        local current_context="default" # default, year, rating, peers, title
        local current_sort="desc"       # desc, asc
        local current_min_rating=0
        local current_query=""
        
        while true; do
            # Export context for fetch functions
            local export_sort_by="year"
            case "$current_context" in
                default) export_sort_by="year" ;;
                title)   export_sort_by="title" ;;
                rating)  export_sort_by="rating" ;;
                peers)   export_sort_by="seeds" ;;
                year)    export_sort_by="year" ;;
                *)       export_sort_by="year" ;;
            esac
            
            # Map friendly context to API sort key
            if [[ "$current_context" == "default" ]]; then
                # Default "Most Recent" behavior
                export CURRENT_SORT="year"
                export CURRENT_ORDER="desc"
            else
                export CURRENT_SORT="$export_sort_by"
                export CURRENT_ORDER="$current_sort"
            fi
            
            export CURRENT_GENRE="" # Clear genre for now unless specific
            export CURRENT_MIN_RATING="$current_min_rating"
            export CURRENT_QUERY="$current_query"
            export CURRENT_CATEGORY="$current_category"

            # Build title
            local title_prefix="üé¨"
            case "$current_context" in
                default) title_prefix="$title_prefix Recent Movies" ;;
                year)    title_prefix="$title_prefix Movies by Year ($current_sort)" ;;
                rating)  title_prefix="$title_prefix Top Rated (${current_min_rating}+) ($current_sort)" ;;
                peers)   title_prefix="$title_prefix Most Seeded ($current_sort)" ;;
                title)   title_prefix="$title_prefix Movies by Title ($current_sort)" ;;
            esac
            
            if [[ -n "$current_query" ]]; then
                 title_prefix="$title_prefix [Filter: $current_query]"
            fi
            
            # Map to data function - Unified
            # All contexts use the same python script, just different args via globals
            # We use 'get_latest_movies' as the base caller since it's generic
            data_func="get_latest_movies"

            display_catalog "$title_prefix" "$data_func" 50
            local ret=$?
            
            # Reset one-time flags
            [[ "$FORCE_REFRESH" == "true" ]] && export FORCE_REFRESH=false
            
            case $ret in
                # ... standard navigations ...
                101) current_category="movies"; current_context="default" ;;
                102) current_category="shows" ;;
                103) # Watchlist
                     # Placeholder for future Watchlist feature
                     clear
                     echo -e "\n${BOLD}${YELLOW}üìö Watchlist${RESET}\n"
                     echo -e "${CYAN}Coming Soon!${RESET}"
                     echo -e "\nThis feature will allow you to:"
                     echo -e "  ‚Ä¢ Save movies and shows to watch later"
                     echo -e "  ‚Ä¢ Get notified when new episodes arrive"
                     echo -e "  ‚Ä¢ Track your watch history"
                     echo -e "\n${GRAY}Press any key to go back...${RESET}"
                     read -n 1 -s
                     current_category="movies"
                     continue
                     ;;
                104) 
                    # Type Menu (^T) - Select Category & Context
                    # Indicators
                    local ind_mov="‚óã"; [[ "$current_category" == "movies" ]] && ind_mov="‚óè"
                    local ind_sho="‚óã"; [[ "$current_category" == "shows" ]] && ind_sho="‚óè"
                    
                    local ind_ctx_def=" "; [[ "$current_context" == "default" ]] && ind_ctx_def="‚óè"
                    local ind_ctx_year=" "; [[ "$current_context" == "year" ]] && ind_ctx_year="‚óè"
                    local ind_ctx_rate=" "; [[ "$current_context" == "rating" ]] && ind_ctx_rate="‚óè"
                    local ind_ctx_peer=" "; [[ "$current_context" == "peers" ]] && ind_ctx_peer="‚óè"
                    local ind_ctx_title=" "; [[ "$current_context" == "title" ]] && ind_ctx_title="‚óè"

                    local menu_items="${ind_mov} üé¨ Browse Movies\n${ind_sho} üì∫ Browse Shows\n"
                    menu_items+="\n-- üîç Switch Context --\n"
                    menu_items+="${ind_ctx_year} üìÖ By Year (Mode)...\n"
                    menu_items+="${ind_ctx_rate} ‚≠ê By Rating (Mode)...\n"
                    menu_items+="${ind_ctx_peer} üå± By Peers (Mode)...\n"
                    menu_items+="${ind_ctx_title} üî§ By Title (Mode)...\n"
                    
                    local selected_action
                    selected_action=$(echo -e "$menu_items" | fzf --height=16 --layout=reverse --border --prompt="Type > " --header="Select Content Mode (Current marks: ‚óè)" 2>/dev/null)
                    
                    # Handle Esc/Cancel (Empty selection) - Just continue to re-render without changing state
                    [[ -z "$selected_action" ]] && continue

                    case "$selected_action" in
                        *"Browse Movies") 
                            current_category="movies"; current_context="default" ;;
                        *"Browse Shows") 
                            current_category="shows" ;;
                            
                        # Context Switching - Immediately Prompts for Filter Value
                        *"By Year (Mode)...") 
                            current_context="year"; current_sort="desc" 
                            # Initial Prompt
                            local yr_list=$(seq $(date +%Y) -1 1950)
                            local sel_yr=$(echo "$yr_list" | fzf --height=15 --layout=reverse --border --prompt="Year: " --header="Set Initial Year" 2>/dev/null)
                            [[ -n "$sel_yr" ]] && current_query="$sel_yr"
                            ;;
                        *"By Rating (Mode)...") 
                            current_context="rating"; current_sort="desc"
                            local rat_opts="9+ Stars\n8+ Stars\n7+ Stars\n6+ Stars\n5+ Stars\nAny Rating"
                            local sel_rat=$(echo -e "$rat_opts" | fzf --height=10 --layout=reverse --border --prompt="Min Rating: " --header="Set Initial Rating" 2>/dev/null)
                            case "$sel_rat" in
                                "9+ Stars") current_min_rating=9 ;;
                                "8+ Stars") current_min_rating=8 ;;
                                "7+ Stars") current_min_rating=7 ;;
                                "6+ Stars") current_min_rating=6 ;;
                                "5+ Stars") current_min_rating=5 ;;
                                *) current_min_rating=0 ;;
                            esac
                            ;;
                        *"By Peers (Mode)...") 
                             current_context="peers"; current_sort="desc" ;;
                        *"By Title (Mode)...") 
                             current_context="title"; current_sort="asc" ;;
                    esac
                    continue
                    ;;
                105) 
                    # Smart Sort Menu (^V) - Context Aware + Tweaker
                    local sort_menu=""
                    
                    case "$current_context" in
                        default)
                            sort_menu="‚¨áÔ∏è Latest Uploads (Default)\nüî• Trending Now\n‚≠ê Popular All Time" ;;
                        year)
                            # Allow changing the filter value (Year) from here too
                            sort_menu="üìÖ Change Year... [Current: $current_query]\n"
                            sort_menu+="‚¨áÔ∏è Sort: Newest First\n‚¨ÜÔ∏è Sort: Oldest First" ;;
                        rating)
                            sort_menu="‚≠ê Change Min Rating... [Current: ${current_min_rating}+]\n"
                            sort_menu+="‚¨áÔ∏è Sort: Highest Rated\n‚¨ÜÔ∏è Sort: Lowest Rated" ;;
                        peers)
                            sort_menu="‚¨áÔ∏è Sort: Most Seeds\n‚¨ÜÔ∏è Sort: Fewest Seeds" ;;
                        title)
                            sort_menu="‚¨áÔ∏è Sort: A-Z\n‚¨ÜÔ∏è Sort: Z-A" ;;
                    esac
                    
                    local sel_sort
                    sel_sort=$(echo -e "$sort_menu" | fzf --height=12 --layout=reverse --border --prompt="Sort: " --header="Sort & Tweak ($current_context)" 2>/dev/null)
                    
                    if [[ -n "$sel_sort" ]]; then
                        case "$sel_sort" in
                            # DEFAULT
                            *"Latest Uploads"*) current_sort="date_added"; current_order="desc" ;;
                            *"Trending Now"*)   current_sort="trending";   current_order="desc" ;; # Trending usually implies desc
                            *"Popular All Time"*) current_sort="rating"; current_order="desc" ;;
                            
                            # YEAR TWEAKS
                            *"Change Year"*)
                                local yr_list=$(seq $(date +%Y) -1 1950)
                                local sel_yr=$(echo "$yr_list" | fzf --height=15 --layout=reverse --border --prompt="Year: " 2>/dev/null)
                                [[ -n "$sel_yr" ]] && current_query="$sel_yr"
                                ;;
                            *"Newest First"*) current_sort="desc" ;;
                            *"Oldest First"*) current_sort="asc" ;;
                            
                            # RATING TWEAKS
                            *"Change Min Rating"*)
                                local r_opts="9+\n8+\n7+\n6+\nAny"
                                local r_sel=$(echo -e "$r_opts" | fzf --height=8 --layout=reverse --border --prompt="Min Rating: " 2>/dev/null)
                                case "$r_sel" in
                                    "9+") current_min_rating=9 ;;
                                    "8+") current_min_rating=8 ;;
                                    "7+") current_min_rating=7 ;;
                                    "6+") current_min_rating=6 ;;
                                    *)    current_min_rating=0 ;;
                                esac
                                ;;
                            *"Highest Rated"*) current_sort="desc" ;;
                            *"Lowest Rated"*)  current_sort="asc" ;;
                            
                            # GENERAL
                            *"Most Seeds"*)    current_sort="desc" ;;
                            *"Fewest Seeds"*)  current_sort="asc" ;;
                            *"A-Z"*)           current_sort="asc" ;;
                            *"Z-A"*)           current_sort="desc" ;;
                        esac
                    fi
                    continue
                    ;;
                106)
                    # Genre dropdown: show FZF popup with genre list
                    local genre_list="All Genres\nAction\nAdventure\nAnimation\nComedy\nCrime\nDocumentary\nDrama\nFamily\nFantasy\nHorror\nMusic\nMystery\nRomance\nSci-Fi\nThriller\nWar\nWestern"
                    local selected_genre
                    selected_genre=$(echo -e "$genre_list" | fzf --height=15 --layout=reverse --border --prompt="Genre: " --header="Filter by genre" 2>/dev/null)
                    
                    if [[ -n "$selected_genre" && "$selected_genre" != "All Genres" ]]; then
                        export CURRENT_GENRE="$selected_genre" # Use export for CURRENT_GENRE
                    else
                        export CURRENT_GENRE=""
                    fi
                    continue
                    ;;
                109)
                    # Refresh: Force reload of catalog data
                    export FORCE_REFRESH=true
                    continue
                    ;;
                110)
                    # Search UI
                    local search_query=""
                    if command -v gum &> /dev/null; then
                        search_query=$(gum input --placeholder "Search Movies/Shows..." --prompt "üîç " --width 60 --header "Search Termflix Catalog")
                    else
                         # Fallback: Use FZF as an input box
                         # We pipe dummy input, use print-query to get user typing, and capture first line
                         search_query=$(echo "" | fzf --print-query --prompt="Search > " --header="Type and press Enter" --height=8 --layout=reverse --border | head -1)
                    fi
                    
                    if [[ -n "$search_query" ]]; then
                        current_query="$search_query"
                        # Switch to default sort for relevance
                        current_context="default" 
                    fi
                    continue
                    ;;
                *)   break ;;  # User cancelled or streamed
            esac
        done
        
        exit 0
    fi
    
    # Check dependencies for streaming (only needed when actually streaming)
    check_deps
    check_jq
    
    # Get source from clipboard if not provided
    if [ -z "$source" ]; then
        if command -v pbpaste &> /dev/null; then
            # BSD grep compatible (no -P flag)
            source=$(pbpaste | grep -oE 'magnet:\?[^[:space:]]+' | head -1)
            if [ -n "$source" ]; then
                echo -e "${GREEN}Using magnet link from clipboard${RESET}"
            fi
        fi
        
        if [ -z "$source" ]; then
            echo -e "${RED}Error:${RESET} No magnet link or torrent file provided"
            echo "Usage: termflix <magnet_link|torrent_file>"
            echo "   or: termflix --help"
            exit 1
        fi
    fi
    
    # Handle auto-quality selection
    if [ "$auto_quality" = true ] && [ -z "$index" ]; then
        index=$(select_best_quality "$source")
    fi
    
    # Stream the torrent
    stream_torrent "$source" "$index" "$list_only" "$enable_subtitles"
}

# Run main function
# Run main function if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
