#!/usr/bin/env bash
#
# Termflix - Torrent Streaming Tool - Stream torrents directly to mpv/vlc
# Usage: termflix [command] or termflix <magnet_link|torrent_file>
#

# Don't exit on error - we handle errors gracefully
set +e
# Suppress job control messages (like "Terminated: 15")
set +H 2>/dev/null || true

# Cleanup function for poster images
cleanup_on_exit() {
    cleanup_posters
}
trap cleanup_on_exit EXIT INT TERM

# Resolve script directory (works even when called via PATH or symlinks)
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
export TERMFLIX_SCRIPTS_DIR="${SCRIPT_DIR}/termflix_scripts"

# Source termflix modules
source "${SCRIPT_DIR}/termflix_modules/core.sh"
source "${SCRIPT_DIR}/termflix_modules/ui.sh"
source "${SCRIPT_DIR}/termflix_modules/posters.sh"
source "${SCRIPT_DIR}/termflix_modules/search.sh"
source "${SCRIPT_DIR}/termflix_modules/catalog.sh"
source "${SCRIPT_DIR}/termflix_modules/torrent.sh"



# Check for jq - now in core.sh module (keeping for backward compat)
check_jq() {
    if ! command -v jq &> /dev/null; then
        echo -e "${YELLOW}Warning:${RESET} jq not found. Some search features may be limited."
        if [[ "$OSTYPE" == "darwin"* ]]; then
            echo "Install with: ${CYAN}brew install jq${RESET}"
        else
            echo "Install with: ${CYAN}sudo apt-get install jq${RESET} (Debian/Ubuntu) or ${CYAN}sudo yum install jq${RESET} (RHEL/CentOS)"
        fi
        echo
    fi
}

# Check for viu (optional, for displaying images - cross-platform)
check_viu() {
    if ! command -v viu &> /dev/null; then
        echo -e "${YELLOW}Note:${RESET} viu not found. Movie posters will not be displayed."
        if [[ "$OSTYPE" == "darwin"* ]]; then
            echo "Install with: ${CYAN}brew install viu${RESET} or ${CYAN}cargo install viu${RESET}"
        else
            echo "Install with: ${CYAN}cargo install viu${RESET} or ${CYAN}sudo apt-get install viu${RESET} (if available in repos)"
        fi
        echo
        return 1
    fi
    return 0
}

# ============================================================
# VIU ANSI CACHING SYSTEM
# Pre-renders poster images with viu and caches the ANSI escape
# sequences for instant display (~4x faster than rendering each time)
# ============================================================

# Get the VIU render cache directory
get_viu_cache_dir() {
    local cache_dir="$HOME/.config/termflix/cache/viu_renders"
    mkdir -p "$cache_dir" 2>/dev/null
    echo "$cache_dir"
}

# Generate cache key from image source and dimensions
# Returns: hash string suitable for filename
viu_cache_key() {
    local image_source="$1"
    local width="${2:-15}"
    local height="${3:-10}"
    
    # Create unique key from source + dimensions
    local key_input="${image_source}_${width}x${height}"
    local hash
    hash=$(echo "$key_input" | md5 2>/dev/null || echo "$key_input" | md5sum 2>/dev/null | cut -d' ' -f1)
    echo "${hash:0:16}"
}

# Check if cached viu render exists and is valid
# Returns 0 if cache hit, 1 if cache miss
viu_cache_exists() {
    local cache_key="$1"
    local cache_dir
    cache_dir=$(get_viu_cache_dir)
    local cache_file="${cache_dir}/${cache_key}.ansi"
    
    if [ -f "$cache_file" ] && [ -s "$cache_file" ]; then
        return 0  # Cache hit
    fi
    return 1  # Cache miss
}

# Pre-render image with viu and cache the ANSI output
# This is the expensive operation (~300-1000ms) we want to do only once
prerender_poster_viu() {
    local image_file="$1"
    local width="${2:-15}"
    local height="${3:-10}"
    local cache_key="${4:-}"
    
    if [ ! -f "$image_file" ] || [ ! -s "$image_file" ]; then
        return 1
    fi
    
    # Generate cache key if not provided
    if [ -z "$cache_key" ]; then
        cache_key=$(viu_cache_key "$image_file" "$width" "$height")
    fi
    
    local cache_dir
    cache_dir=$(get_viu_cache_dir)
    local cache_file="${cache_dir}/${cache_key}.ansi"
    
    # Check if already cached
    if [ -f "$cache_file" ] && [ -s "$cache_file" ]; then
        echo "$cache_file"
        return 0
    fi
    
    # Check if viu is available
    if ! command -v viu &>/dev/null; then
        return 1
    fi
    
    # Pre-render with viu and capture ANSI output
    viu -w "$width" -h "$height" "$image_file" 2>/dev/null > "$cache_file"
    
    if [ -f "$cache_file" ] && [ -s "$cache_file" ]; then
        echo "$cache_file"
        return 0
    fi
    
    rm -f "$cache_file" 2>/dev/null
    return 1
}

# Display cached viu render (instant - just cat the ANSI file)
display_cached_viu() {
    local cache_file="$1"
    local x_pos="${2:-}"
    local y_pos="${3:-}"
    
    if [ ! -f "$cache_file" ] || [ ! -s "$cache_file" ]; then
        return 1
    fi
    
    # Position cursor if coordinates provided
    if [ -n "$x_pos" ] && [ -n "$y_pos" ]; then
        tput cup "$y_pos" "$x_pos" 2>/dev/null || true
    fi
    
    # Instant display - just cat the pre-rendered ANSI
    cat "$cache_file"
    return 0
}

# Background pre-render multiple posters in parallel
# Usage: prerender_posters_batch image1 image2 image3 ...
prerender_posters_batch() {
    local width="${1:-15}"
    local height="${2:-10}"
    shift 2
    local image_files=("$@")
    
    local pids=()
    for image_file in "${image_files[@]}"; do
        if [ -f "$image_file" ] && [ -s "$image_file" ]; then
            prerender_poster_viu "$image_file" "$width" "$height" &
            pids+=($!)
        fi
    done
    
    # Wait for all background renders to complete
    for pid in "${pids[@]}"; do
        wait "$pid" 2>/dev/null || true
    done
}

# Clean up old viu cache files (older than 7 days)
cleanup_viu_cache() {
    local cache_dir
    cache_dir=$(get_viu_cache_dir)
    
    if [ -d "$cache_dir" ]; then
        find "$cache_dir" -name "*.ansi" -type f -mtime +7 -delete 2>/dev/null || true
    fi
}

# Download and display poster image (with VIU caching for ~4x speedup)
display_poster() {
    local poster_source="$1"  # Can be a URL or a cached file path
    local width="${2:-20}"
    local height="${3:-15}"
    local x_pos="${4:-}"
    local y_pos="${5:-}"
    
    if [ -z "$poster_source" ] || [ "$poster_source" = "N/A" ] || [ "$poster_source" = "" ]; then
        return 1
    fi
    
    local image_file=""
    
    # Check if it's already a cached file path
    if [ -f "$poster_source" ]; then
        image_file="$poster_source"
    else
        # It's a URL, download it to temp directory
        local temp_dir="${TMPDIR:-/tmp}/torrent_posters_$$"
        mkdir -p "$temp_dir" 2>/dev/null || return 1
        
        # Use md5 on macOS, md5sum on Linux
        local hash=$(echo "$poster_source" | md5 2>/dev/null || echo "$poster_source" | md5sum 2>/dev/null | cut -d' ' -f1)
        image_file="${temp_dir}/poster_$(echo "$hash" | cut -c1-8).jpg"
        
        if [ ! -f "$image_file" ]; then
            curl -s --max-time 5 "$poster_source" -o "$image_file" 2>/dev/null || return 1
        fi
    fi
    
    if [ ! -f "$image_file" ] || [ ! -s "$image_file" ]; then
        return 1
    fi

    # Check for Kitty terminal (native image protocol - no caching needed)
    if [[ "$TERM" == "xterm-kitty" ]] && command -v kitty &> /dev/null; then
        if [ -n "$x_pos" ] && [ -n "$y_pos" ]; then
            tput cup "$y_pos" "$x_pos"
            kitty +kitten icat --align left --place "${width}x${height}@${x_pos}x${y_pos}" "$image_file" 2>/dev/null
        else
            kitty +kitten icat --align left --height "$height" "$image_file" 2>/dev/null
        fi
        return 0
    fi
    
    # VIU with ANSI caching (check cache first for instant display)
    if check_viu >/dev/null 2>&1; then
        # Generate cache key for this image + dimensions
        local cache_key
        cache_key=$(viu_cache_key "$image_file" "$width" "$height")
        local cache_dir
        cache_dir=$(get_viu_cache_dir)
        local cached_ansi="${cache_dir}/${cache_key}.ansi"
        
        # Try to use cached render first (instant display!)
        if [ -f "$cached_ansi" ] && [ -s "$cached_ansi" ]; then
            display_cached_viu "$cached_ansi" "$x_pos" "$y_pos"
            return 0
        fi
        
        # Cache miss - pre-render and cache for next time
        local new_cache
        new_cache=$(prerender_poster_viu "$image_file" "$width" "$height" "$cache_key")
        
        if [ -n "$new_cache" ] && [ -f "$new_cache" ]; then
            # Display the newly cached render
            display_cached_viu "$new_cache" "$x_pos" "$y_pos"
            return 0
        fi
        
        # Fallback: direct viu render (shouldn't happen often)
        if [ -n "$x_pos" ] && [ -n "$y_pos" ]; then
            tput cup "$y_pos" "$x_pos"
            viu -w "$width" -h "$height" "$image_file" 2>/dev/null
        else
            viu -w "$width" -h "$height" "$image_file" 2>/dev/null
        fi
        return 0
    fi
    
    return 1
}


# Draw a row of up to 3 items in a grid
# Offline rendering: Pre-render images, then draw row-by-row with proper cursor positioning
draw_grid_row() {
    local start_row="$1"
    local start_index="$2"
    local num_cols="$3"
    shift 3
    local items=("$@")
    
    local col_width=40  # Approximate column width in characters
    local img_width=20
    local img_height=15
    local row_height=21  # Total height for one row (image + 3 text lines + spacing)
    
    # Calculate column positions based on terminal width
    # Ensure proper spacing: each column needs at least img_width + padding
    local term_cols=$(tput cols)
    # Calculate spacing to evenly distribute columns with proper padding
    # Each column needs ~40 chars (20 for image + 20 for text), but we'll use dynamic spacing
    local total_cols_needed=$((num_cols * 40))
    local spacing
    if [ "$total_cols_needed" -le "$term_cols" ]; then
        # We have enough space, use even distribution
        spacing=$((term_cols / num_cols))
    else
        # Not enough space, use minimum spacing
        spacing=40
    fi
    local col_positions=()
    for ((c=0; c<num_cols; c++)); do
        col_positions+=($((c * spacing)))
    done

    # Pass 1: Pre-download all images in parallel
    local temp_dir="${TMPDIR:-/tmp}/torrent_posters_$$"
    mkdir -p "$temp_dir" 2>/dev/null
    
    local pids=()
    local image_files=()
    
    for i in "${!items[@]}"; do
        local result="${items[$i]}"
        IFS='|' read -r source name magnet quality size extra poster_url <<< "$result"
        
        # Handle COMBINED entries
        if [[ "$source" == "COMBINED" ]]; then
            # COMBINED|Name|Sources|Seeds|Qualities|Sizes|Magnets|Poster
            IFS='|' read -r _ c_name _ _ _ _ _ c_poster <<< "$result"
            name="$c_name"
            poster_url="$c_poster"
        fi
        
        if [[ -n "$poster_url" ]] && [[ "$poster_url" != "N/A" ]]; then
            # Check if it's already a cached file path
            if [ -f "$poster_url" ]; then
                # It's a file path, use it directly
                image_files[$i]="$poster_url"
            else
                # It's a URL, download it
                # Use md5 on macOS, md5sum on Linux
                local hash=$(echo "$poster_url" | md5 2>/dev/null || echo "$poster_url" | md5sum 2>/dev/null | cut -d' ' -f1)
                local image_file="${temp_dir}/poster_$(echo "$hash" | cut -c1-8).jpg"
                image_files[$i]="$image_file"
                
                # Download in background if not already cached
                if [ ! -f "$image_file" ]; then
                    ( curl -s --max-time 5 "$poster_url" -o "$image_file" 2>/dev/null ) &
                    pids+=($!)
                fi
            fi
        else
            image_files[$i]=""
        fi
    done
    
    # Wait for all downloads to complete
    for pid in "${pids[@]}"; do
        wait "$pid" 2>/dev/null
    done
    
    # Pass 2: Pre-render all images offline - capture each line separately
    # Store rendered lines: image_lines[item_index][row_index] = line_content
    declare -a has_image=()
    declare -a is_kitty=()
    # Use associative array-like structure with temp files for each item's lines
    local image_line_files=()
    
    for i in "${!items[@]}"; do
        local image_file="${image_files[$i]}"
        has_image[$i]=0
        is_kitty[$i]=0
        image_line_files[$i]=""
        
        if [[ -n "$image_file" ]] && [[ -f "$image_file" ]]; then
            # Check if we're using kitty (which handles positioning differently)
            if [[ "$TERM" == "xterm-kitty" ]] && command -v kitty &> /dev/null; then
                is_kitty[$i]=1
                has_image[$i]=1
            elif check_viu >/dev/null 2>&1; then
                # Pre-render image with viu and capture output line by line
                local rendered_file="${temp_dir}/rendered_${i}.txt"
                viu -w "$img_width" -h "$img_height" "$image_file" 2>/dev/null > "$rendered_file"
                # Sanitize VIU output: remove cursor movement codes but keep colors
                if command -v perl &> /dev/null; then
                    perl -i -pe "s/\x1b\[[0-9;]*[A-HJKSTf]//g" "$rendered_file" 2>/dev/null
                fi
                if [ $? -eq 0 ] && [ -s "$rendered_file" ]; then
                    image_line_files[$i]="$rendered_file"
                    has_image[$i]=1
                else
                    rm -f "$rendered_file" 2>/dev/null
                fi
            fi
        fi
    done
    
    # Pass 3: Draw images row by row (offline rendering)
    # For each row (0 to img_height-1), draw that row for all columns
    for ((row=0; row<img_height; row++)); do
        for i in "${!items[@]}"; do
            local x_pos="${col_positions[$i]}"
            local current_y=$((start_row + row + 1))
            
            if [[ "${has_image[$i]}" -eq 1 ]]; then
                if [[ "${is_kitty[$i]}" -eq 1 ]]; then
                    # For kitty, render once on first row only
                    if [[ "$row" -eq 0 ]]; then
                        local image_file="${image_files[$i]}"
                        kitty +kitten icat --align left --place "${img_width}x${img_height}@${x_pos}x$((start_row + 1))" "$image_file" 2>/dev/null
                    fi
                else
                    # For viu: Read specific row from pre-rendered file and draw at correct position
                    local rendered_file="${image_line_files[$i]}"
                    if [[ -n "$rendered_file" ]] && [[ -f "$rendered_file" ]]; then
                        # Move cursor to exact position for this row and column
                        tput cup "$current_y" "$x_pos"
                        # Read and output the specific line (row+1 because sed line numbers start at 1)
                        local image_line
                        image_line=$(sed -n "$((row + 1))p" "$rendered_file" 2>/dev/null)
                        if [[ -n "$image_line" ]]; then
                            # Remove trailing newline and any remaining escape codes
                            local clean_line="${image_line%$'\n'}"
                            # Remove any cursor movement codes that might have leaked through
                            clean_line=$(echo -n "$clean_line" | sed 's/\x1b\[[0-9;]*[A-HJKSTf]//g' | sed 's/\[0m//g')
                            # Output the line - viu should already respect width
                            printf "%s" "$clean_line"
                            # Position cursor at end of image area (x_pos + img_width) to prevent overwrite
                            # This ensures next column starts at correct position
                            local end_x=$((x_pos + img_width))
                            local term_cols=$(tput cols)
                            if [ "$end_x" -gt "$term_cols" ]; then
                                end_x=$term_cols
                            fi
                            tput cup "$current_y" "$end_x"
                        fi
                    fi
                fi
            else
                # Draw placeholder box row by row (always draw if no image)
                tput cup "$current_y" "$x_pos"
                if [[ "$row" -eq 0 ]]; then
                    echo -ne "${CYAN}┌──────────────────┐${RESET}"
                elif [[ "$row" -eq $((img_height-1)) ]]; then
                    echo -ne "${CYAN}└──────────────────┘${RESET}"
                elif [[ "$row" -eq 7 ]]; then
                    # Center row - show "No Poster" text
                    echo -ne "${CYAN}│${RESET}"
                    tput cup "$current_y" $((x_pos + 5))
                    echo -ne "${CYAN}No Poster${RESET}"
                    tput cup "$current_y" $((x_pos + 19))
                    echo -ne "${CYAN}│${RESET}"
                else
                    echo -ne "${CYAN}│                  │${RESET}"
                fi
                # Ensure cursor is positioned after placeholder
                tput cup "$current_y" $((x_pos + 20))
            fi
        done
        # CRITICAL: After drawing each image row, don't move cursor - let it stay at end of row
        # We'll position it correctly before drawing text
    done
    
    # CRITICAL: After drawing all images, ensure cursor is positioned correctly
    # Images occupy rows: start_row+1 to start_row+img_height (15 lines)
    # Text should start at: start_row + img_height + 1
    # Don't move cursor here - we'll position it per-item when drawing text
    
    # Pass 4: Draw all text below images
    # Calculate text starting row (below images with 1 line spacing for compact layout)
    # Images are drawn from start_row+1 to start_row+img_height (15 lines)
    # Add 1 line spacing, so text starts at start_row + 16
    # CRITICAL: text_row must always be relative to start_row, not adjusted by scrolling
    local text_row=$((start_row + img_height + 1))
    local term_cols=$(tput cols)
    local term_lines_check=$(tput lines)
    
    # CRITICAL: Ensure text_row is within terminal bounds
    if [ "$text_row" -ge "$term_lines_check" ] || [ "$text_row" -lt 1 ]; then
        # If text row is beyond terminal, adjust it
        text_row=$((term_lines_check - 5))
        if [ "$text_row" -lt 1 ]; then
            text_row=1
        fi
    fi
    
    # CRITICAL: Ensure text_row is at least below the image area
    local image_end_row=$((start_row + img_height))
    if [ "$text_row" -le "$image_end_row" ]; then
        text_row=$((image_end_row + 1))
    fi
    
    # Draw text for each item completely before moving to next
    # This prevents overwrites from cursor positioning
    for i in "${!items[@]}"; do
        local item="${items[$i]}"
        local x_pos="${col_positions[$i]}"
        IFS='|' read -r source name magnet quality size extra poster_url <<< "$item"
        
        local item_num=$((start_index + i + 1))
        
        # Check if item is COMBINED
        local is_combined=false
        local combined_sources=()
        local combined_seeds=()
        local combined_qualities=()
        local combined_sizes=()
        local max_seeds=0
        local source_tags=""
        
        if [[ "$source" == "COMBINED" ]]; then
            is_combined=true
            # Parse COMBINED format: COMBINED|Name|Sources|Seeds|Qualities|Sizes|Magnets|Poster
            IFS='|' read -r _ c_name c_sources c_seeds c_qualities c_sizes c_magnets c_poster <<< "$item"
            name="$c_name"
            poster_url="$c_poster"
            
            # Split arrays by ^ delimiter
            IFS='^' read -ra combined_sources <<< "$c_sources"
            IFS='^' read -ra combined_seeds <<< "$c_seeds"
            IFS='^' read -ra combined_qualities <<< "$c_qualities"
            IFS='^' read -ra combined_sizes <<< "$c_sizes"
            
            # Build source tags (e.g., [TPB] [YTS]) - deduplicate sources
            declare -A seen_sources=()
            for src in "${combined_sources[@]}"; do
                # Skip if we've already seen this source
                if [[ -n "${seen_sources[$src]}" ]]; then
                    continue
                fi
                seen_sources[$src]=1
                case "$src" in
                    YTS) source_tags="${source_tags}[${GREEN}YTS${RESET}] " ;;
                    TPB) source_tags="${source_tags}[${YELLOW}TPB${RESET}] " ;;
                    EZTV) source_tags="${source_tags}[${BLUE}EZTV${RESET}] " ;;
                    1337x) source_tags="${source_tags}[${MAGENTA}1337x${RESET}] " ;;
                    *) source_tags="${source_tags}[${CYAN}${src}${RESET}] " ;;
                esac
            done
            unset seen_sources
            source_tags=$(echo "$source_tags" | sed 's/[[:space:]]*$//')  # Trim trailing space
            
            # Calculate max seeds
            for seed_str in "${combined_seeds[@]}"; do
                local seed_val=$(echo "$seed_str" | grep -oE '[0-9]+' | head -1)
                if [ -n "$seed_val" ] && [ "$seed_val" -gt "$max_seeds" ] 2>/dev/null; then
                    max_seeds=$seed_val
                fi
            done
            
            # Use best quality (prefer 1080p, then 720p, then first available)
            quality=""
            for q in "${combined_qualities[@]}"; do
                if [[ "$q" =~ 1080 ]]; then
                    quality="1080p"
                    break
                elif [[ "$q" =~ 720 ]] && [ -z "$quality" ]; then
                    quality="720p"
                elif [ -z "$quality" ] && [ -n "$q" ] && [ "$q" != "N/A" ]; then
                    quality="$q"
                fi
            done
            if [ -z "$quality" ]; then
                quality="N/A"
            fi
            
            # Use first size as representative
            if [ ${#combined_sizes[@]} -gt 0 ]; then
                size="${combined_sizes[0]}"
            fi
            
            # Set seeds for display
            if [ "$max_seeds" -gt 0 ]; then
                seeds="$max_seeds"
            else
                seeds=""
            fi
        else
            # Regular item - use existing logic
            local source_color="$CYAN"
            case "$source" in
                YTS) source_color="$GREEN" ;;
                TPB) source_color="$YELLOW" ;;
                EZTV) source_color="$BLUE" ;;
                1337x) source_color="$MAGENTA" ;;
            esac
        fi
        
        local display_name="${name:0:38}"
        if [ "${#name}" -gt 38 ]; then
            display_name="${display_name}..."
        fi
        
        # Calculate available width for this column (needed for both row 2 and row 3)
        local next_x
        if [ "$i" -lt $((${#items[@]} - 1)) ]; then
            next_x="${col_positions[$((i + 1))]}"
        else
            next_x=$term_cols
        fi
        local col_width=$((next_x - x_pos - 1))  # Leave 1 char margin
        if [ "$col_width" -gt 35 ]; then col_width=35; fi
        if [ "$col_width" -lt 20 ]; then col_width=20; fi
        
        # Write all three lines of text for this item at once
        # CRITICAL: Calculate text_row relative to start_row (where images were drawn)
        # Images are drawn from start_row+1 to start_row+img_height (15 lines)
        # Text should start at start_row + img_height + 1 (row 16 from start_row)
        local image_end_row=$((start_row + img_height))
        local actual_text_row=$((image_end_row + 1))
        
        # CRITICAL: Ensure text_row is below image area first
        if [ "$actual_text_row" -le "$image_end_row" ]; then
            actual_text_row=$((image_end_row + 1))
        fi
        
        # CRITICAL: Then check if it's within terminal bounds
        # If beyond terminal, we still need to draw it, but it might scroll
        # Don't skip drawing - let the terminal handle scrolling
        if [ "$actual_text_row" -lt 1 ]; then
            actual_text_row=1
        fi
        
        # CRITICAL: Clear each line before writing to prevent overlap
        # Calculate clear end position
        local clear_end
        if [ "$i" -lt $((${#items[@]} - 1)) ]; then
            clear_end="${col_positions[$((i + 1))]}"
        else
            clear_end=$term_cols
        fi
        
        # CRITICAL: Strip ANSI codes from quality and extra fields first before parsing
        local clean_quality=$(echo -n "$quality" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/\[0m//g')
        local clean_extra=$(echo -n "$extra" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/\[0m//g')
        
        # Extract seeds from either quality field (TPB format: "1234 seeds") or extra field (YTSRS format: "1234 seeds, 567 peers")
        # Skip extraction for COMBINED entries (seeds already set)
        local quality_has_seeds=false
        if [ "$is_combined" != true ]; then
            seeds=""
            if [[ "$clean_quality" =~ ([0-9]+)[[:space:]]*seeds ]]; then
                seeds="${BASH_REMATCH[1]}"
                quality_has_seeds=true
            elif [[ "$clean_extra" =~ ([0-9]+)[[:space:]]*seeds ]]; then
                seeds="${BASH_REMATCH[1]}"
            fi
        fi
        
        # Get quality preference from config (default: 1080p)
        local config_file=$(get_termflix_config_file)
        local preferred_quality="1080p"
        if [ -f "$config_file" ]; then
            local config_quality=$(grep "^QUALITY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
            if [ -n "$config_quality" ]; then
                preferred_quality="$config_quality"
            fi
        fi
        
        # Extract quality (720p/1080p) - use config preference as default
        local quality_display="$preferred_quality"
        if [ -n "$clean_quality" ] && [ "$clean_quality" != "N/A" ] && [ "$quality_has_seeds" = false ]; then
            # Extract resolution from quality string (e.g., "720p", "1080p", "4K")
            if [[ "$clean_quality" =~ ([0-9]+[pK]) ]]; then
                quality_display="${BASH_REMATCH[1]}"
            elif [[ "$clean_quality" =~ (720|1080|2160|4K) ]]; then
                if [[ "$clean_quality" =~ 720 ]]; then
                    quality_display="720p"
                elif [[ "$clean_quality" =~ 1080 ]]; then
                    quality_display="1080p"
                elif [[ "$clean_quality" =~ (2160|4K) ]]; then
                    quality_display="4K"
                fi
            fi
        fi
        
        # Get IMDB rating and genre from TMDB API cache
        local imdb_rating=""
        local rating_display=""
        local genre_display=""
        if [ -n "$name" ]; then
            # Extract year from name if available
            local year=$(echo "$name" | grep -oE '[0-9]{4}' | head -1)
            local clean_title=$(echo "$name" | sed -E 's/\./ /g' | sed -E 's/ \([0-9]{4}\).*//' | sed 's/\[.*\]//g' | xargs)
            
            # Check cache for rating and genre (using TMDB cache)
            local cache_dir=$(get_termflix_cache_dir)/tmdb
            local cache_key=$(echo "${clean_title}_${year}" | tr -cd '[:alnum:]')
            local cache_file="$cache_dir/${cache_key}.json"
            
            if [ -f "$cache_file" ]; then
                # Try to get rating from cached file
                if command -v jq &> /dev/null; then
                    imdb_rating=$(cat "$cache_file" 2>/dev/null | jq -r '.imdbRating // .vote_average // empty' 2>/dev/null)
                    # Get first genre from genres array
                    genre_display=$(cat "$cache_file" 2>/dev/null | jq -r '.genres[0].name // .genres[0] // empty' 2>/dev/null)
                else
                    imdb_rating=$(cat "$cache_file" 2>/dev/null | grep -o '"imdbRating":"[^"]*"' | cut -d'"' -f4)
                    if [ -z "$imdb_rating" ]; then
                        imdb_rating=$(cat "$cache_file" 2>/dev/null | grep -o '"vote_average":[0-9.]*' | cut -d':' -f2)
                    fi
                    # Try to get genre (first one)
                    genre_display=$(cat "$cache_file" 2>/dev/null | grep -o '"name":"[^"]*"' | head -1 | cut -d'"' -f4)
                fi
            fi
            
            # Format rating display (e.g., "7.5 ⭐")
            if [ -n "$imdb_rating" ] && [ "$imdb_rating" != "N/A" ] && [ "$imdb_rating" != "" ] && [ "$imdb_rating" != "null" ]; then
                # Round to 1 decimal place
                local rating_num=$(echo "$imdb_rating" | awk '{printf "%.1f", $1}')
                rating_display="${rating_num} ⭐"
            fi
        fi
        
        # Clean up title for display (remove dots, brackets, etc.)
        local clean_display_name=$(echo "$display_name" | sed -E 's/\./ /g' | sed -E 's/\[.*\]//g' | sed -E 's/  +/ /g' | xargs)
        # Truncate title if too long (leave some room for column width)
        local title_max_len=$((col_width - 5))
        if [ "$title_max_len" -lt 10 ]; then
            title_max_len=10
        fi
        if [ "${#clean_display_name}" -gt "$title_max_len" ]; then
            clean_display_name="${clean_display_name:0:$title_max_len}..."
        fi
        
        # Row 1: [Number] [Source] Quality | Rating ⭐
        if [ "$actual_text_row" -ge 1 ]; then
            tput cup "$actual_text_row" "$x_pos"
            # Clear to end of column
            printf "%*s" $((clear_end - x_pos)) ""
            tput cup "$actual_text_row" "$x_pos"
            local row1_text=""
            if [ "$is_combined" = true ]; then
                # For COMBINED entries, show multiple source tags
                row1_text="${BOLD}[${item_num}]${RESET} ${source_tags} ${CYAN}${quality_display}${RESET}"
            else
                # For regular entries, show single source
                row1_text="${BOLD}[${item_num}]${RESET} ${source_color}[${source}]${RESET} ${CYAN}${quality_display}${RESET}"
            fi
            if [ -n "$rating_display" ]; then
                row1_text="${row1_text} | ${rating_display}"
            fi
            echo -ne "$row1_text"
        fi
        
        # Row 2: Full Title (cleaned up)
        local text_row_2=$((actual_text_row + 1))
        if [ "$text_row_2" -ge 1 ]; then
            tput cup "$text_row_2" "$x_pos"
            # Clear to end of column
            printf "%*s" $((clear_end - x_pos)) ""
            tput cup "$text_row_2" "$x_pos"
            echo -ne "${BOLD}${clean_display_name}${RESET}"
        fi
        
        # Row 3: Seeds | Genre
        local text_row_3=$((actual_text_row + 2))
        if [ "$text_row_3" -ge 1 ]; then
            tput cup "$text_row_3" "$x_pos"
            # Clear to end of column
            printf "%*s" $((clear_end - x_pos)) ""
            tput cup "$text_row_3" "$x_pos"
            local row3_text=""
            if [ -n "$seeds" ]; then
                row3_text="${YELLOW}${seeds} Seeds${RESET}"
            fi
            if [ -n "$genre_display" ] && [ "$genre_display" != "" ] && [ "$genre_display" != "null" ]; then
                if [ -n "$row3_text" ]; then
                    row3_text="${row3_text} | "
                fi
                row3_text="${row3_text}[${genre_display}]"
            fi
            echo -ne "$row3_text"
            
            # After writing all text for this item, move cursor to end of its column area
            # This prevents overwrites when we write the next column
            tput cup "$text_row_3" $((clear_end - 1))
        fi
    done
    
    # Cleanup rendered files
    for rendered_file in "${image_line_files[@]}"; do
        [[ -n "$rendered_file" ]] && rm -f "$rendered_file" 2>/dev/null
    done
    
    # Calculate the next row position
    # Layout: start_row + img_height (15) + spacing (1) + text_lines (3) = start_row + 19
    # But we use row_height=21 for consistency with scrolling logic (3 text lines)
    local next_row=$((start_row + row_height))
    
    # Ensure cursor is positioned at the next row before returning
    # This ensures the cursor is in a known state for the next row
    tput cup "$next_row" 0
    
    # Return the next row position via stderr (so it doesn't mix with stdout output)
    echo "$next_row" >&2
}

# Cleanup poster images
cleanup_posters() {
    local temp_dir="${TMPDIR:-/tmp}/torrent_posters_$$"
    rm -rf "$temp_dir" 2>/dev/null
}

# Termflix config directory
get_termflix_config_dir() {
    echo "$HOME/.config/termflix"
}

# Termflix config file
get_termflix_config_file() {
    echo "$(get_termflix_config_dir)/config"
}

# Termflix cache directory
get_termflix_cache_dir() {
    echo "$(get_termflix_config_dir)/cache"
}

# Initialize termflix directories
init_termflix_dirs() {
    local config_dir=$(get_termflix_config_dir)
    local cache_dir=$(get_termflix_cache_dir)
    mkdir -p "$config_dir" 2>/dev/null
    mkdir -p "$cache_dir" 2>/dev/null
    mkdir -p "$cache_dir/tmdb" 2>/dev/null
}

# Generate cache key from function names and arguments
generate_cache_key() {
    local args=("$@")
    local key_parts=()
    for arg in "${args[@]}"; do
        key_parts+=("$arg")
    done
    # Create a hash-like key from all arguments
    local key=$(printf '%s|' "${key_parts[@]}" | shasum -a 256 | cut -d' ' -f1)
    echo "$key"
}

# Check if cache is valid (less than 1 hour old)
is_cache_valid() {
    local cache_file="$1"
    if [ ! -f "$cache_file" ]; then
        return 1
    fi
    
    local cache_age=$(($(date +%s) - $(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null)))
    local max_age=$((1 * 60 * 60))  # 1 hour in seconds
    
    if [ "$cache_age" -lt "$max_age" ]; then
        return 0  # Cache is valid
    else
        return 1  # Cache is expired
    fi
}

# Get TMDB API Key
get_tmdb_api_key() {
    local config_file=$(get_termflix_config_file)
    
    if [ -f "$config_file" ]; then
        # Try specific TMDB_API_KEY first, then generic API_KEY
        local key=$(grep "^TMDB_API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        if [ -z "$key" ]; then
            key=$(grep "^API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        fi
        echo "$key"
    fi
}

# Get TMDB Read Access Token
get_tmdb_read_token() {
    local config_file=$(get_termflix_config_file)
    
    if [ -f "$config_file" ]; then
        local token=$(grep "^TMDB_READ_TOKEN=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        echo "$token"
    fi
}

# Get OMDB API Key (deprecated, kept for backward compatibility)
get_omdb_api_key() {
    local config_file=$(get_termflix_config_file)
    
    if [ -f "$config_file" ]; then
        # Try specific OMDB_API_KEY first, then generic API_KEY
        local key=$(grep "^OMDB_API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        if [ -z "$key" ]; then
            key=$(grep "^API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        fi
        echo "$key"
    fi
}

# Fetch poster from Google Images (fallback)
fetch_google_poster() {
    local title="$1"
    local year="$2"
    
    if [ -z "$title" ]; then
        echo "N/A"
        return 1
    fi
    
    # Use external Python script
    export GOOGLE_QUERY="$title $year movie poster"
    
    python3 "$TERMFLIX_SCRIPTS_DIR/google_poster.py"
}

# Fetch poster from TMDB (TheMovieDB) with caching
fetch_tmdb_poster() {
    local title="$1"
    local year="$2"
    
    if [ -z "$title" ]; then
        echo "N/A"
        return 1
    fi
    
    init_termflix_dirs
    
    # Clean title for cache key (remove special chars)
    local clean_title=$(echo "$title" | tr -cd '[:alnum:]')
    local cache_key="${clean_title}_${year}"
    local cache_dir=$(get_termflix_cache_dir)/tmdb
    local images_cache_dir="$cache_dir/images"
    local cache_file="$cache_dir/${cache_key}.json"
    local cached_image="$images_cache_dir/${cache_key}.jpg"
    
    mkdir -p "$cache_dir" 2>/dev/null
    mkdir -p "$images_cache_dir" 2>/dev/null
    
    # Check if we have a cached image file
    if [ -f "$cached_image" ]; then
        echo "$cached_image"
        return 0
    fi
    
    # Check cache for movie data
    local movie_id=""
    local poster_path=""
    
    if [ -f "$cache_file" ]; then
        # Extract movie_id and poster_path from cached JSON
        if command -v jq &> /dev/null; then
            movie_id=$(cat "$cache_file" | jq -r '.id // empty' 2>/dev/null)
            poster_path=$(cat "$cache_file" | jq -r '.poster_path // empty' 2>/dev/null)
        else
            movie_id=$(cat "$cache_file" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
            poster_path=$(cat "$cache_file" | grep -o '"poster_path":"[^"]*"' | cut -d'"' -f4)
        fi
        
        # If we have a cached poster_path but no image file, try to download it
        if [ -n "$poster_path" ] && [ "$poster_path" != "null" ] && [ "$poster_path" != "N/A" ] && [ -n "$movie_id" ]; then
            local image_url="https://image.tmdb.org/t/p/w500${poster_path}"
            if curl -s --max-time 5 "$image_url" -o "$cached_image" 2>/dev/null && [ -f "$cached_image" ] && [ -s "$cached_image" ]; then
                echo "$cached_image"
                return 0
            fi
        fi
    fi
    
    # Get API credentials
    local api_key=$(get_tmdb_api_key)
    local read_token=$(get_tmdb_read_token)
    
    if [ -z "$api_key" ]; then
        echo "N/A"
        return 1
    fi
    
    # Step 1: Search for movie to get movie_id
    local encoded_title
    if command -v jq &> /dev/null; then
        encoded_title=$(echo "$title" | jq -sRr @uri | tr -d '\r\n')
    else
        encoded_title=$(echo "$title" | sed 's/ /%20/g')
    fi
    
    local search_url="https://api.themoviedb.org/3/search/movie?api_key=${api_key}&query=${encoded_title}"
    if [ -n "$year" ]; then
        search_url="${search_url}&year=${year}"
    fi
    
    if ! command -v curl &> /dev/null; then
        echo "N/A"
        return 1
    fi
    
    local search_response=$(curl -s --max-time 5 "$search_url" 2>/dev/null)
    
    if [ -z "$search_response" ]; then
        echo "N/A"
        return 1
    fi
    
    # Extract movie_id from search results
    if [ -z "$movie_id" ]; then
        if command -v jq &> /dev/null; then
            movie_id=$(echo "$search_response" | jq -r '.results[0].id // empty' 2>/dev/null)
            poster_path=$(echo "$search_response" | jq -r '.results[0].poster_path // empty' 2>/dev/null)
        else
            movie_id=$(echo "$search_response" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
            poster_path=$(echo "$search_response" | grep -o '"poster_path":"[^"]*"' | head -1 | cut -d'"' -f4)
        fi
    fi
    
    if [ -z "$movie_id" ] || [ "$movie_id" = "null" ]; then
        # Cache the response even if no movie found
        echo "$search_response" > "$cache_file"
        echo "N/A"
        return 1
    fi
    
    # Step 2: Use images API to verify and get poster information
    local images_url="https://api.themoviedb.org/3/movie/${movie_id}/images"
    local images_response=""
    
    # Try with Bearer token first (more reliable)
    if [ -n "$read_token" ]; then
        images_response=$(curl -s --max-time 5 \
            --header "Authorization: Bearer ${read_token}" \
            --header "accept: application/json" \
            "$images_url" 2>/dev/null)
    fi
    
    # Fallback to API key if Bearer token didn't work or wasn't available
    if [ -z "$images_response" ] || echo "$images_response" | grep -q "Invalid\|Unauthorized\|401"; then
        images_url="${images_url}?api_key=${api_key}"
        images_response=$(curl -s --max-time 5 "$images_url" 2>/dev/null)
    fi
    
    # Extract poster_path from images API response (more reliable)
    if [ -n "$images_response" ]; then
        if command -v jq &> /dev/null; then
            # Get the first poster from the posters array
            poster_path=$(echo "$images_response" | jq -r '.posters[0].file_path // empty' 2>/dev/null)
            # If no poster in images API, try the original from search
            if [ -z "$poster_path" ] || [ "$poster_path" = "null" ]; then
                poster_path=$(echo "$search_response" | jq -r '.results[0].poster_path // empty' 2>/dev/null)
            fi
        else
            poster_path=$(echo "$images_response" | grep -o '"file_path":"[^"]*"' | head -1 | cut -d'"' -f4)
            if [ -z "$poster_path" ]; then
                poster_path=$(echo "$search_response" | grep -o '"poster_path":"[^"]*"' | head -1 | cut -d'"' -f4)
            fi
        fi
    fi
    
    # Fetch full movie details to get genre names and other metadata
    local movie_details=""
    if [ -n "$movie_id" ] && [ "$movie_id" != "null" ]; then
        local details_url="https://api.themoviedb.org/3/movie/${movie_id}"
        if [ -n "$read_token" ]; then
            movie_details=$(curl -s --max-time 5 \
                --header "Authorization: Bearer ${read_token}" \
                "$details_url" 2>/dev/null)
        fi
        if [ -z "$movie_details" ] || echo "$movie_details" | grep -q "Invalid\|Unauthorized\|401"; then
            details_url="${details_url}?api_key=${api_key}"
            movie_details=$(curl -s --max-time 5 "$details_url" 2>/dev/null)
        fi
    fi
    
    # Save to cache (prefer movie details if available, otherwise use search response)
    if [ -n "$movie_details" ] && [ "$movie_details" != "" ]; then
        # Use movie details which includes genre names
        if command -v jq &> /dev/null; then
            echo "$movie_details" | jq --arg path "$poster_path" '. + {poster_path: $path}' > "$cache_file" 2>/dev/null || \
            echo "$movie_details" > "$cache_file" 2>/dev/null
        else
            echo "$movie_details" > "$cache_file"
        fi
    elif command -v jq &> /dev/null; then
        # Fallback to search response
        echo "$search_response" | jq --arg id "$movie_id" --arg path "$poster_path" '.results[0] | .id = ($id | tonumber) | .poster_path = $path' > "$cache_file" 2>/dev/null || \
        echo "$search_response" | jq '.results[0] // {}' > "$cache_file" 2>/dev/null
    else
        echo "$search_response" > "$cache_file"
    fi
    
    # Step 3: Download and cache the image if we have a poster_path
    if [ -n "$poster_path" ] && [ "$poster_path" != "null" ] && [ "$poster_path" != "N/A" ]; then
        local image_url="https://image.tmdb.org/t/p/w500${poster_path}"
        
        # Download the image
        if curl -s --max-time 10 "$image_url" -o "$cached_image" 2>/dev/null && [ -f "$cached_image" ] && [ -s "$cached_image" ]; then
            # Verify it's actually an image file
            if file "$cached_image" 2>/dev/null | grep -q "image"; then
                echo "$cached_image"
                return 0
            else
                rm -f "$cached_image" 2>/dev/null
            fi
        fi
    fi
    
    echo "N/A"
    return 1
}

# Fetch poster from OMDB with caching (deprecated, now uses TMDB only)
fetch_omdb_poster() {
    # Use TMDB only (no OMDB fallback)
    fetch_tmdb_poster "$1" "$2"
}

# Enrich entries with missing posters by looking them up on TMDB
# Input: array of result lines (passed via global variable name)
# Modifies the array in place, updating N/A posters with TMDB URLs
enrich_missing_posters() {
    local -n results_ref=$1  # nameref to results array
    local max_to_enrich=${2:-20}  # Limit to first N entries for speed
    local enriched=0
    local pids=()
    local tmpdir=$(mktemp -d)
    
    # Extract title and year from entry name, fetch poster in background
    for i in "${!results_ref[@]}"; do
        [ "$enriched" -ge "$max_to_enrich" ] && break
        
        local entry="${results_ref[$i]}"
        local poster_field=""
        
        # Get the poster field (last field in pipe-delimited format)
        if [[ "$entry" =~ ^COMBINED\| ]]; then
            # COMBINED|Name|Sources|Seeds|Qualities|Sizes|Magnets|Poster
            poster_field=$(echo "$entry" | cut -d'|' -f8)
        else
            # Source|Name|Magnet|Quality|Size|Extra|Poster
            poster_field=$(echo "$entry" | cut -d'|' -f7)
        fi
        
        # Skip if already has poster
        if [[ -n "$poster_field" && "$poster_field" != "N/A" && "$poster_field" != "" ]]; then
            continue
        fi
        
        # Extract name for TMDB lookup
        local name=""
        if [[ "$entry" =~ ^COMBINED\| ]]; then
            name=$(echo "$entry" | cut -d'|' -f2)
        else
            name=$(echo "$entry" | cut -d'|' -f2)
        fi
        
        # Extract year if present (e.g., "Movie Name (2025)")
        local year=""
        if [[ "$name" =~ \(([0-9]{4})\) ]]; then
            year="${BASH_REMATCH[1]}"
        fi
        
        # Clean title (remove year, quality tags, etc.)
        local clean_title=$(echo "$name" | sed -E 's/\([0-9]{4}\)//g' | sed -E 's/\[[^\]]+\]//g' | sed -E 's/(1080p|720p|480p|HDRip|WEBRip|BluRay|HEVC|x264|x265).*//gi' | xargs)
        
        if [ -n "$clean_title" ]; then
            # Fetch poster in background and save to temp file
            (
                local poster_url=$(fetch_tmdb_poster "$clean_title" "$year" 2>/dev/null)
                if [[ -n "$poster_url" && "$poster_url" != "N/A" ]]; then
                    echo "$poster_url" > "$tmpdir/poster_$i"
                fi
            ) &
            pids+=($!)
            enriched=$((enriched + 1))
        fi
    done
    
    # Wait for all fetches to complete (with timeout)
    local wait_count=0
    while [ $wait_count -lt 20 ]; do  # 10 second timeout
        local all_done=true
        for pid in "${pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                all_done=false
                break
            fi
        done
        [ "$all_done" = true ] && break
        sleep 0.5
        wait_count=$((wait_count + 1))
    done
    
    # Kill remaining background processes
    for pid in "${pids[@]}"; do
        kill "$pid" 2>/dev/null || true
    done
    wait "${pids[@]}" 2>/dev/null || true
    
    # Update entries with fetched posters
    for i in "${!results_ref[@]}"; do
        if [ -f "$tmpdir/poster_$i" ]; then
            local new_poster=$(cat "$tmpdir/poster_$i")
            local entry="${results_ref[$i]}"
            
            # Replace the N/A poster with the fetched URL
            if [[ "$entry" =~ ^COMBINED\| ]]; then
                # Replace last field (poster)
                results_ref[$i]=$(echo "$entry" | sed "s/|N/A$/|$new_poster/" | sed "s/|$/|$new_poster/")
            else
                results_ref[$i]=$(echo "$entry" | sed "s/|N/A$/|$new_poster/" | sed "s/|$/|$new_poster/")
            fi
        fi
    done
    
    rm -rf "$tmpdir" 2>/dev/null
}

export -f get_omdb_api_key get_tmdb_api_key get_tmdb_read_token fetch_omdb_poster fetch_tmdb_poster fetch_google_poster enrich_missing_posters

# Colors - Charm/Charmbracelet style palette
# Inspired by Charm CLI tools (gum, bubbletea, lipgloss)
RED='\033[0;31m'
GREEN='\033[1;38;5;46m'       # Bright luminous green (like Charm selection highlight)
YELLOW='\033[1;38;5;220m'     # Warm yellow/gold
BLUE='\033[1;38;5;81m'        # Light blue (like Charm keywords)
CYAN='\033[1;38;5;87m'        # Bright cyan
MAGENTA='\033[1;38;5;213m'    # Vibrant magenta/pink (Charm accent - like ////// separators)
PURPLE='\033[1;38;5;135m'     # Medium purple (Charm border color)
PINK='\033[1;38;5;219m'       # Soft pink for secondary accents
BOLD='\033[1m'
RESET='\033[0m'

# Charm-style spinner configuration (unified across all spinners)
CHARM_SPINNER_CHARS=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
CHARM_SPINNER_1_COLOR="$MAGENTA"   # First spinner - vibrant magenta
CHARM_SPINNER_2_COLOR="$CYAN"      # Second spinner - bright cyan

# Get or set player preference
get_player_preference() {
    init_termflix_dirs
    local config_file=$(get_termflix_config_file)
    
    # Check if preference exists
    if [ -f "$config_file" ]; then
        local player=$(grep "^PLAYER=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        if [ -n "$player" ] && [[ "$player" =~ ^(mpv|vlc)$ ]]; then
            echo "$player"
            return 0
        fi
    fi
    
    # Ask user for preference (first time) - check if /dev/tty is available
    # Don't check stdin (-t 0) as it may be consumed by previous reads
    if [ -c /dev/tty ] 2>/dev/null && [ -r /dev/tty ] 2>/dev/null; then
        # Use a timeout to prevent hanging - try to read with a timeout
        echo
        echo -e "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${PINK}First time setup:${RESET} Which media player would you like to use?"
        echo -e "  ${MAGENTA}1${RESET}) mpv (recommended)"
        echo -e "  ${MAGENTA}2${RESET}) VLC"
        echo -ne "${PINK}Enter choice (1 or 2, default: 1):${RESET} "
        
        # Try to read with timeout (10 seconds) - if it fails, default to mpv
        # Use read -t which is built into bash and won't block forever
        local choice=""
        if ! read -t 10 -r choice < /dev/tty 2>/dev/null; then
            # Timeout or error - default to mpv
            choice="1"
            echo ""  # New line after timeout
        fi
        
        # Default to 1 if empty or invalid
        [ -z "$choice" ] && choice="1"
        
        local selected_player="mpv"
        case "$choice" in
            2) selected_player="vlc" ;;
            *) selected_player="mpv" ;;
        esac
        
        # Verify player is installed
        if ! command -v "$selected_player" &> /dev/null; then
            echo -e "${RED}Error:${RESET} $selected_player is not installed."
            if [[ "$OSTYPE" == "darwin"* ]]; then
                echo "Please install it first: ${CYAN}brew install $selected_player${RESET}"
            else
                echo "Please install it first: ${CYAN}sudo apt-get install $selected_player${RESET} (Debian/Ubuntu) or ${CYAN}sudo yum install $selected_player${RESET} (RHEL/CentOS)"
            fi
            echo "Defaulting to mpv..."
            selected_player="mpv"
        fi
        
        # Save preference
        echo "PLAYER=$selected_player" > "$config_file"
        echo -e "${GREEN}✓ Preference saved to:${RESET} $config_file"
        echo -e "${CYAN}Note:${RESET} Edit this file to change your preference later."
        echo -e "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo
        
        echo "$selected_player"
        return 0
    else
        # Non-interactive mode or no TTY, default to mpv
        echo "mpv"
        return 0
    fi
}

# Check dependencies
check_deps() {
    local missing=()
    
    # Check for peerflix (primary tool) or webtorrent (alternative)
    if command -v peerflix &> /dev/null; then
        TORRENT_TOOL="peerflix"
    elif command -v webtorrent &> /dev/null; then
        TORRENT_TOOL="webtorrent"
        echo -e "${YELLOW}Note:${RESET} Using webtorrent (peerflix not found)"
        echo "  For better compatibility, install peerflix: ${CYAN}npm install -g peerflix${RESET}"
    else
        echo -e "${RED}Error:${RESET} No torrent streaming tool found."
        echo
        echo "Please install one of:"
        echo "  ${GREEN}npm install -g peerflix${RESET}  (recommended)"
        echo "  ${GREEN}npm install -g webtorrent-cli${RESET}  (alternative)"
        echo
        if [[ "$OSTYPE" == "darwin"* ]]; then
            echo "Or use: ${CYAN}brew install peerflix${RESET}"
        else
            echo "Or use: ${CYAN}npm install -g peerflix${RESET} (works on all platforms)"
        fi
        exit 1
    fi
    
    # Check for transmission-cli (fallback for problematic magnet links)
    if ! command -v transmission-cli &> /dev/null; then
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${YELLOW}Warning:${RESET} transmission-cli not found"
        echo ""
        echo "transmission-cli is used as a fallback when peerflix fails to handle"
        echo "certain magnet links. It's recommended to install it for better compatibility."
        echo ""
        echo -e "${CYAN}Would you like to install transmission-cli now? (y/n)${RESET} "
        read -r install_transmission
        
        if [[ "$install_transmission" =~ ^[Yy]$ ]]; then
            echo ""
            echo -e "${CYAN}Installing transmission-cli...${RESET}"
            
            # Try brew first (macOS)
            if command -v brew &> /dev/null; then
                echo -e "${GREEN}Using Homebrew...${RESET}"
                if brew install transmission-cli; then
                    echo -e "${GREEN}✓ transmission-cli installed successfully${RESET}"
                    echo ""
                else
                    echo -e "${RED}✗ Installation failed. Please install manually:${RESET}"
                    echo "  ${GREEN}brew install transmission-cli${RESET}"
                    echo ""
                    echo -e "${YELLOW}You can continue without it, but some magnet links may not work.${RESET}"
                fi
            else
                echo -e "${YELLOW}Homebrew not found. Please install transmission-cli manually:${RESET}"
                echo ""
                echo "  ${GREEN}macOS:${RESET} brew install transmission-cli"
                echo "  ${GREEN}Linux:${RESET} sudo apt-get install transmission-cli  (Debian/Ubuntu)"
                echo "  ${GREEN}Linux:${RESET} sudo yum install transmission-cli    (RHEL/CentOS)"
                echo ""
                echo -e "${YELLOW}You can continue without it, but some magnet links may not work.${RESET}"
            fi
        else
            echo -e "${YELLOW}Skipping transmission-cli installation.${RESET}"
            echo -e "${YELLOW}Note:${RESET} Some magnet links may not work without transmission-cli."
            echo ""
        fi
    fi
    
    # Note: Player preference will be checked when streaming starts
    # This avoids prompting during catalog browsing
}

# Show help
show_help() {
    echo -e "${BOLD}${MAGENTA}Termflix${RESET} ${CYAN}- Torrent Streaming Tool${RESET}"
    echo
    echo "Stream torrents directly to mpv or VLC player using peerflix."
    echo
    echo -e "${PINK}Usage:${RESET}"
    echo "  termflix                                    Show latest movies and shows (default)"
    echo "  termflix <magnet_link>"
    echo "  termflix <torrent_file>"
    echo "  termflix search <query>"
    echo "  termflix latest [movies|shows|all]"
    echo "  termflix trending [movies|shows|all]"
    echo "  termflix popular [movies|shows|all]"
    echo "  termflix catalog [genre]"
    echo
    echo -e "${PINK}Options:${RESET}"
    echo "  -h, --help          Show this help"
    echo "  -l, --list          List available files in torrent"
    echo "  -i, --index <num>   Select specific file by index"
    echo "  -q, --quality       Auto-select best quality"
    echo "  -s, --subtitles     Enable subtitle loading (auto-detected if available)"
    echo "  -v, --verbose       Verbose output"
    echo "      --debug         Show debug information (magnet links, etc.)"
    echo "      --clear         Clear catalog cache files"
    echo
    echo -e "${PINK}Commands:${RESET}"
    echo "  player <mpv|vlc>    Change default media player preference"
    echo
    echo -e "${PINK}Examples:${RESET}"
    echo "  termflix                                    # Show latest movies and shows"
    echo "  termflix \"magnet:?xt=urn:btih:...\""
    echo "  termflix movie.torrent"
    echo "  termflix search \"movie name\""
    echo "  termflix latest movies"
    echo "  termflix trending shows"
    echo "  termflix catalog action"
    echo
    echo -e "${PINK}Catalog Features:${RESET}"
    echo "  - Browse latest movies and TV shows (like Stremio)"
    echo "  - View trending and popular content"
    echo "  - Browse by genre/category"
}

# Search using YTS API (movies) - same as Stremio YTS addon
# Uses same approach as YTS-Streaming app
search_yts() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}YTS${MAGENTA}]${RESET} Searching movies..." >&2
    
    if ! command -v python3 &> /dev/null; then
        echo -e "${YELLOW}Warning:${RESET} python3 required for YTS scraping" >&2
        return 1
    fi
    
    export YTS_QUERY="$query"
    python3 "$TERMFLIX_SCRIPTS_DIR/search_yts.py"
}

# Search using YTSRS (en.ytsrs.com) - web crawler approach
search_ytsrs() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}YTS${MAGENTA}]${RESET} Searching movies..." >&2
    
    if ! command -v python3 &> /dev/null; then
        return 1
    fi

    # Pass query as argument to python script
    python3 - "$query" << 'PYEOF'
import sys, re, json, urllib.parse, urllib.request, os

def scrape_yts_movies(sort='date_added', order='desc', limit=20, page=1, genre=None, quality='1080p', keyword=None):
    """Scrape movies from YTS website - uses working domains: yts.rs and yts.hn"""
    domains = ['https://yts.mx', 'https://yts.ag', 'https://yts.am', 'https://yts.pm', 'https://yts.lt', 'https://yts.rs', 'https://yts.hn']
    base_url = None
    
    # Test which domain works
    for domain in domains:
        try:
            req = urllib.request.Request(f"{domain}/browse-movies", headers={'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'})
            with urllib.request.urlopen(req, timeout=5) as response:
                if response.status == 200:
                    base_url = domain
                    break
        except: continue
    
    if not base_url: base_url = 'https://yts.rs'
    
    # Build browse URL
    url = f"{base_url}/browse-movies"
    params = []
    if sort: params.append(f"sort_by={sort}")
    if keyword: params.append(f"keyword={urllib.parse.quote(keyword)}")
    
    if params: url += "?" + "&".join(params)
    
    try:
        req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'})
        with urllib.request.urlopen(req, timeout=15) as response:
            html = response.read().decode('utf-8', errors='ignore')
    except: return []
    
    if not html: return []
    
    movie_links = re.findall(r'<a[^>]+href="/movies/([^"]+)"[^>]*class="[^"]*browse-movie-link[^"]*"[^>]*>', html)
    if not movie_links:
        movie_links = re.findall(r'<a[^>]+href="/movies/([^"]+)"[^>]*>', html)
    
    count = 0
    for slug in movie_links[:limit]:
        try:
            movie_url = f"{base_url}/movies/{slug}"
            req = urllib.request.Request(movie_url, headers={'User-Agent': 'Mozilla/5.0'})
            with urllib.request.urlopen(req, timeout=10) as response:
                movie_html = response.read().decode('utf-8', errors='ignore')
            
            title_match = re.search(r'<h1[^>]*>([^<]+)</h1>', movie_html)
            if not title_match: continue
            title = title_match.group(1).strip()
            
            year_match = re.search(r'<span[^>]*class="[^"]*year[^"]*"[^>]*>(\d{4})</span>', movie_html)
            year = year_match.group(1) if year_match else None
            
            poster_match = re.search(r'<img[^>]+class="[^"]*movie-poster[^"]*"[^>]+src="([^"]+)"', movie_html)
            poster = poster_match.group(1) if poster_match else 'N/A'
            if poster.startswith('/'): poster = f"{base_url}{poster}"
            
            hash_match = re.search(r'magnet:\?xt=urn:btih:([a-fA-F0-9]{40})', movie_html)
            if not hash_match: hash_match = re.search(r'data-hash="([a-fA-F0-9]{40})"', movie_html)
            if not hash_match: continue
            hash_val = hash_match.group(1)
            
            quality_match = re.search(r'<span[^>]*class="[^"]*quality[^"]*"[^>]*>([^<]+)</span>', movie_html, re.IGNORECASE)
            quality = quality_match.group(1).strip() if quality_match else "1080p"
            
            size_match = re.search(r'<span[^>]*class="[^"]*size[^"]*"[^>]*>([^<]+)</span>', movie_html, re.IGNORECASE)
            size = size_match.group(1).strip() if size_match else 'N/A'
            
            seeds_match = re.search(r'<span[^>]*class="[^"]*seeds[^"]*"[^>]*>(\d+)</span>', movie_html, re.IGNORECASE)
            seeds = int(seeds_match.group(1)) if seeds_match else 0
            
            year_str = f" ({year})" if year else ""
            extra = f"{seeds} seeds"
            print(f"YTS|{title}{year_str}|magnet:?xt=urn:btih:{hash_val}|{quality}|{size}|{extra}|{poster}", flush=True)
            count += 1
        except: continue

if __name__ == '__main__':
    keyword = sys.argv[1] if len(sys.argv) > 1 else None
    scrape_yts_movies(keyword=keyword, sort='seeds', limit=20)
PYEOF
    return 0
}



# Group results by Title and Year using external Python script
group_results() {
    tee /tmp/termflix_last_input.txt | python3 "$TERMFLIX_SCRIPTS_DIR/group_results.py" 2>/tmp/termflix_last_error.log
}

# Search using 1337x API - same as Stremio 1337x addon
search_1337x() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}1337x${MAGENTA}]${RESET} Searching..." >&2
    
    if ! command -v python3 &> /dev/null; then
        return 1
    fi
    
    export SEARCH_QUERY="$query"
    python3 "$TERMFLIX_SCRIPTS_DIR/search_1337x.py" 2>/tmp/termflix_last_error.log
}

# Search using ThePirateBay API - same as Stremio TPB addon
search_tpb() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}ThePirateBay${MAGENTA}]${RESET} Searching..." >&2
    
    if ! command -v python3 &> /dev/null; then
        return 1
    fi
    
    export SEARCH_QUERY="$query"
    python3 "$TERMFLIX_SCRIPTS_DIR/search_tpb.py" 2>/tmp/termflix_last_error.log
}

# Search using EZTV API (TV shows) - same as Stremio EZTV addon
search_eztv() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}EZTV${MAGENTA}]${RESET} Searching TV shows..." >&2
    
    if ! command -v python3 &> /dev/null; then
        return 1
    fi
    
    export SEARCH_QUERY="$query"
    python3 "$TERMFLIX_SCRIPTS_DIR/search_eztv.py" 2>/tmp/termflix_last_error.log
}

# Scrape movies from YTSRS (en.ytsrs.com) using external Python script
# Supports genre, quality, sort parameters
get_ytsrs_movies() {
    local genre="${1:-}"
    local quality="${2:-1080p}"
    local sort="${3:-seeds}"
    local limit="${4:-20}"
    local page="${5:-1}"

    if ! command -v python3 &> /dev/null; then
        return 1
    fi
    
    
    python3 "$TERMFLIX_SCRIPTS_DIR/get_ytsrs_movies.py" "$sort" "$limit" "$page" "$genre"
    return 0
}
# Helper function to get source name from function name
get_source_name() {
    local func_name="$1"
    case "$func_name" in
        get_latest_movies|get_trending_movies|get_popular_movies|get_catalog_by_genre)
            echo "YTS"
            ;;
        get_latest_shows)
            echo "EZTV"
            ;;
        search_ytsrs|get_ytsrs_movies)
            echo "YTS"
            ;;
        search_tpb)
            echo "TPB"
            ;;
        search_eztv)
            echo "EZTV"
            ;;
        search_1337x)
            echo "1337x"
            ;;
        *)
            echo "Unknown"
            ;;
    esac
}

# Get latest movies from YTS (like Stremio catalog)
# Uses same approach as YTS-Streaming app
# Supports pagination via page parameter
get_latest_movies() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Try YTS first (same as YTS-Streaming app)
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching latest movies..." >&2
    
    # Build URL the same way as YTS-Streaming app (with pagination)
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?limit=${limit}&sort_by=date_added&order_by=desc&page=${page}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        # Try with timeout - YTS API may be slow or down
        local response=$(curl -s --max-time 3 --connect-timeout 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                # Get movies and their torrents - same structure as YTS-Streaming
                # Include poster URL (medium_cover_image)
                local results=$(echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.date_uploaded // "N/A")|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20)
                
                if [ -n "$results" ]; then
                    echo "$results"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fallback to TPB if YTS fails (YTS API is often down)
    echo -e "${YELLOW}[TPB]${RESET} YTS unavailable, using ThePirateBay..." >&2
    # TPB doesn't have pagination in precompiled, so we fetch more and paginate client-side
    local tpb_url="https://apibay.org/precompiled/data_top100_207.json"
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local tpb_response=$(curl -s --max-time 5 "$tpb_url" 2>/dev/null)
        if [ -n "$tpb_response" ]; then
            # Fetch all available and let display_catalog handle pagination
            echo "$tpb_response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB|Latest"' 2>/dev/null
        fi
    fi
}

# Get trending movies from YTS
# Uses same approach as YTS-Streaming app
# Supports pagination via page parameter
get_trending_movies() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching trending movies..." >&2
    
    # Build URL the same way as YTS-Streaming app (with pagination)
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?limit=${limit}&sort_by=download_count&order_by=desc&page=${page}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 3 --connect-timeout 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                local results=$(echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.download_count // 0)|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20)
                
                if [ -n "$results" ]; then
                    echo "$results"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fallback to TPB trending
    echo -e "${YELLOW}[TPB]${RESET} YTS unavailable, using ThePirateBay trending..." >&2
    local tpb_url="https://apibay.org/precompiled/data_top100_201.json"
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local tpb_response=$(curl -s --max-time 5 "$tpb_url" 2>/dev/null)
        if [ -n "$tpb_response" ]; then
            # Fetch all available for pagination
            echo "$tpb_response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB|Trending"' 2>/dev/null
        fi
    fi
}

# Get popular movies from YTS
# Uses same approach as YTS-Streaming app
# Supports pagination via page parameter
get_popular_movies() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching popular movies..." >&2
    
    # Build URL the same way as YTS-Streaming app (with pagination)
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?limit=${limit}&sort_by=rating&order_by=desc&minimum_rating=7&page=${page}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 3 --connect-timeout 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                local results=$(echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year)) - ⭐\(.rating // "N/A")|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.rating // "N/A")|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20)
                
                if [ -n "$results" ]; then
                    echo "$results"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fallback to TPB popular
    echo -e "${YELLOW}[TPB]${RESET} YTS unavailable, using ThePirateBay popular..." >&2
    local tpb_url="https://apibay.org/precompiled/data_top100_205.json"
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local tpb_response=$(curl -s --max-time 5 "$tpb_url" 2>/dev/null)
        if [ -n "$tpb_response" ]; then
            # Fetch all available for pagination
            echo "$tpb_response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB|Popular"' 2>/dev/null
        fi
    fi
}

# Get latest TV shows from EZTV
# Supports pagination via page parameter
get_latest_shows() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[EZTV]${RESET} Fetching latest TV shows..." >&2
    
    local api_url="https://eztv.re/api/get-torrents?limit=$limit&page=$page"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 5 "$api_url" 2>/dev/null)
        local count=$(echo "$response" | jq -r '.torrents_count // 0' 2>/dev/null)
        
        if [ "$count" -gt 0 ] 2>/dev/null; then
            echo "$response" | jq -r '.torrents[]? | select(.magnet_url != null and .magnet_url != "") | "EZTV|\(.title)|\(.magnet_url)|\(.seeds) seeds|\(.size_bytes / 1024 / 1024 | floor)MB|\(.date_released_unix // 0)"' 2>/dev/null
        fi
    fi
}

# Get catalog by genre
# Uses same approach as YTS-Streaming app
get_catalog_by_genre() {
    local genre="$1"
    local limit="${2:-20}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching $genre movies..." >&2
    
    # Map common genre names to YTS genre IDs (same as YTS-Streaming)
    local genre_id=""
    case "$(echo "$genre" | tr '[:upper:]' '[:lower:]')" in
        action) genre_id="Action" ;;
        adventure) genre_id="Adventure" ;;
        animation) genre_id="Animation" ;;
        comedy) genre_id="Comedy" ;;
        crime) genre_id="Crime" ;;
        documentary) genre_id="Documentary" ;;
        drama) genre_id="Drama" ;;
        family) genre_id="Family" ;;
        fantasy) genre_id="Fantasy" ;;
        horror) genre_id="Horror" ;;
        mystery) genre_id="Mystery" ;;
        romance) genre_id="Romance" ;;
        sci-fi|scifi|science-fiction) genre_id="Sci-Fi" ;;
        thriller) genre_id="Thriller" ;;
        war) genre_id="War" ;;
        western) genre_id="Western" ;;
        *) genre_id="$genre" ;;
    esac
    
    # Build URL the same way as YTS-Streaming app
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?genre=${genre_id}&limit=${limit}&sort_by=date_added&order_by=desc"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        # Add User-Agent header like browsers do
        local response=$(curl -s --max-time 10 --retry 1 --retry-delay 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.genres | join(", "))|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20
            fi
        fi
    fi
}

# Helper function to redraw a specific page from cached results
# This function displays a page without re-fetching data
redraw_catalog_page() {
    local title="$1"
    local cached_results_ref="$2"  # Name of array variable containing cached results
    local page="$3"
    local per_page="$4"
    local total="$5"
    
    # Get the cached results array
    eval "local all_results=(\"\${${cached_results_ref}[@]}\")"
    
    # Check if results are already grouped (contain COMBINED entries)
    # If not, group them to remove duplicates
    local needs_grouping=true
    for result in "${all_results[@]}"; do
        IFS='|' read -r result_source _ <<< "$result"
        if [[ "$result_source" == "COMBINED" ]]; then
            needs_grouping=false
            break
        fi
    done
    
    # Group results to remove duplicates (only if not already grouped)
    if [ "$needs_grouping" = true ] && [ ${#all_results[@]} -gt 0 ]; then
        local grouped_results=()
        # Create temp file for grouping
        local group_input=$(mktemp)
        printf "%s\n" "${all_results[@]}" > "$group_input"
        
        # Run grouping
        local group_output=$(cat "$group_input" | group_results 2>/dev/null)
        
        # Read back into array
        if [ -n "$group_output" ]; then
             while IFS= read -r line || [ -n "$line" ]; do
                 grouped_results+=("$line")
             done <<< "$group_output"
             all_results=("${grouped_results[@]}")
             total=${#all_results[@]}
        fi
        rm -f "$group_input"
    fi
    
    # Calculate pagination
    local total_pages=$(( (total + per_page - 1) / per_page ))
    if [ "$total_pages" -eq 0 ]; then total_pages=1; fi
    local start_idx=$(( (page - 1) * per_page ))
    local end_idx=$(( start_idx + per_page ))
    
    # Clear screen and redraw
    clear
    echo -e "${BOLD}${YELLOW}$title${RESET}\n"
    
    # Display pagination info
    echo -e "${BOLD}${GREEN}Found ${total} results${RESET} (Page ${page}/${total_pages})"
    
    # Check if we have any results with posters
    local has_posters=false
    for result in "${all_results[@]}"; do
        IFS='|' read -r result_source result_name result_magnet result_quality result_size result_extra result_poster <<< "$result"
        
        # Handle COMBINED entries
        if [[ "$result_source" == "COMBINED" ]]; then
            # COMBINED|Name|Sources|Seeds|Qualities|Sizes|Magnets|Poster
            IFS='|' read -r _ _ _ _ _ _ _ result_poster <<< "$result"
        fi
        
        if [[ -n "$result_poster" ]] && [[ "$result_poster" != "N/A" ]]; then
            has_posters=true
            break
        fi
    done
    
    # Show note about posters
    if [ "$has_posters" = false ] && check_viu >/dev/null 2>&1; then
        echo -e "${YELLOW}Note:${RESET} Movie posters are not available for these results."
    elif [ "$has_posters" = true ] && ! check_viu >/dev/null 2>&1; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            echo -e "${YELLOW}Note:${RESET} Install ${CYAN}viu${RESET} to see movie posters: ${CYAN}brew install viu${RESET} or ${CYAN}cargo install viu${RESET}"
        else
            echo -e "${YELLOW}Note:${RESET} Install ${CYAN}viu${RESET} to see movie posters: ${CYAN}cargo install viu${RESET}"
        fi
    fi
    echo
    
    # Display results in grid layout (same logic as before)
    local term_cols=$(tput cols)
    local num_cols=$((term_cols / 40))
    if [ "$num_cols" -lt 1 ]; then num_cols=1; fi
    if [ "$num_cols" -gt 5 ]; then num_cols=5; fi
    
    local index=$start_idx
    local current_start_row=5
    local term_lines=$(tput lines)
    local term_cols=$(tput cols)
    local row_height=21  # Must match row_height in draw_grid_row function
    local scroll_offset=0  # Track how much we've scrolled (for cursor position calculations)
    
    local row_items=()
    local row_count=0
    
    tput cup "$current_start_row" 0
    echo
    
    while [ $index -lt $end_idx ] && [ $index -lt $total ]; do
        local result="${all_results[$index]}"
        
        if [ -z "$result" ]; then
            index=$((index + 1))
            continue
        fi
        
        row_items+=("$result")
        row_count=$((row_count + 1))
        
        if [ $row_count -eq $num_cols ] || [ $index -eq $((end_idx - 1)) ] || [ $index -eq $((total - 1)) ]; then
            # Parallel Fetching of Posters (same as before)
            local pids=()
            local temp_files=()
            local fetch_indices=()
            local fetching=false
            
            for i in "${!row_items[@]}"; do
                local item="${row_items[$i]}"
                IFS='|' read -r source name magnet quality size extra poster_url <<< "$item"
                
                # Check if item is COMBINED
                if [[ "$source" == "COMBINED" ]]; then
                    # Parse COMBINED format: COMBINED|Name|Sources|Seeds|Qualities|Sizes|Magnets|Poster
                    IFS='|' read -r _ c_name _ _ _ _ _ c_poster <<< "$item"
                    name="$c_name"
                    poster_url="$c_poster"
                fi
                
                local title_year=$(echo "$name" | sed -E 's/\./ /g')
                local year=$(echo "$title_year" | grep -oE '\(?[0-9]{4}\)?' | head -1 | tr -d '()')
                
                # Careful title cleaning: remove year and everything after, remove brackets
                local title_clean1=$(echo "$title_year" | sed -E "s/\\(${year}\\).*//")
                local title_clean2=$(echo "$title_clean1" | sed -E "s/ ${year}.*//")
                local clean_title=$(echo "$title_clean2" | sed 's/\[.*\]//g' | xargs)
                
                if [[ -z "$poster_url" ]] || [[ "$poster_url" == "N/A" ]]; then
                    if [ -n "$clean_title" ]; then
                        fetching=true
                        local temp_file=$(mktemp)
                        temp_files[$i]="$temp_file"
                        fetch_indices+=($i)
                        (
                            local new_poster=$(fetch_tmdb_poster "$clean_title" "$year")
                            echo "$new_poster" > "$temp_file"
                        ) &
                        pids+=($!)
                    fi
                else
                    local cache_dir=$(get_termflix_cache_dir)/tmdb
                    local cache_key=$(echo "${clean_title}_${year}" | tr -cd '[:alnum:]')
                    local cache_file="$cache_dir/${cache_key}.json"
                    
                    if [ ! -f "$cache_file" ] && [ -n "$clean_title" ]; then
                        (
                            fetch_tmdb_poster "$clean_title" "$year" > /dev/null 2>&1
                        ) &
                        pids+=($!)
                    fi
                fi
            done
            
            if [ "$fetching" = true ]; then
                tput sc
                echo -ne "${YELLOW}Fetching posters...${RESET}"
                for pid in "${pids[@]}"; do
                    wait "$pid" 2>/dev/null
                done
                tput rc
                tput el
                
                for i in "${fetch_indices[@]}"; do
                    local temp_file="${temp_files[$i]}"
                    if [ -f "$temp_file" ]; then
                        local new_poster=$(cat "$temp_file")
                        rm -f "$temp_file"
                        if [ -n "$new_poster" ] && [ "$new_poster" != "N/A" ]; then
                            local item="${row_items[$i]}"
                            IFS='|' read -r source name magnet quality size extra old_poster <<< "$item"
                            
                            # Handle COMBINED entries - preserve the COMBINED format
                            if [[ "$source" == "COMBINED" ]]; then
                                # COMBINED|Name|Sources|Seeds|Qualities|Sizes|Magnets|Poster
                                IFS='|' read -r _ c_name c_sources c_seeds c_qualities c_sizes c_magnets _ <<< "$item"
                                row_items[$i]="COMBINED|$c_name|$c_sources|$c_seeds|$c_qualities|$c_sizes|$c_magnets|$new_poster"
                            else
                                row_items[$i]="$source|$name|$magnet|$quality|$size|$extra|$new_poster"
                            fi
                        fi

                    fi
                done
            fi
            
            # Position cursor at current_start_row for this row
            # For first row, this is the initial position (5)
            # For subsequent rows, this is where the previous row ended (next_row from draw_grid_row)
            # This creates a chain: row1 ends at next_row -> row2 starts at next_row -> row2 ends at next_row2 -> etc.
            
            if [ "$current_start_row" -lt 1 ]; then
                current_start_row=1
            fi
            
            # SIMPLIFIED APPROACH: Check if we're getting close to bottom, scroll if needed
            # When cursor approaches bottom (within 23 lines), scroll up and recalculate position
            local available_lines=$((term_lines - current_start_row))
            local scroll_threshold=23  # Scroll when we're within 23 lines of bottom
            
            # If we're getting close to the bottom, scroll up to make room
            if [ "$available_lines" -lt "$scroll_threshold" ] || [ "$current_start_row" -ge "$term_lines" ]; then
                # Scroll by outputting newlines - this moves visible content up
                # Scroll enough to ensure we have room for the row (row_height = 21) plus margin
                local scroll_amount=$((row_height + 8))  # Scroll row_height + 8 lines for safety
                
                # Output newlines to scroll the terminal up
                for ((scroll=0; scroll<scroll_amount; scroll++)); do
                    echo
                done
                
                # After scrolling, recalculate where we should start drawing
                # We want to start at a position that gives us enough room for the row
                # Calculate from terminal height: leave row_height + 10 lines of space (further reduced gap)
                local new_start_row=$((term_lines - row_height - 10))
                if [ "$new_start_row" -lt 1 ]; then
                    new_start_row=1
                fi
                
                # Update current_start_row to the new calculated position
                current_start_row=$new_start_row
                
                # Position cursor at the new start row
                tput cup "$current_start_row" 0
            else
                # We have enough space, just position cursor at current_start_row
                tput cup "$current_start_row" 0
            fi
            
            local item_start_index=$((index - row_count + 1))
            if [ "$item_start_index" -lt 0 ]; then
                item_start_index=0
            fi
            
            # Draw the row - this function will position the cursor at next_row when done
            local temp_return=$(mktemp)
            draw_grid_row "$current_start_row" "$item_start_index" "$num_cols" "${row_items[@]}" 2>"$temp_return"
            local next_row
            next_row=$(tail -1 "$temp_return" 2>/dev/null | grep -E '^[0-9]+$' | tail -1)
            rm -f "$temp_return"
            
            # Fallback if next_row wasn't returned correctly
            if ! [[ "$next_row" =~ ^[0-9]+$ ]] || [ -z "$next_row" ]; then
                next_row=$((current_start_row + row_height))
            fi
            
            # CRITICAL: Use next_row as the starting point for the next row
            # draw_grid_row already positioned the cursor at next_row, so we just update
            # current_start_row to use for the next iteration. This creates a chain where
            # each row starts exactly where the previous row ended.
            # 
            # Note: If we scrolled before drawing this row, we already adjusted current_start_row,
            # and draw_grid_row calculated next_row from that adjusted position, so next_row
            # should already be correct relative to the scrolled screen.
            current_start_row=$next_row
            
            # draw_grid_row already positioned cursor at (next_row, 0), so we're ready
            # for the next iteration. The scroll check at the start of next iteration will
            # handle scrolling if needed.
            
            row_items=()
            row_count=0
        fi
        index=$((index + 1))
    done
    
    # After drawing all rows, current_start_row contains where the last row ended
    # draw_grid_row already positioned the cursor at current_start_row (which is next_row from last draw)
    # Add a couple of blank lines for spacing before navigation
    echo
    echo
    # Cursor is now positioned correctly for navigation text to be displayed
}

# Display catalog results in columns with pagination
display_catalog() {
    local title="$1"
    local all_results=()
    local page="${CATALOG_PAGE:-1}"
    local per_page=20
    shift
    
    # Store original arguments for pagination navigation
    local original_args=("$@")
    
    echo -e "${BOLD}${YELLOW}$title${RESET}\n"
    
    # Initialize termflix directories
    init_termflix_dirs
    
    # Generate cache key from function names and arguments
    local cache_key=$(generate_cache_key "$title" "${original_args[@]}")
    local cache_dir=$(get_termflix_cache_dir)
    local cache_file="$cache_dir/catalog_${cache_key}.txt"
    
    # Check if cache is valid (less than 1 hour old)
    # Also invalidate if cache contains legacy "YTSRS" sources (we now use "YTS")
    # or if result count is suspicious (999 usually implies cache error)
    if [ -f "$cache_file" ] && (grep -q "YTSRS" "$cache_file" || grep -q "No Poster" "$cache_file"); then
         rm -f "$cache_file"
    fi

    if is_cache_valid "$cache_file"; then
        echo -e "${CYAN}Loading from cache...${RESET}"
        # Read results from cache
        local result_count=0
        if [ -f "$cache_file" ] && [ -s "$cache_file" ]; then
            while IFS= read -r line || [ -n "$line" ]; do
                if [ -n "$line" ] && echo "$line" | grep -q '|'; then
                    all_results+=("$line")
                    result_count=$((result_count + 1))
                fi
            done < "$cache_file"
        fi
        
        if [ ${#all_results[@]} -gt 0 ]; then
            # Check if results are already grouped (contain COMBINED entries)
            local is_grouped=false
            for result in "${all_results[@]}"; do
                IFS='|' read -r result_source _ <<< "$result"
                if [[ "$result_source" == "COMBINED" ]]; then
                    is_grouped=true
                    break
                fi
            done
            
            if [ "$is_grouped" = true ]; then
                printf "\r${GREEN}✓ Loaded ${result_count} grouped results from cache${RESET}                    \n"
            else
                printf "\r${GREEN}✓ Loaded ${result_count} results from cache${RESET}                    \n"
            fi
            # Skip to pagination logic
            goto_pagination=true
        else
            goto_pagination=false
        fi
    else
        goto_pagination=false
    fi
    
    # Collect results from all functions passed as arguments
    local temp_file=$(mktemp 2>/dev/null || echo "/tmp/torrent_catalog_$$")
    local args_copy=("$@")
    local arg_idx=0
    local ytsrs_pids=()
    local all_pids=()
    local func_names=()
    
    # Only fetch if cache was not used
    if [ "$goto_pagination" != "true" ]; then
        echo -e "${CYAN}Fetching data from sources (all pages)...${RESET}"
        
        # CRITICAL: Fetch ALL pages at once and cache in memory
        # Fetch pages 1-10 in parallel to get all results
        local max_pages=10
        local page_pids=()
        local page_files=()
        
        while [ $arg_idx -lt ${#args_copy[@]} ]; do
        local func="${args_copy[$arg_idx]}"
        arg_idx=$((arg_idx + 1))
        local source_name=$(get_source_name "$func")
        
        # Call the function with remaining arguments
        local current_page_pids=()
        if [ $arg_idx -lt ${#args_copy[@]} ] && [[ "${args_copy[$arg_idx]}" =~ ^[0-9]+$ ]]; then
            local limit="${args_copy[$arg_idx]}"
            arg_idx=$((arg_idx + 1))
            
            # Fetch all pages (1-10) in parallel for this function
            for p in $(seq 1 $max_pages); do
                local page_file="${temp_file}.${source_name}.page${p}"
                page_files+=("$page_file")
                ($func "$limit" "$p" >> "$page_file" 2>&1) &
                current_page_pids+=($!)
                page_pids+=($!)
            done
        else
            # Fetch all pages (1-10) in parallel for this function
            for p in $(seq 1 $max_pages); do
                local page_file="${temp_file}.${source_name}.page${p}"
                page_files+=("$page_file")
                ($func "$p" >> "$page_file" 2>&1) &
                current_page_pids+=($!)
                page_pids+=($!)
            done
        fi
        
        # Wait for this source's page fetches to complete with dual spinner (spinning in opposite directions)
        local spinner_chars=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
        local spinner_idx1=0
        local spinner_idx2=0
        (
            while true; do
                local any_running=false
                for pid in "${current_page_pids[@]}"; do
                    if kill -0 "$pid" 2>/dev/null; then
                        any_running=true
                        break
                    fi
                done
                [ "$any_running" = false ] && break
                # Charm-style dual spinner: magenta goes backward, cyan goes forward
                printf "\r${MAGENTA}${spinner_chars[$spinner_idx1]}${CYAN}${spinner_chars[$spinner_idx2]}${RESET} Fetching from ${PINK}${source_name}${RESET}..."
                spinner_idx1=$(( (spinner_idx1 - 1 + ${#spinner_chars[@]}) % ${#spinner_chars[@]} ))
                spinner_idx2=$(( (spinner_idx2 + 1) % ${#spinner_chars[@]} ))
                sleep 0.1
            done
            printf "\r${GREEN}✓${RESET} Fetched from ${PINK}${source_name}${RESET}                    \n"
        ) &
        local spinner_pid=$!
        
        # Wait for this source's page fetches to complete
        for pid in "${current_page_pids[@]}"; do
            wait "$pid" 2>/dev/null || true
        done
        
        # Stop spinner
        kill "$spinner_pid" 2>/dev/null || true
        wait "$spinner_pid" 2>/dev/null || true
    done
        
        # Combine all page files into one temp file
        for page_file in "${page_files[@]}"; do
            if [ -f "$page_file" ]; then
                cat "$page_file" >> "$temp_file" 2>/dev/null || true
                rm -f "$page_file" 2>/dev/null || true
            fi
        done
        
        printf "\r${GREEN}✓ Fetched all pages${RESET}                    \n"
        
        
        echo -e "${CYAN}Parsing results...${RESET}"
        
        # Read results from temp file
        local result_count=0
        if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
            while IFS= read -r line || [ -n "$line" ]; do
                if [ -n "$line" ] && echo "$line" | grep -q '|'; then
                    all_results+=("$line")
                    result_count=$((result_count + 1))
                    # Show progress while parsing
                    if [ $((result_count % 5)) -eq 0 ]; then
                        printf "\r${CYAN}Parsing results...${RESET} [%d found]" "$result_count"
                    fi
                fi
            done < "$temp_file"
        fi
        
        rm -f "$temp_file" 2>/dev/null
        
        printf "\r${GREEN}✓ Parsed ${result_count} results${RESET}                    \n"
    fi
    
    if [ ${#all_results[@]} -eq 0 ]; then
        echo -e "${RED}No results found${RESET}"
        echo -e "${YELLOW}Note:${RESET} This might be due to API timeouts or rate limiting."
        echo "Try again in a moment or use: ${CYAN}torrent search \"query\"${RESET}"
        return 1
    fi
    
    echo  # Blank line before results
    
    # Group results BEFORE caching (only if not already grouped)
    local needs_grouping=true
    for result in "${all_results[@]}"; do
        IFS='|' read -r result_source _ <<< "$result"
        if [[ "$result_source" == "COMBINED" ]]; then
            needs_grouping=false
            break
        fi
    done
    
    if [ "$needs_grouping" = true ] && [ ${#all_results[@]} -gt 0 ]; then
        printf "${CYAN}Grouping results...${RESET}"
        local grouped_results=()
        local group_input=$(mktemp)
        printf "%s\n" "${all_results[@]}" > "$group_input"
        local group_output=$(cat "$group_input" | group_results 2>/dev/null)
        if [ -n "$group_output" ]; then
             while IFS= read -r line || [ -n "$line" ]; do
                 grouped_results+=("$line")
             done <<< "$group_output"
             all_results=("${grouped_results[@]}")
        fi
        rm -f "$group_input"
        printf "\r${GREEN}✓ Grouped ${#all_results[@]} results${RESET}                    \n"
        
        # Enrich entries with missing posters from TMDB
        if [ ${#all_results[@]} -gt 0 ]; then
            printf "${CYAN}Fetching posters from TMDB...${RESET}"
            enrich_missing_posters all_results 20  # Enrich up to 20 entries per page
            printf "\r${GREEN}✓ Enriched posters${RESET}                    \n"
        fi
        
        # Save GROUPED results to cache (after grouping and enrichment)
        if [ ${#all_results[@]} -gt 0 ]; then
            printf "%s\n" "${all_results[@]}" > "$cache_file" 2>/dev/null
        fi
    fi
    
    # Calculate pagination
    local total="${#all_results[@]}"
    local total_pages=$(( (total + per_page - 1) / per_page ))
    
    # Store cached results in a variable name for redraw function
    local cached_results_var="cached_results_$$"
    eval "declare -a ${cached_results_var}=()"
    for result in "${all_results[@]}"; do
        eval "${cached_results_var}+=(\"\$result\")"
    done
    
    # Display initial page using redraw function
    redraw_catalog_page "$title" "$cached_results_var" "$page" "$per_page" "$total"
    
    # Interactive selection with pagination using keypress detection
    if [ -t 0 ]; then
        
        # Navigation loop with keypress detection
        local current_page=$page
        local selection=""
        local number_input=""
        
        while true; do
            # Display navigation instructions right after the last row
            # redraw_catalog_page already positioned the cursor correctly (after last row + 2 blank lines)
            # So we can just display navigation directly - no need to reposition cursor
            
            if [ $total_pages -gt 1 ]; then
                echo -e "${CYAN}Navigation:${RESET}"
                echo -e "  ${GREEN}n${RESET} - Next page (press key, no Enter needed)"
                echo -e "  ${GREEN}p${RESET} - Previous page (press key, no Enter needed)"
                echo -e "  ${GREEN}1-${total}${RESET} - Select torrent (type number, press Enter)"
                echo -e "  ${GREEN}q${RESET} or ${GREEN}Esc${RESET} - Cancel/Quit"
                echo
            else
                echo -e "${CYAN}Navigation:${RESET}"
                echo -e "  ${GREEN}1-${total}${RESET} - Select torrent (type number, press Enter)"
                echo -e "  ${GREEN}q${RESET} or ${GREEN}Esc${RESET} - Cancel/Quit"
                echo
            fi
            
            # Setup terminal for keypress detection
            local old_stty
            old_stty=$(stty -g 2>/dev/null) || true
            stty -icanon -echo 2>/dev/null || true
            
            # Read a single keypress
            local key
            if IFS= read -rsn1 key 2>/dev/null; then
                # Handle escape sequences (arrow keys, etc.)
                if [ "$key" = $'\033' ]; then
                    read -rsn1 -t 0.1 key 2>/dev/null || true
                    if [ "$key" = "[" ]; then
                        read -rsn1 -t 0.1 key 2>/dev/null || true
                        # Arrow keys - ignore for now, could add later
                    else
                        # ESC key - cancel
                        key="q"
                    fi
                fi
            else
                # No input or error
                key=""
            fi
            
            # Restore terminal settings
            [ -n "$old_stty" ] && stty "$old_stty" 2>/dev/null || true
            
            # Handle keypress
            case "$key" in
                n|N)
                    if [ $current_page -lt $total_pages ]; then
                        current_page=$((current_page + 1))
                        # Redraw page from cache (no re-fetch)
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        continue
                    else
                        echo -e "${YELLOW}Already on last page.${RESET}"
                        sleep 0.5
                        # Redraw to clear message
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                    fi
                    ;;
                p|P)
                    if [ $current_page -gt 1 ]; then
                        current_page=$((current_page - 1))
                        # Redraw page from cache (no re-fetch)
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        continue
                    else
                        echo -e "${YELLOW}Already on first page.${RESET}"
                        sleep 0.5
                        # Redraw to clear message
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                    fi
                    ;;
                q|Q|$'\033')
                    echo "Cancelled."
                    unset CATALOG_PAGE
                    cleanup_posters
                    return
                    ;;
                [0-9])
                    # Start collecting number input
                    number_input="$key"
                    # Read remaining digits (if any) with normal input mode
                    local old_stty2
                    old_stty2=$(stty -g 2>/dev/null) || true
                    stty icanon echo 2>/dev/null || true
                    echo -ne "${YELLOW}Enter selection: ${number_input}${RESET}"
                    while IFS= read -rsn1 -t 1 key2 2>/dev/null; do
                        if [[ "$key2" =~ [0-9] ]]; then
                            number_input="${number_input}${key2}"
                            echo -ne "$key2"
                        elif [ "$key2" = "" ] || [ "$key2" = $'\n' ] || [ "$key2" = $'\r' ]; then
                            # Enter pressed
                            break
                        elif [ "$key2" = $'\177' ] || [ "$key2" = $'\b' ]; then
                            # Backspace
                            if [ ${#number_input} -gt 1 ]; then
                                number_input="${number_input%?}"
                                echo -ne "\b \b"
                            fi
                        else
                            break
                        fi
                    done
                    [ -n "$old_stty2" ] && stty "$old_stty2" 2>/dev/null || true
                    echo
                    
                    selection="$number_input"
                    number_input=""
                    ;;
                *)
                    # Ignore other keys
                    continue
                    ;;
            esac
            
            # Handle numeric selection
            if [ -n "$selection" ] && [[ "$selection" =~ ^[0-9]+$ ]]; then
                if [ "$selection" -ge 1 ] && [ "$selection" -le "$total" ] 2>/dev/null; then
                    local selected_result
                    eval "selected_result=\"\${${cached_results_var}[$((selection - 1))]}\""

                    IFS='|' read -r source name magnet quality size extra poster_url <<< "$selected_result"
                    
                    # Check if item is COMBINED
                    if [[ "$source" == "COMBINED" ]]; then
                        # Format: COMBINED|Name|Sources|Qualities|Seeds|Sizes|Magnets|Poster
                        IFS='|' read -r _ c_name c_sources c_qualities c_seeds c_sizes c_magnets c_poster <<< "$selected_result"
                        local sources_arr=() 
                        local seeds_arr=()
                        local qualities_arr=()
                        local sizes_arr=()
                        local magnets_arr=()
                        IFS='^' read -ra sources_arr <<< "$c_sources"
                        IFS='^' read -ra seeds_arr <<< "$c_seeds"
                        IFS='^' read -ra qualities_arr <<< "$c_qualities"
                        IFS='^' read -ra sizes_arr <<< "$c_sizes"
                        IFS='^' read -ra magnets_arr <<< "$c_magnets"
                        
                        # Display simple numbered list for version selection
                        echo -e "\n${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                        echo -e "${CYAN}Multiple versions found for:${RESET} ${BOLD}${YELLOW}$c_name${RESET}"
                        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}\n"
                        
                        for i in "${!sources_arr[@]}"; do
                            local src="${sources_arr[$i]}"
                            local qty="${qualities_arr[$i]}"
                            local sz="${sizes_arr[$i]}"
                            local sd="${seeds_arr[$i]}"
                            
                            # Color code sources
                            local src_color=""
                            case "$src" in
                                YTS) src_color="${GREEN}" ;;
                                TPB) src_color="${YELLOW}" ;;
                                EZTV) src_color="${BLUE}" ;;
                                1337x) src_color="${MAGENTA}" ;;
                                *) src_color="${CYAN}" ;;
                            esac
                            
                            echo -e "  ${BOLD}$((i+1)))${RESET} ${src_color}[${src}]${RESET} ${CYAN}${qty}${RESET} - ${sz} (${YELLOW}${sd}${RESET} seeds)"
                        done
                        echo
                        
                        # Get user input
                        local choice_num
                        read -p "Enter choice [1-${#sources_arr[@]}] or 'q' to cancel: " choice_num
                        
                        if [[ "$choice_num" == "q" ]] || [[ "$choice_num" == "Q" ]]; then
                            selection=""
                            redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                            continue
                        fi
                        
                        if [[ "$choice_num" =~ ^[0-9]+$ ]] && [ "$choice_num" -ge 1 ] && [ "$choice_num" -le "${#sources_arr[@]}" ]; then
                            local selected_idx=$((choice_num - 1))
                            source="${sources_arr[$selected_idx]}"
                            magnet="${magnets_arr[$selected_idx]}"
                            quality="${qualities_arr[$selected_idx]}"
                            size="${sizes_arr[$selected_idx]}"
                            name="$c_name"
                        else
                            echo -e "${RED}Invalid choice${RESET}"
                            sleep 1
                            selection=""
                            redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                            continue
                        fi
                    fi
                    
                    # Validate magnet link
                    magnet=$(echo "$magnet" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    if [ -z "$magnet" ] || [[ ! "$magnet" =~ ^magnet: ]]; then
                        echo -e "${RED}Error:${RESET} Invalid or missing magnet link for selected torrent"
                        echo -e "${YELLOW}Debug info:${RESET}"
                        echo "  Source: $source"
                        echo "  Name: $name"
                        echo "  Magnet: '$magnet'"
                        sleep 2
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        selection=""
                        continue
                    fi
                    
                    # Debug output
                    if [ "$TORRENT_DEBUG" = true ]; then
                        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                        echo -e "${CYAN}DEBUG MODE${RESET}"
                        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                        echo -e "${YELLOW}Selected torrent:${RESET}"
                        echo "  Index: $selection"
                        echo "  Source: $source"
                        echo "  Name: $name"
                        echo "  Quality: $quality"
                        echo "  Size: $size"
                        echo -e "${YELLOW}Magnet link:${RESET}"
                        echo "  $magnet"
                        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                        echo
                    fi
                    
                    echo
                    echo -e "${GREEN}Streaming:${RESET} $name"
                    echo
                    
                    # Check dependencies before streaming
                    if [ -z "$TORRENT_TOOL" ]; then
                        check_deps
                    fi
                    
                    # Stream the selected torrent (subtitles auto-detected)
                    stream_torrent "$magnet" "" false false
                    local exit_code=$?
                    
                    # Exit code 2 means player closed normally - return to catalog
                    if [ $exit_code -eq 2 ]; then
                        # Player closed, return to catalog view
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        selection=""
                        continue
                    elif [ $exit_code -ne 0 ]; then
                        # Other error occurred
                        echo
                        echo -e "${YELLOW}Playback failed.${RESET}"
                        echo -e "${YELLOW}Would you like to search for alternative versions of \"$name\"? (y/n)${RESET} "
                        read -r answer
                        if [[ "$answer" =~ ^[Yy]$ ]]; then
                            # Clean up name for search
                            local search_query=$(echo "$name" | tr '.' ' ')
                            search_query=$(echo "$search_query" | sed -E 's/ (1080p|720p|4k|2160p|WEB-DL|BluRay|HDRip|x265|HEVC).*//i')
                            search_query=$(echo "$search_query" | sed -E 's/ \([0-9]{4}\)//')
                            
                            echo -e "${CYAN}Searching for: $search_query${RESET}"
                            search_torrent "$search_query"
                        fi
                        # Redraw catalog after search or if user said no
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        selection=""
                        continue
                    else
                        # Player exited normally (exit code 0) - also return to catalog
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        selection=""
                        continue
                    fi
                    
                    # Exit navigation loop after selection
                    break
                else
                    echo -e "${YELLOW}Invalid selection. Please enter a number between 1 and $total.${RESET}"
                    sleep 1
                    redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                    selection=""
                fi
            fi
        done
        
        # Cleanup
        unset CATALOG_PAGE
        eval "unset ${cached_results_var}"
        cleanup_posters
    fi
}

# Unified search using Stremio-style APIs
search_torrent() {
    local query="$1"
    local all_results=()
    
    echo -e "${BOLD}${YELLOW}Searching for:${RESET} ${BOLD}$query${RESET}"
    echo
    
    # Search all sources (similar to how Stremio aggregates)
    # Collect results into array using process substitution
    {
        search_yts "$query" 2>/dev/null
        search_tpb "$query" 2>/dev/null
        search_eztv "$query" 2>/dev/null
        search_1337x "$query" 2>/dev/null
    } | while IFS= read -r line || [ -n "$line" ]; do
        if [ -n "$line" ] && [[ "$line" =~ \| ]]; then
            all_results+=("$line")
        fi
    done
    
    # Note: Due to pipe creating subshell, we need to use a different approach
    # Let's use a temp file instead and run searches in parallel with timeouts
    local temp_file=$(mktemp 2>/dev/null || echo "/tmp/torrent_$$")
    local search_pids=()
    
    # Run all searches in parallel (each has its own timeout via curl --max-time)
    (search_yts "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_ytsrs "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_tpb "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_eztv "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_1337x "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    
    # Wait for all searches to complete (max 10 seconds total)
    local wait_count=0
    while [ $wait_count -lt 20 ]; do
        local all_done=true
        for pid in "${search_pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                all_done=false
                break
            fi
        done
        if [ "$all_done" = true ]; then
            break
        fi
        sleep 0.5
        wait_count=$((wait_count + 1))
    done
    
    # Kill any remaining processes after timeout
    for pid in "${search_pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
    done
    wait "${search_pids[@]}" 2>/dev/null || true
    
    # Read results from temp file
    if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip empty lines and lines without pipe separator
            if [ -n "$line" ] && echo "$line" | grep -q '|'; then
                # Remove any trailing whitespace
                line=$(echo "$line" | sed 's/[[:space:]]*$//')
                all_results+=("$line")
            fi
        done < "$temp_file"
    fi
    
    rm -f "$temp_file" 2>/dev/null
    
    rm -f "$temp_file" 2>/dev/null
    
    # Group results
    local grouped_results=()
    if [ ${#all_results[@]} -gt 0 ]; then
        local group_input=$(mktemp)
        printf "%s\n" "${all_results[@]}" > "$group_input"
        local group_output=$(cat "$group_input" | group_results)
        if [ -n "$group_output" ]; then
             while IFS= read -r line || [ -n "$line" ]; do
                 grouped_results+=("$line")
             done <<< "$group_output"
             all_results=("${grouped_results[@]}")
        fi
        rm -f "$group_input"
    fi
    
    # Remove duplicates (fallback)
    if [ ${#all_results[@]} -gt 0 ]; then
        local unique_results=()
        local seen_hashes=()
        for result in "${all_results[@]}"; do
            IFS='|' read -r source name magnet quality size extra <<< "$result"
            # Extract hash from magnet link
            local hash=$(echo "$magnet" | grep -oE 'btih:[a-fA-F0-9]+' | cut -d: -f2 | tr '[:upper:]' '[:lower:]')
            if [ -n "$hash" ]; then
                # Check if we've seen this hash before
                local seen=false
                for seen_hash in "${seen_hashes[@]}"; do
                    if [ "$hash" = "$seen_hash" ]; then
                        seen=true
                        break
                    fi
                done
                if [ "$seen" = false ]; then
                    unique_results+=("$result")
                    seen_hashes+=("$hash")
                fi
            else
                # If no hash, just add it (shouldn't happen but be safe)
                unique_results+=("$result")
            fi
        done
        all_results=("${unique_results[@]}")
    fi
    
    if [ ${#all_results[@]} -eq 0 ]; then
        echo -e "${RED}No results found${RESET}"
        echo
        echo "Try:"
        echo "  - Check your internet connection"
        if [[ "$OSTYPE" == "darwin"* ]]; then
            echo "  - Install jq: ${CYAN}brew install jq${RESET}"
            echo "  - Install python3: ${CYAN}brew install python3${RESET} (for YTSRS search)"
        else
            echo "  - Install jq: ${CYAN}sudo apt-get install jq${RESET} (Debian/Ubuntu) or ${CYAN}sudo yum install jq${RESET} (RHEL/CentOS)"
            echo "  - Install python3: ${CYAN}sudo apt-get install python3${RESET} (Debian/Ubuntu) or ${CYAN}sudo yum install python3${RESET} (RHEL/CentOS)"
        fi
        echo "  - Try a different search query"
        echo "  - The search APIs may be temporarily unavailable"
        return 1
    fi
    
    # Display results
    echo -e "${BOLD}${GREEN}Found ${#all_results[@]} results:${RESET}\n"
    
    local index=0
    for result in "${all_results[@]}"; do
        if [ -z "$result" ]; then
            continue
        fi
        
        IFS='|' read -r source name magnet quality size <<< "$result"
        
        if [ -z "$name" ] || [ -z "$magnet" ]; then
            continue
        fi
        
        index=$((index + 1))
        
        local source_color="$CYAN"
        case "$source" in
            YTS) source_color="$GREEN" ;;
            TPB) source_color="$YELLOW" ;;
            EZTV) source_color="$BLUE" ;;
            1337x) source_color="$MAGENTA" ;;
        esac
        
        echo -e "${BOLD}[$index]${RESET} ${source_color}[$source]${RESET} ${BOLD}$name${RESET}"
        if [ "$quality" != "N/A" ] && [ -n "$quality" ] && [ "$quality" != "" ]; then
            echo -e "     Quality: $quality | Size: $size"
        fi
        echo -e "     ${CYAN}$magnet${RESET}"
        echo
    done
    
    # Interactive selection
    if [ -t 0 ]; then
        echo -e "${YELLOW}Select a torrent (1-$index) or press Enter to cancel:${RESET} "
        read -r selection
        
        if [ -n "$selection" ] && [ "$selection" -ge 1 ] && [ "$selection" -le "$index" ] 2>/dev/null; then
            local selected_result="${all_results[$((selection - 1))]}"

            IFS='|' read -r source name magnet quality size extra poster <<< "$selected_result"
            
            # Check if item is COMBINED
            if [[ "$source" == "COMBINED" ]]; then
                # Parse output from group_results
                # Format: COMBINED|Name|Sources|Seeds|Qualities|Sizes|Magnets|Poster
                IFS='|' read -r _ c_name c_sources c_seeds c_qualities c_sizes c_magnets _ <<< "$selected_result"
                
                local sources_arr=() 
                local seeds_arr=()
                local qualities_arr=()
                local sizes_arr=()
                local magnets_arr=()
                
                IFS='^' read -ra sources_arr <<< "$c_sources"
                IFS='^' read -ra seeds_arr <<< "$c_seeds"
                IFS='^' read -ra qualities_arr <<< "$c_qualities"
                IFS='^' read -ra sizes_arr <<< "$c_sizes"
                IFS='^' read -ra magnets_arr <<< "$c_magnets"
                
                echo -e "\n${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo -e "${CYAN}Multiple versions found for:${RESET} ${BOLD}${YELLOW}$c_name${RESET}"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}\n"
                
                local selected_idx=0
                
                if command -v gum &> /dev/null; then
                     echo -e "${GREEN}Select a version:${RESET}"
                     # Create a numbered list for gum
                     local gum_opts=()
                     for i in "${!sources_arr[@]}"; do
                         local src="${sources_arr[$i]}"
                         local qty="${qualities_arr[$i]}"
                         local sz="${sizes_arr[$i]}"
                         local sd="${seeds_arr[$i]}"
                         gum_opts+=("$((i+1)). [${src}] ${qty} - ${sz} (${sd} seeds)")
                     done
                     local choice=$(printf "%s\n" "${gum_opts[@]}" | gum choose --height=10 --cursor="➤ " --header="Available Versions" --header.foreground="212")
                     
                     if [ -n "$choice" ]; then
                         # Extract number from choice (format: "1. ...")
                         local choice_num=$(echo "$choice" | grep -oE '^([0-9]+)' | head -1)
                         if [ -n "$choice_num" ] && [ "$choice_num" -ge 1 ] && [ "$choice_num" -le "${#sources_arr[@]}" ]; then
                             selected_idx=$((choice_num - 1))
                         else
                             return 1
                         fi
                     else
                         return 1
                     fi
                else
                    echo -e "${GREEN}Available versions:${RESET}"
                    for i in "${!sources_arr[@]}"; do
                        local src="${sources_arr[$i]}"
                        local qty="${qualities_arr[$i]}"
                        local sz="${sizes_arr[$i]}"
                        local sd="${seeds_arr[$i]}"
                        
                        # Color code sources
                        local src_color=""
                        case "$src" in
                            YTS) src_color="${GREEN}" ;;
                            TPB) src_color="${YELLOW}" ;;
                            EZTV) src_color="${BLUE}" ;;
                            1337x) src_color="${MAGENTA}" ;;
                            *) src_color="${CYAN}" ;;
                        esac
                        
                        echo -e "  ${BOLD}$((i+1)))${RESET} ${src_color}[${src}]${RESET} ${CYAN}${qty}${RESET} - ${sz} (${YELLOW}${sd}${RESET} seeds)"
                    done
                    echo
                    read -p "Enter choice [1-${#sources_arr[@]}]: " choice_num
                    if [[ "$choice_num" =~ ^[0-9]+$ ]] && [ "$choice_num" -ge 1 ] && [ "$choice_num" -le "${#sources_arr[@]}" ]; then
                        selected_idx=$((choice_num - 1))
                    else
                        return 1
                    fi
                fi
                
                source="${sources_arr[$selected_idx]}"
                magnet="${magnets_arr[$selected_idx]}"
                quality="${qualities_arr[$selected_idx]}"
                size="${sizes_arr[$selected_idx]}"
                name="$c_name"
                
                echo -e "${GREEN}Selected:${RESET} $source $quality - $size"
            fi
            
            # Validate magnet link
            magnet=$(echo "$magnet" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [ -z "$magnet" ] || [[ ! "$magnet" =~ ^magnet: ]]; then
                echo -e "${RED}Error:${RESET} Invalid or missing magnet link for selected torrent"
                echo -e "${YELLOW}Debug info:${RESET}"
                echo "  Source: $source"
                echo "  Name: $name"
                echo "  Magnet: '$magnet'"
                exit 1
            fi
            
            # Debug output
            if [ "$TORRENT_DEBUG" = true ]; then
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo -e "${CYAN}DEBUG MODE${RESET}"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo -e "${YELLOW}Selected torrent:${RESET}"
                echo "  Index: $selection"
                echo "  Source: $source"
                echo "  Name: $name"
                echo "  Quality: $quality"
                echo "  Size: $size"
                echo -e "${YELLOW}Magnet link:${RESET}"
                echo "  $magnet"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo
            fi
            
            echo
            echo -e "${GREEN}Streaming:${RESET} $name"
            echo
            
            # Ensure dependencies are checked before streaming
            if [ -z "$TORRENT_TOOL" ]; then
                check_deps
            fi
            
            # Stream the selected torrent (subtitles auto-detected)
            stream_torrent "$magnet" "" false false
            local exit_code=$?
            
            # Exit code 2 means player closed normally - just return (search results don't have pagination to return to)
            if [ $exit_code -eq 2 ]; then
                # Player closed, just return
                return 0
            elif [ $exit_code -ne 0 ]; then
                # Other error occurred
                echo
                echo -e "${YELLOW}Playback failed.${RESET}"
                echo -e "${YELLOW}Would you like to search for alternative versions of \"$name\"? (y/n)${RESET} "
                read -r answer
                if [[ "$answer" =~ ^[Yy]$ ]]; then
                    # Clean up name for search
                    local search_query=$(echo "$name" | tr '.' ' ')
                    search_query=$(echo "$search_query" | sed -E 's/ (1080p|720p|4k|2160p|WEB-DL|BluRay|HDRip|x265|HEVC).*//i')
                    search_query=$(echo "$search_query" | sed -E 's/ \([0-9]{4}\)//')
                    
                    echo -e "${CYAN}Searching for: $search_query${RESET}"
                    search_torrent "$search_query"
                fi
            fi
        else
            echo "Cancelled."
        fi
    else
        echo -e "${YELLOW}Non-interactive mode. Use:${RESET}"
        echo "  torrent \"<magnet_link>\""
    fi
}

# Check if torrent has subtitle files and return info
has_subtitles() {
    local source="$1"
    
    # List files and check for subtitle extensions
    local file_list=$(peerflix "$source" --list 2>/dev/null || echo "")
    
    if [ -z "$file_list" ]; then
        return 1
    fi
    
    # Check for common subtitle file extensions and extract subtitle file names
    local subtitle_files=$(echo "$file_list" | grep -iE '\.(srt|vtt|ass|ssa|sub|idx)$' || echo "")
    
    if [ -n "$subtitle_files" ]; then
        # Count and list subtitle files found
        local sub_count=$(echo "$subtitle_files" | wc -l | tr -d ' ')
        echo -e "${GREEN}Subtitle found!${RESET} ($sub_count file(s))" >&2
        
        # Print subtitle file names (limit to first 3 to avoid clutter)
        echo "$subtitle_files" | head -3 | while IFS= read -r line; do
            if [ -n "$line" ]; then
                # Extract filename (usually the last part after spaces/tabs)
                # peerflix list format: "index  size  filename"
                local sub_file=$(echo "$line" | awk '{for(i=3;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//' 2>/dev/null || echo "$line")
                if [ -n "$sub_file" ]; then
                    echo -e "  ${CYAN}→${RESET} $sub_file" >&2
                fi
            fi
        done
        
        local total_subs=$(echo "$subtitle_files" | wc -l | tr -d ' ')
        if [ "$total_subs" -gt 3 ]; then
            local remaining=$((total_subs - 3))
            echo -e "  ${CYAN}... and $remaining more${RESET}" >&2
        fi
        
        return 0
    fi
    
    return 1
}

# Stream with peerflix - use peerflix's --subtitles flag properly
stream_peerflix() {
    local source="$1"
    local index="${2:-}"
    local enable_subtitles="${3:-false}"
    
    # Get player preference (will ask if first time, but with timeout to prevent hanging)
    local player=$(get_player_preference)
    
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${GREEN}Streaming with peerflix to $player...${RESET}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    
    # Validate source is a valid magnet link or file
    source=$(echo "$source" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    # Normalize magnet link: ensure hash is lowercase (peerflix may have issues with uppercase)
    if [[ "$source" =~ ^magnet: ]]; then
        # Extract and lowercase the hash
        local hash=$(echo "$source" | grep -oE 'btih:[a-fA-F0-9]+' | cut -d: -f2 | head -1)
        if [ -n "$hash" ]; then
            local hash_lower=$(echo "$hash" | tr '[:upper:]' '[:lower:]')
            # Replace uppercase hash with lowercase
            if [ "$hash" != "$hash_lower" ]; then
                 source="${source/btih:$hash/btih:$hash_lower}"
            fi
        fi
        # Ensure proper magnet link format
        if [[ ! "$source" =~ ^magnet:\?xt=urn:btih: ]]; then
            # Try to fix common issues
            source=$(echo "$source" | sed 's/^magnet:/magnet:?xt=urn:btih:/' | sed 's/btih:\([^&]*\)/btih:\1/')
        fi
        
        # Add common trackers if not present (helps peerflix connect to peers)
        # Some magnet links work with transmission but not peerflix because they lack trackers
        if ! echo "$source" | grep -q "&tr="; then
            local common_trackers=(
                "udp://tracker.openbittorrent.com:80/announce"
                "udp://tracker.opentrackr.org:1337/announce"
                "udp://tracker.coppersurfer.tk:6969/announce"
                "udp://tracker.leechers-paradise.org:6969/announce"
                "udp://tracker.internetwarriors.net:1337/announce"
                "udp://9.rarbg.to:2710/announce"
                "udp://9.rarbg.me:2710/announce"
                "udp://exodus.desync.com:6969/announce"
            )
            
            for tracker in "${common_trackers[@]}"; do
                # URL encode the tracker (magnet links need URL-encoded trackers)
                local encoded_tracker=$(echo "$tracker" | sed 's/:/%3A/g' | sed 's/\//%2F/g' | sed 's/ /%20/g')
                source="${source}&tr=${encoded_tracker}"
            done
        fi
    fi
    
    # Debug output
    if [ "$TORRENT_DEBUG" = true ]; then
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${CYAN}DEBUG: stream_peerflix${RESET}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${YELLOW}Source (raw):${RESET} '$source'"
        echo -e "${YELLOW}Source (cleaned):${RESET} '$(echo "$source" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')'"
        echo -e "${YELLOW}Source length:${RESET} ${#source} characters"
        echo -e "${YELLOW}Is magnet link:${RESET} $([[ "$source" =~ ^magnet: ]] && echo "yes" || echo "no")"
        echo -e "${YELLOW}Is file:${RESET} $([ -f "$source" ] && echo "yes" || echo "no")"
        if [[ "$source" =~ ^magnet: ]]; then
            local hash_debug=$(echo "$source" | grep -oE 'btih:[a-fA-F0-9]+' | cut -d: -f2 | head -1)
            echo -e "${YELLOW}Magnet hash:${RESET} $hash_debug"
            echo -e "${YELLOW}Normalized magnet:${RESET} $source"
        fi
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo
    fi
    
    if [[ ! "$source" =~ ^magnet: ]] && [ ! -f "$source" ]; then
        echo -e "${RED}Error:${RESET} Invalid torrent source: '$source'"
        echo -e "${YELLOW}Expected:${RESET} magnet link (magnet:?xt=...) or path to .torrent file"
        return 1
    fi
    
    local args=("-p" "0")
    
    if [ -n "$index" ]; then
        args+=("-i" "$index")
    fi
    
    # Add quiet flag to reduce verbose output
    args+=("-q")
    
    # Check for subtitles and find the subtitle file path
    local subtitle_file=""
    if [ "$enable_subtitles" = true ] || has_subtitles "$source" >/dev/null 2>&1; then
        echo -e "${CYAN}Checking for subtitles in torrent...${RESET}"
        
        # We need to get the torrent path first to find subtitle files
        # Run peerflix briefly to get the path, then restart with subtitles
        local temp_output=$(mktemp 2>/dev/null || echo "/tmp/peerflix_output_$$")
        
        # Start peerflix briefly to get the path (without auto-launch)
        # This will start downloading the torrent files including subtitles
        peerflix "$source" "${args[@]}" > "$temp_output" 2>&1 &
        local temp_pid=$!
        
        # Wait for peerflix to start and show the path
        echo -e "${YELLOW}Waiting for peerflix to initialize and start downloading...${RESET}"
        sleep 3
        
        # Extract the path from peerflix output
        local torrent_path=""
        local max_wait=15
        local waited=0
        while [ $waited -lt $max_wait ]; do
            if [ -f "$temp_output" ]; then
                # Try multiple patterns to find the path
                torrent_path=$(grep "info path" "$temp_output" 2>/dev/null | head -1 | sed 's/.*info path //' | tr -d '\r\n')
                
                # If not found, try looking for path patterns in the output
                if [ -z "$torrent_path" ]; then
                    torrent_path=$(grep -iE "(path|downloaded|stream)" "$temp_output" 2>/dev/null | grep -oE "/tmp/[^[:space:]]+" | head -1)
                fi
                
                if [ -n "$torrent_path" ] && [ -d "$torrent_path" ]; then
                    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    echo -e "${GREEN}✓ TORRENT PATH FOUND:${RESET}"
                    echo -e "${CYAN}$torrent_path${RESET}"
                    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    echo
                    echo -e "${YELLOW}You can manually verify subtitle files with:${RESET}"
                    echo -e "${CYAN}ls -la \"$torrent_path\"${RESET}"
                    echo -e "${CYAN}find \"$torrent_path\" -name '*.srt'${RESET}"
                    echo
                    break
                fi
            fi
            sleep 1
            waited=$((waited + 1))
        done
        
        # If still not found, show the raw output for debugging
        if [ -z "$torrent_path" ] || [ ! -d "$torrent_path" ]; then
            echo -e "${YELLOW}Warning:${RESET} Could not extract torrent path from peerflix output"
            echo -e "${YELLOW}Peerflix output (last 20 lines):${RESET}"
            tail -20 "$temp_output" 2>/dev/null | while IFS= read -r line; do
                echo "  $line"
            done
        fi
        
        # Wait a bit more for files to actually download (especially subtitle files)
        # Search recursively for subtitle files
        if [ -n "$torrent_path" ] && [ -d "$torrent_path" ]; then
            echo -e "${YELLOW}Waiting for subtitle files to download...${RESET}"
            echo -e "${CYAN}Searching recursively in:${RESET} $torrent_path"
            echo
            
            local download_wait=0
            local max_download_wait=15  # Increased wait time
            
            while [ $download_wait -lt $max_download_wait ]; do
                # List all files in the directory for debugging (recursively)
                if [ $download_wait -eq 0 ] || [ $((download_wait % 3)) -eq 0 ]; then
                    echo -e "${YELLOW}Files in torrent (attempt $((download_wait + 1))):${RESET}"
                    find "$torrent_path" -type f 2>/dev/null | head -10 | while IFS= read -r file; do
                        if [ -n "$file" ]; then
                            local fname=$(basename "$file")
                            local fsize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                            local rel_path="${file#$torrent_path/}"
                            echo -e "  ${CYAN}→${RESET} $fname (${fsize} bytes) [${rel_path}]"
                        fi
                    done
                    echo
                fi
                
                # Check if any subtitle files exist and have content (search recursively)
                local found_sub=$(find "$torrent_path" -type f -iname "*.srt" 2>/dev/null | head -1)
                if [ -z "$found_sub" ]; then
                    found_sub=$(find "$torrent_path" -type f \( -iname "*.vtt" -o -iname "*.ass" -o -iname "*.ssa" \) 2>/dev/null | head -1)
                fi
                
                if [ -n "$found_sub" ] && [ -f "$found_sub" ] && [ -s "$found_sub" ]; then
                    # File exists and has content - it's downloaded
                    subtitle_file=$(realpath "$found_sub" 2>/dev/null || echo "$found_sub")
                    local file_size=$(stat -f%z "$subtitle_file" 2>/dev/null || stat -c%s "$subtitle_file" 2>/dev/null || echo "0")
                    
                    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    echo -e "${GREEN}✓ SRT FOUND!${RESET}"
                    echo -e "  ${CYAN}File:${RESET} $(basename "$subtitle_file")"
                    echo -e "  ${CYAN}Location:${RESET} $subtitle_file"
                    echo -e "  ${CYAN}Size:${RESET} ${file_size} bytes"
                    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    break
                fi
                
                sleep 1
                download_wait=$((download_wait + 1))
            done
            
            if [ -z "$subtitle_file" ]; then
                echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo -e "${YELLOW}⚠ NO SUBTITLE FILE FOUND${RESET}"
                echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo -e "${YELLOW}Torrent path:${RESET} $torrent_path"
                echo -e "${YELLOW}All files in torrent (recursive):${RESET}"
                find "$torrent_path" -type f 2>/dev/null | while IFS= read -r file; do
                    local rel_path="${file#$torrent_path/}"
                    echo -e "  ${CYAN}→${RESET} $rel_path"
                done
                echo
            fi
        fi
        
        # Kill the temp peerflix process
        echo -e "${YELLOW}Stopping temporary peerflix instance...${RESET}"
        kill $temp_pid 2>/dev/null || true
        wait $temp_pid 2>/dev/null || true
        sleep 1  # Give it a moment to clean up
        
        rm -f "$temp_output" 2>/dev/null
    fi
    
    # Don't use peerflix auto-launch - play file directly from local directory
    # Start peerflix in background to download files
    # Note: Remove -q temporarily to get path info, or check output more carefully
    local temp_output=$(mktemp 2>/dev/null || echo "/tmp/peerflix_output_$$")
    local peerflix_pid
    
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${YELLOW}Starting peerflix to download torrent files...${RESET}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    # Remove quiet flag temporarily to see path output (we need "info path" line)
    local temp_args=()
    for arg in "${args[@]}"; do
        if [ "$arg" != "-q" ]; then
            temp_args+=("$arg")
        fi
    done
    peerflix "$source" "${temp_args[@]}" > "$temp_output" 2>&1 &
    peerflix_pid=$!
    
    # Check if peerflix started successfully (wait a moment, then check if process is still running)
    sleep 2
    if ! kill -0 "$peerflix_pid" 2>/dev/null; then
        # Process died - check error output
        if [ -f "$temp_output" ]; then
            local error_output=$(cat "$temp_output" 2>/dev/null)
            if echo "$error_output" | grep -q "Invalid data\|Missing delimiter\|parse-torrent\|bencode\|Error\|Failed"; then
                echo -e "${RED}Error:${RESET} peerflix failed to handle this magnet link"
                echo ""
                
                # Automatically use transmission-cli as fallback if available
                if command -v transmission-cli &> /dev/null; then
                    echo -e "${CYAN}Switching to transmission-cli fallback...${RESET}"
                    echo ""
                    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    echo -e "${CYAN}Streaming with transmission-cli...${RESET}"
                    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    echo ""
                    
                    # Extract hash from magnet link to create unique subdirectory
                    local torrent_hash=""
                    if [[ "$source" =~ ^magnet: ]]; then
                        torrent_hash=$(echo "$source" | grep -oE 'btih:[a-fA-F0-9]+' | cut -d: -f2 | tr '[:upper:]' '[:lower:]' | head -1)
                    fi
                    
                    # If no hash found (shouldn't happen for magnet links), use a timestamp-based hash
                    if [ -z "$torrent_hash" ]; then
                        torrent_hash=$(echo "$source" | shasum -a 256 | cut -d' ' -f1 | cut -c1-40)
                    fi
                    
                    # Create hash-based subdirectory for this specific torrent (easier to search files)
                    local base_dir="/tmp/torrent-stream"
                    local download_dir="$base_dir/$torrent_hash"
                    mkdir -p "$download_dir" 2>/dev/null
                    
                    # Get player preference
                    local player=$(get_player_preference)
                    
                    echo -e "${CYAN}Download directory:${RESET} $download_dir"
                    echo -e "${CYAN}Torrent hash:${RESET} $torrent_hash"
                    echo -e "${CYAN}Player:${RESET} $player"
                    echo -e "${YELLOW}Note:${RESET} It may take a while to connect to peers and start downloading..."
                    echo ""
                    
                    # Capture transmission output to parse progress
                    local transmission_output=$(mktemp 2>/dev/null || echo "/tmp/transmission_output_$$")
                    
                    # Record start time to filter out old files from previous downloads
                    local start_time=$(date +%s)
                    
                    # Run transmission-cli with --download-dir flag using hash-based subdirectory
                    # Use --download-dir explicitly to ensure it's used (transmission-cli may have config file defaults)
                    # Note: transmission-cli may create subdirectories within the download directory
                    # We'll search recursively to find the actual video files
                    # Check for transmission config and temporarily override download directory if needed
                    local transmission_config_dir="$HOME/.config/transmission"
                    local transmission_config="$transmission_config_dir/settings.json"
                    local config_backup=""
                    local original_download_dir=""
                    
                    # Auto-create config directory and file if they don't exist
                    if [ ! -d "$transmission_config_dir" ]; then
                        mkdir -p "$transmission_config_dir" 2>/dev/null
                        echo -e "${CYAN}Created transmission config directory:${RESET} $transmission_config_dir"
                    fi
                    
                    if [ ! -f "$transmission_config" ]; then
                        # Create default config file with download-dir set to /tmp/torrent-transmission/
                        # Matching the exact format of the existing settings.json
                        cat > "$transmission_config" << 'EOF'

"download-dir": "/tmp/torrent-transmission/"
EOF
                        echo -e "${CYAN}Created transmission config file:${RESET} $transmission_config"
                    fi
                    
                    if [ -f "$transmission_config" ]; then
                        # Backup the config file
                        config_backup=$(mktemp 2>/dev/null || echo "/tmp/transmission_config_backup_$$.json")
                        cp "$transmission_config" "$config_backup" 2>/dev/null
                        
                        # Read current download-dir setting
                        if command -v jq &> /dev/null; then
                            original_download_dir=$(jq -r '.["download-dir"] // empty' "$transmission_config" 2>/dev/null)
                            
                            # Temporarily set download-dir to our hash-based directory
                            jq --arg dir "$download_dir" '.["download-dir"] = $dir' "$transmission_config" > "${transmission_config}.tmp" 2>/dev/null && \
                                mv "${transmission_config}.tmp" "$transmission_config" 2>/dev/null
                        elif command -v python3 &> /dev/null; then
                            # Fallback to Python if jq is not available
                            python3 << EOF 2>/dev/null
import json
import sys
try:
    with open("$transmission_config", 'r') as f:
        config = json.load(f)
    original_download_dir = config.get('download-dir', '')
    config['download-dir'] = '$download_dir'
    with open("$transmission_config", 'w') as f:
        json.dump(config, f, indent=4)
    print(original_download_dir)
except:
    pass
EOF
                            original_download_dir=$(python3 -c "import json; f=open('$transmission_config'); d=json.load(f); print(d.get('download-dir', ''))" 2>/dev/null || echo "")
                        else
                            # Fallback: use sed to modify JSON (less reliable but works for simple cases)
                            original_download_dir=$(grep -oE '"download-dir"[[:space:]]*:[[:space:]]*"[^"]*"' "$transmission_config" 2>/dev/null | cut -d'"' -f4 || echo "")
                            # Escape the directory path for sed
                            local escaped_dir=$(echo "$download_dir" | sed 's/[[\.*^$()+?{|]/\\&/g')
                            sed -i.bak "s|\"download-dir\"[[:space:]]*:[[:space:]]*\"[^\"]*\"|\"download-dir\": \"$escaped_dir\"|g" "$transmission_config" 2>/dev/null
                            rm -f "${transmission_config}.bak" 2>/dev/null
                        fi
                        
                        echo -e "${CYAN}Note:${RESET} Temporarily overriding transmission config download directory"
                    fi
                    
                    # Run transmission-cli with both --config-dir and --download-dir to ensure it uses our modified config
                    local transmission_config_dir="$HOME/.config/transmission"
                    if [ -d "$transmission_config_dir" ]; then
                        transmission-cli --config-dir "$transmission_config_dir" --download-dir "$download_dir" "$source" > "$transmission_output" 2>&1 &
                    else
                        transmission-cli --download-dir "$download_dir" "$source" > "$transmission_output" 2>&1 &
                    fi
                    local transmission_pid=$!
                    
                    # Wait a moment for transmission-cli to start and check if it's still running
                    sleep 2
                    
                    # Verify the download directory exists and is writable
                    if [ ! -d "$download_dir" ] || [ ! -w "$download_dir" ]; then
                        echo -e "${YELLOW}Warning:${RESET} Download directory may not be accessible: $download_dir"
                        echo -e "${CYAN}Creating directory...${RESET}"
                        mkdir -p "$download_dir" 2>/dev/null || {
                            echo -e "${RED}Error:${RESET} Cannot create download directory"
                            kill $transmission_pid 2>/dev/null || true
                            # Restore original transmission config if we modified it
                            if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                                cp "$config_backup" "$transmission_config" 2>/dev/null
                                rm -f "$config_backup" 2>/dev/null
                            fi
                            rm -f "$transmission_output" 2>/dev/null
                            rm -f "$temp_output" 2>/dev/null
                            return 1
                        }
                    fi
                    
                    # Check if transmission-cli process is still running
                    if ! kill -0 "$transmission_pid" 2>/dev/null; then
                        echo -e "${RED}Error:${RESET} transmission-cli failed to start"
                        if [ -f "$transmission_output" ]; then
                            echo -e "${YELLOW}Transmission output:${RESET}"
                            cat "$transmission_output" | head -20
                        fi
                        # Restore original transmission config if we modified it
                        if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                            cp "$config_backup" "$transmission_config" 2>/dev/null
                            rm -f "$config_backup" 2>/dev/null
                        fi
                        rm -f "$transmission_output" 2>/dev/null
                        rm -f "$temp_output" 2>/dev/null
                        return 1
                    fi
                    
                    # Check for immediate errors in output
                    if [ -f "$transmission_output" ]; then
                        local error_check=$(grep -iE "(error|failed|cannot|unable)" "$transmission_output" 2>/dev/null | head -3)
                        if [ -n "$error_check" ]; then
                            echo -e "${YELLOW}Warning:${RESET} Possible errors detected:"
                            echo "$error_check" | while IFS= read -r line; do
                                echo -e "  ${YELLOW}→${RESET} $line"
                            done
                            echo ""
                        fi
                    fi
                    
                    echo -e "${GREEN}Transmission started (PID: $transmission_pid)${RESET}"
                    echo -e "${CYAN}Connecting to peers and downloading metadata...${RESET}"
                    echo -e "${CYAN}This typically takes 8-30 seconds depending on tracker response.${RESET}"
                    echo ""
                    
                    # Wait a bit for transmission to recognize the torrent and start downloading
                    # Based on user testing: ~4s to recognize torrent, ~8s to show progress
                    echo -e "${CYAN}Waiting for transmission to initialize...${RESET}"
                    sleep 5
                    
                    # Wait for video file to appear - transmission-cli takes time to connect to peers
                    # Increased timeout significantly: 5 minutes (600 iterations * 0.5s)
                    # User testing shows ~32s total startup time, so 5 minutes is safe
                    local video_file=""
                    local video_wait=0
                    local max_video_wait=600  # 5 minutes * 60 / 0.5
                    
                    # Also check if transmission process is still running during the wait
                    
                    while [ $video_wait -lt $max_video_wait ]; do
                        # Find the largest video file in the hash-specific directory
                        # This ensures we only find files from this specific torrent
                        video_file=$(find "$download_dir" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.mov" -o -iname "*.webm" -o -iname "*.m4v" \) 2>/dev/null | \
                            while IFS= read -r file; do
                                if [ -f "$file" ] && [ -s "$file" ]; then
                                    # Check if file was modified after transmission started
                                    # Use modification time (mtime) - on macOS use stat -f %m, on Linux use stat -c %Y
                                    local file_mtime=$(stat -f %m "$file" 2>/dev/null || stat -c %Y "$file" 2>/dev/null || echo "0")
                                    
                                    # Only consider files created/modified after transmission started
                                    # Allow 2 seconds buffer for file system timing
                                    if [ "$file_mtime" -ge $((start_time - 2)) ]; then
                                        local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                                        echo "$size|$file"
                                    fi
                                fi
                            done | sort -t'|' -k1 -rn | head -1 | cut -d'|' -f2)
                        
                        if [ -n "$video_file" ] && [ -f "$video_file" ] && [ -s "$video_file" ]; then
                            local file_size=$(stat -f%z "$video_file" 2>/dev/null || stat -c%s "$video_file" 2>/dev/null || echo "0")
                            if [ "$file_size" -gt 1048576 ]; then  # 1MB minimum
                                break
                            fi
                        fi
                        
                        # Charm-style dual spinner
                        local charm_chars=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
                        local charm_len=${#charm_chars[@]}
                        local idx1=$(( (charm_len - (video_wait % charm_len)) % charm_len ))
                        local idx2=$(( video_wait % charm_len ))
                        # Show progress with elapsed time
                        local elapsed_secs=$((video_wait / 2))
                        printf "\r${MAGENTA}${charm_chars[$idx1]}${CYAN}${charm_chars[$idx2]}${RESET} Waiting for video file... ${PURPLE}[${CYAN}%ds${PURPLE}]${RESET}" "$elapsed_secs"
                        
                        # Check if transmission process is still running
                            if ! kill -0 "$transmission_pid" 2>/dev/null; then
                                echo ""
                                echo -e "${RED}Error:${RESET} transmission-cli process died unexpectedly"
                                if [ -f "$transmission_output" ]; then
                                    echo -e "${YELLOW}Last transmission output:${RESET}"
                                    tail -30 "$transmission_output" | while IFS= read -r line; do
                                        echo "  $line"
                                    done
                                fi
                                # Restore original transmission config if we modified it
                                if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                                    cp "$config_backup" "$transmission_config" 2>/dev/null
                                    rm -f "$config_backup" 2>/dev/null
                                fi
                                rm -f "$transmission_output" 2>/dev/null
                                rm -f "$temp_output" 2>/dev/null
                                return 1
                            fi
                        
                        sleep 0.5
                        video_wait=$((video_wait + 1))
                    done
                    
                    if [ -z "$video_file" ] || [ ! -f "$video_file" ]; then
                        echo ""
                        echo -e "${RED}Error:${RESET} Could not find video file after 5 minutes"
                        
                        # Check if transmission is still running
                        if ! kill -0 "$transmission_pid" 2>/dev/null; then
                            echo -e "${YELLOW}Transmission process is not running.${RESET}"
                            if [ -f "$transmission_output" ]; then
                                echo -e "${YELLOW}Transmission output:${RESET}"
                                tail -50 "$transmission_output" | while IFS= read -r line; do
                                    echo "  $line"
                                done
                            fi
                        else
                            echo -e "${CYAN}Transmission is still running. Checking download directory...${RESET}"
                            echo -e "${CYAN}Directory:${RESET} $download_dir"
                            if [ -d "$download_dir" ]; then
                                echo -e "${CYAN}Files in directory:${RESET}"
                                find "$download_dir" -type f 2>/dev/null | head -10 | while IFS= read -r file; do
                                    if [ -n "$file" ]; then
                                        local fname=$(basename "$file")
                                        local fsize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                                        echo "  → $fname (${fsize} bytes)"
                                    fi
                                done
                            else
                                echo -e "${YELLOW}Directory does not exist:${RESET} $download_dir"
                            fi
                            
                            # Show recent transmission output
                            if [ -f "$transmission_output" ]; then
                                echo ""
                                echo -e "${CYAN}Recent transmission output:${RESET}"
                                tail -20 "$transmission_output" | while IFS= read -r line; do
                                    echo "  $line"
                                done
                            fi
                        fi
                        
                        kill $transmission_pid 2>/dev/null || true
                        # Restore original transmission config if we modified it
                        if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                            cp "$config_backup" "$transmission_config" 2>/dev/null
                            rm -f "$config_backup" 2>/dev/null
                        fi
                        rm -f "$transmission_output" 2>/dev/null
                        rm -f "$temp_output" 2>/dev/null
                        return 1
                    fi
                    
                    local video_path=$(realpath "$video_file" 2>/dev/null || echo "$video_file")
                    local video_dir=$(dirname "$video_path")
                    local video_name=$(basename "$video_path")
                    
                    echo ""
                    echo -e "${GREEN}✓ Video file found:${RESET} $video_name"
                    echo ""
                    
                    # Wait for buffer (10% progress or 50MB, whichever comes first)
                    echo -e "${CYAN}Buffering video (waiting for 10% progress)...${RESET}"
                    local target_progress=10  # 10% progress
                    local target_buffer_size=52428800  # 50MB fallback
                    local buffer_wait=0
                    local max_buffer_wait=300  # 5 minutes max
                    local last_size=0
                    local last_progress=0
                    local current_progress=0
                    local connected_peers=0
                    local total_peers=0
                    local download_speed=""
                    local last_update_time=$(date +%s)
                    
                    while [ $buffer_wait -lt $max_buffer_wait ]; do
                        # Parse progress from transmission output (check more frequently)
                        if [ -f "$transmission_output" ]; then
                            # Look for "Progress: X.X%" pattern
                            local progress_line=$(grep "Progress:" "$transmission_output" 2>/dev/null | tail -1)
                            if [ -n "$progress_line" ]; then
                                # Extract percentage: "Progress: 18.0%" -> 18.0
                                current_progress=$(echo "$progress_line" | grep -oE "Progress: [0-9]+\.[0-9]+%" | grep -oE "[0-9]+\.[0-9]+" | head -1)
                                # Extract peers: "dl from 18 of 49 peers" -> 18 and 49
                                local peer_match=$(echo "$progress_line" | grep -oE "dl from [0-9]+ of [0-9]+ peers" 2>/dev/null)
                                if [ -n "$peer_match" ]; then
                                    connected_peers=$(echo "$peer_match" | grep -oE "[0-9]+" | head -1)
                                    total_peers=$(echo "$peer_match" | grep -oE "[0-9]+" | tail -1)
                                fi
                                # Extract download speed: "(1.38 MB/s)" or "(3.63 MB/s)"
                                download_speed=$(echo "$progress_line" | grep -oE "\([0-9]+\.[0-9]+ [A-Z]+/s\)" | head -1)
                            fi
                        fi
                        
                        # Check file size (more reliable and updates frequently)
                        local current_size=$(stat -f%z "$video_path" 2>/dev/null || stat -c%s "$video_path" 2>/dev/null || echo "0")
                        local size_mb=$((current_size / 1048576))
                        local size_display=""
                        if [ "$current_size" -gt 1048576 ]; then
                            size_display="${size_mb} MB"
                        elif [ "$current_size" -gt 1024 ]; then
                            size_display="$((current_size / 1024)) KB"
                        else
                            size_display="${current_size} B"
                        fi
                        
                        # Calculate download rate (bytes per second)
                        local current_time=$(date +%s)
                        local time_diff=$((current_time - last_update_time))
                        local size_diff=$((current_size - last_size))
                        local bytes_per_sec=0
                        if [ "$time_diff" -gt 0 ] && [ "$size_diff" -gt 0 ]; then
                            bytes_per_sec=$((size_diff / time_diff))
                        fi
                        local speed_display=""
                        if [ "$bytes_per_sec" -gt 0 ]; then
                            if [ "$bytes_per_sec" -gt 1048576 ]; then
                                if command -v bc &> /dev/null; then
                                    speed_display="$(echo "scale=2; $bytes_per_sec / 1048576" | bc) MB/s"
                                else
                                    speed_display="$((bytes_per_sec / 1048576)) MB/s"
                                fi
                            elif [ "$bytes_per_sec" -gt 1024 ]; then
                                if command -v bc &> /dev/null; then
                                    speed_display="$(echo "scale=2; $bytes_per_sec / 1024" | bc) KB/s"
                                else
                                    speed_display="$((bytes_per_sec / 1024)) KB/s"
                                fi
                            else
                                speed_display="${bytes_per_sec} B/s"
                            fi
                        fi
                        
                        # Show progress with multiple indicators
                        if [ -n "$current_progress" ] && [ "$current_progress" != "0" ]; then
                            local progress_int=$(echo "$current_progress" | cut -d. -f1)
                            
                            local width=20
                            local filled=$((progress_int * width / 100))
                            if [ "$filled" -gt "$width" ]; then
                                filled=$width
                            fi
                            
                            local bar=""
                            local i=0
                            while [ $i -lt $filled ]; do
                                bar="${bar}🟩"
                                i=$((i + 1))
                            done
                            while [ $i -lt $width ]; do
                                bar="${bar}⬜"
                                i=$((i + 1))
                            done
                            
                            # Build comprehensive progress display
                            local progress_display="${current_progress}%"
                            if [ -n "$download_speed" ]; then
                                progress_display="${progress_display} $download_speed"
                            elif [ -n "$speed_display" ] && [ "$bytes_per_sec" -gt 0 ]; then
                                progress_display="${progress_display} (~$speed_display)"
                            fi
                            if [ "$total_peers" -gt 0 ]; then
                                progress_display="${progress_display} | ${connected_peers}/${total_peers} peers"
                            fi
                            if [ "$current_size" -gt 0 ]; then
                                progress_display="${progress_display} | ${size_display} downloaded"
                            fi
                            
                            printf "\r${CYAN}Buffering:${RESET} %s %s" "$bar" "$progress_display"
                            
                            # Check if we have 10% progress
                            if [ "$progress_int" -ge "$target_progress" ]; then
                                echo ""
                                echo -e "${GREEN}✓ Buffer ready (${current_progress}% progress, ${size_display} downloaded)${RESET}"
                                if [ "$total_peers" -gt 0 ]; then
                                    echo -e "${CYAN}Connected to ${connected_peers}/${total_peers} peers${RESET}"
                                fi
                                break
                            fi
                            
                            last_progress=$current_progress
                        elif [ "$current_size" -gt 0 ]; then
                            # Show size-based progress with download rate
                            local progress_percent=$((current_size * 100 / target_buffer_size))
                            if [ $progress_percent -gt 100 ]; then
                                progress_percent=100
                            fi
                            
                            local width=20
                            local filled=$((progress_percent * width / 100))
                            if [ "$filled" -gt "$width" ]; then
                                filled=$width
                            fi
                            
                            local bar=""
                            local i=0
                            while [ $i -lt $filled ]; do
                                bar="${bar}🟩"
                                i=$((i + 1))
                            done
                            while [ $i -lt $width ]; do
                                bar="${bar}⬜"
                                i=$((i + 1))
                            done
                            
                            # Build size-based display
                            local size_display_full="${size_display} / $((target_buffer_size / 1048576)) MB"
                            if [ -n "$speed_display" ] && [ "$bytes_per_sec" -gt 0 ]; then
                                size_display_full="${size_display_full} @ ~$speed_display"
                            fi
                            if [ "$total_peers" -gt 0 ]; then
                                size_display_full="${size_display_full} | ${connected_peers}/${total_peers} peers"
                            fi
                            
                            printf "\r${CYAN}Buffering:${RESET} %s %d%% (%s)" "$bar" "$progress_percent" "$size_display_full"
                            
                            # Check if we have enough buffer
                            if [ "$current_size" -ge $target_buffer_size ]; then
                                echo ""
                                echo -e "${GREEN}✓ Buffer ready (${size_display} downloaded)${RESET}"
                                break
                            fi
                            
                            # Check if stalled but have minimum buffer
                            if [ "$current_size" -eq "$last_size" ] && [ "$current_size" -gt 0 ]; then
                                if [ "$current_size" -ge 20971520 ]; then  # 20MB minimum
                                    echo ""
                                    echo -e "${YELLOW}⚠ Proceeding with available buffer (${size_display})${RESET}"
                                    break
                                fi
                            fi
                        else
                            # Show initial state with peer info if available
                            local initial_display="Connecting..."
                            if [ "$total_peers" -gt 0 ]; then
                                initial_display="${initial_display} (${connected_peers}/${total_peers} peers)"
                            fi
                            printf "\r${CYAN}Buffering:${RESET} ⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜ 0%% - $initial_display"
                        fi
                        
                        # Update tracking variables
                        if [ "$current_size" != "$last_size" ] || [ "$current_progress" != "$last_progress" ]; then
                            last_update_time=$current_time
                        fi
                        last_size=$current_size
                        sleep 0.5  # Update more frequently (every 0.5 seconds)
                        buffer_wait=$((buffer_wait + 1))
                    done
                    echo ""
                    
                    # Find subtitle file (same logic as peerflix)
                    local subtitle_file=""
                    local subtitle_arg=""
                    
                    if [ "$enable_subtitles" = true ] || has_subtitles "$source" >/dev/null 2>&1; then
                        echo -e "${CYAN}Searching for subtitle file...${RESET}"
                        
                        # Search for subtitle files in the same directory as video
                        subtitle_file=$(find "$video_dir" -type f \( -iname "*.srt" -o -iname "*.vtt" -o -iname "*.ass" -o -iname "*.ssa" \) 2>/dev/null | head -1)
                        
                        if [ -n "$subtitle_file" ] && [ -f "$subtitle_file" ]; then
                            local sub_abs=$(realpath "$subtitle_file" 2>/dev/null || echo "$subtitle_file")
                            local sub_name=$(basename "$sub_abs")
                            local sub_dir=$(dirname "$sub_abs")
                            
                            echo -e "${GREEN}✓ Subtitle found:${RESET} $sub_name"
                            
                            if [ "$sub_dir" = "$video_dir" ]; then
                                subtitle_arg="$sub_name"
                            else
                                subtitle_arg="$sub_abs"
                            fi
                        fi
                    fi
                    
                    # Launch player (same as peerflix)
                    echo ""
                    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    echo -e "${GREEN}Launching $player from local directory...${RESET}"
                    echo -e "  ${CYAN}Directory:${RESET} $video_dir"
                    echo -e "  ${CYAN}Video:${RESET} $video_name"
                    if [ -n "$subtitle_arg" ]; then
                        echo -e "  ${CYAN}Subtitle:${RESET} $subtitle_arg"
                    fi
                    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    echo ""
                    
                    local player_pid=""
                    cd "$video_dir" || {
                        echo -e "${RED}Error:${RESET} Could not change to video directory"
                        kill $transmission_pid 2>/dev/null || true
                        # Restore original transmission config if we modified it
                        if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                            cp "$config_backup" "$transmission_config" 2>/dev/null
                            rm -f "$config_backup" 2>/dev/null
                        fi
                        rm -f "$transmission_output" 2>/dev/null
                        rm -f "$temp_output" 2>/dev/null
                        return 1
                    }
                    
                    if [ "$player" = "vlc" ]; then
                        if [ -n "$subtitle_arg" ]; then
                            vlc "$video_name" --sub-file="$subtitle_arg" >/dev/null 2>&1 &
                        else
                            vlc "$video_name" >/dev/null 2>&1 &
                        fi
                        player_pid=$!
                    else
                        # mpv
                        local mpv_args=("$video_name")
                        if [ -n "$subtitle_arg" ]; then
                            mpv_args+=("--sub-file=$subtitle_arg")
                            mpv_args+=("--sid=1")
                            mpv_args+=("--sub-visibility=yes")
                        fi
                        mpv "${mpv_args[@]}" >/dev/null 2>&1 &
                        player_pid=$!
                    fi
                    
                    if [ -z "$player_pid" ] || ! kill -0 "$player_pid" 2>/dev/null; then
                        echo -e "${RED}Error:${RESET} Failed to launch player"
                        kill $transmission_pid 2>/dev/null || true
                        # Restore original transmission config if we modified it
                        if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                            cp "$config_backup" "$transmission_config" 2>/dev/null
                            rm -f "$config_backup" 2>/dev/null
                        fi
                        rm -f "$transmission_output" 2>/dev/null
                        rm -f "$temp_output" 2>/dev/null
                        return 1
                    fi
                    
                    echo -e "${CYAN}Player started (PID: $player_pid). Transmission running (PID: $transmission_pid)${RESET}"
                    echo ""
                    
                    # Monitor player (same as peerflix)
                    local player_running=true
                    local check_count=0
                    
                    trap 'echo -e "\n${YELLOW}Interrupted. Stopping transmission...${RESET}"; kill $transmission_pid 2>/dev/null || true; kill $player_pid 2>/dev/null || true; if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then cp "$config_backup" "$transmission_config" 2>/dev/null; rm -f "$config_backup" 2>/dev/null; fi; rm -f "$transmission_output" 2>/dev/null; return 2' INT TERM
                    
                    while [ "$player_running" = true ]; do
                        local player_processes=""
                        if [ "$player" = "vlc" ]; then
                            player_processes=$(pgrep -i "vlc" 2>/dev/null | head -1 || echo "")
                            if [ -z "$player_processes" ]; then
                                player_processes=$(ps aux | grep -i "[V]LC" | grep -v grep | awk '{print $2}' | head -1 || echo "")
                            fi
                        else
                            player_processes=$(pgrep "mpv" 2>/dev/null | head -1 || echo "")
                        fi
                        
                        if [ -z "$player_processes" ]; then
                            sleep 1
                            if [ "$player" = "vlc" ]; then
                                player_processes=$(pgrep -i "vlc" 2>/dev/null | head -1 || echo "")
                            else
                                player_processes=$(pgrep "mpv" 2>/dev/null | head -1 || echo "")
                            fi
                            
                            if [ -z "$player_processes" ]; then
                                player_running=false
                                break
                            fi
                        fi
                        
                        sleep 1
                        check_count=$((check_count + 1))
                        
                        if [ $check_count -gt 600 ]; then
                            echo -e "${YELLOW}Warning:${RESET} Monitoring timeout, stopping transmission anyway"
                            player_running=false
                            break
                        fi
                    done
                    
                    trap - INT TERM
                    
                    # Player closed, stop transmission
                    echo -e "${CYAN}Player closed. Stopping transmission...${RESET}"
                    kill $transmission_pid 2>/dev/null || true
                    sleep 1
                    kill -9 $transmission_pid 2>/dev/null || true
                    wait $transmission_pid 2>/dev/null &>/dev/null || true
                    
                    # Restore original transmission config if we modified it
                    if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                        cp "$config_backup" "$transmission_config" 2>/dev/null
                        rm -f "$config_backup" 2>/dev/null
                        echo -e "${CYAN}Restored transmission config${RESET}"
                    fi
                    
                    rm -f "$transmission_output" 2>/dev/null
                    rm -f "$temp_output" 2>/dev/null
                    return 2  # Return to catalog
                else
                    # transmission-cli not available, show error and exit
                    echo -e "${RED}Error:${RESET} peerflix failed and transmission-cli is not installed"
                    echo ""
                    echo "Please install transmission-cli:"
                    echo "  ${GREEN}brew install transmission-cli${RESET}"
                    rm -f "$temp_output" 2>/dev/null
                    return 1
                fi
                
                echo -e "${CYAN}Solutions:${RESET}"
                echo "  1. Try selecting a different torrent from the list"
                if ! command -v transmission-cli &> /dev/null; then
                    echo "  2. Install transmission-cli for download fallback:"
                    echo "     ${GREEN}brew install transmission-cli${RESET}"
                    echo "     Then use: ${GREEN}transmission-cli --download-dir \"/tmp/torrent-stream\" \"$source\"${RESET}"
                fi
                echo "  3. Use webtorrent (if installed):"
                echo "     ${GREEN}webtorrent \"$source\" --mpv${RESET}"
                echo "  4. Or add to transmission-daemon:"
                echo "     ${GREEN}transmission-remote -a \"$source\"${RESET}"
                echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                rm -f "$temp_output" 2>/dev/null
                return 1
            fi
        fi
    fi
    
    # Wait for peerflix to start and show the path
    sleep 4
    
    # Extract the torrent path from peerflix output
    local torrent_path=""
        local max_wait=125 # 25 seconds * 5
        local waited=0
    
        echo -e "${CYAN}Waiting for peerflix to show torrent path...${RESET}"
        while [ $waited -lt $max_wait ]; do
            if [ -f "$temp_output" ] && [ -s "$temp_output" ]; then
                # Read the file content (handle potential buffering)
                local output_content=$(cat "$temp_output" 2>/dev/null)
                
                # Try multiple patterns to find the path - "info path" followed by path
                # Pattern: "info path /tmp/torrent-stream/..."
                torrent_path=$(echo "$output_content" | grep "info path" 2>/dev/null | head -1 | sed -E 's/.*info path[[:space:]]+//' | awk '{print $1}' | tr -d '\r\n')
                
                # If not found, try extracting from "info path" line more carefully
                if [ -z "$torrent_path" ]; then
                    torrent_path=$(echo "$output_content" | grep "info path" 2>/dev/null | head -1 | awk '{for(i=3;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//' | awk '{print $1}')
                fi
                
                # Try finding /tmp/torrent-stream/ pattern (more flexible regex)
                if [ -z "$torrent_path" ]; then
                    torrent_path=$(echo "$output_content" | grep -oE "/tmp/torrent-stream/[a-zA-Z0-9]+" "$temp_output" 2>/dev/null | head -1)
                fi
                
                # Try finding any /tmp path after "info path"
                if [ -z "$torrent_path" ]; then
                    torrent_path=$(echo "$output_content" | grep "info path" 2>/dev/null | grep -oE "/tmp/[^[:space:]]+" | head -1)
                fi
                
                # Verify it's a directory
                if [ -n "$torrent_path" ] && [ -d "$torrent_path" ]; then
                    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    echo -e "${GREEN}✓ TORRENT PATH:${RESET}"
                    echo -e "${CYAN}$torrent_path${RESET}"
                    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                    break
                fi
            fi
            # Charm-style dual spinner
            local charm_chars=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
            local charm_len=${#charm_chars[@]}
            local idx1=$(( (charm_len - (waited % charm_len)) % charm_len ))
            local idx2=$(( waited % charm_len ))
            printf "\r${MAGENTA}${charm_chars[$idx1]}${CYAN}${charm_chars[$idx2]}${RESET} Waiting for torrent path..."
            
            sleep 0.2
            waited=$((waited + 1))
            if [ $((waited % 15)) -eq 0 ]; then
                printf "\r${YELLOW}Still waiting... ($((waited / 5))s)${RESET}    \n"
                # Show what we've found so far for debugging
                if [ -f "$temp_output" ] && [ -s "$temp_output" ]; then
                    local found_line=$(grep "info path" "$temp_output" 2>/dev/null | head -1)
                    if [ -n "$found_line" ]; then
                        echo -e "${CYAN}Found 'info path' line:${RESET} $found_line"
                        # Try to extract path from this line
                        local test_path=$(echo "$found_line" | sed -E 's/.*info path[[:space:]]+//' | awk '{print $1}')
                        if [ -n "$test_path" ]; then
                            echo -e "${CYAN}Extracted path:${RESET} $test_path"
                            if [ -d "$test_path" ]; then
                                echo -e "${GREEN}Path exists and is a directory!${RESET}"
                                torrent_path="$test_path"
                                break
                            else
                                echo -e "${YELLOW}Path does not exist yet or is not a directory${RESET}"
                            fi
                        fi
                    fi
                fi
            fi
        done
    
    # If still not found, show debug output
    if [ -z "$torrent_path" ] || [ ! -d "$torrent_path" ]; then
        echo -e "${RED}Error:${RESET} Could not determine torrent path"
        echo -e "${YELLOW}Peerflix output for debugging:${RESET}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        if [ -f "$temp_output" ]; then
            cat "$temp_output" 2>/dev/null | tail -30
        else
            echo "  (no output file found)"
        fi
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        kill $peerflix_pid 2>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        return 1
    fi
    
    # Wait for video file to be available (search recursively)
    # Give peerflix time to start downloading files first
    echo -e "${CYAN}Waiting for files to download...${RESET}"
    sleep 3  # Give peerflix time to create directory structure and start downloading
    
    echo -e "${CYAN}Searching for video file...${RESET}"
    local video_file=""
    local video_wait=0
    local max_video_wait=150  # 30 seconds * 5
    
    while [ $video_wait -lt $max_video_wait ]; do
        # First, check if directory exists and has any files at all
        if [ ! -d "$torrent_path" ]; then
            sleep 0.2
            video_wait=$((video_wait + 1))
            continue
        fi
        
        # List all files first to see what we have
        local all_files=$(find "$torrent_path" -type f 2>/dev/null)
        if [ -z "$all_files" ]; then
            # No files yet, wait longer
            # Charm-style dual spinner
            local charm_chars=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
            local charm_len=${#charm_chars[@]}
            local idx1=$(( (charm_len - (video_wait % charm_len)) % charm_len ))
            local idx2=$(( video_wait % charm_len ))
            local wait_secs=$((video_wait / 5))
            printf "\r${MAGENTA}${charm_chars[$idx1]}${CYAN}${charm_chars[$idx2]}${RESET} Waiting for files to download... ${PURPLE}[${CYAN}%ds${PURPLE}]${RESET}" "$wait_secs"
            sleep 0.2
            video_wait=$((video_wait + 1))
            continue
        fi
        
        # Debug: show what files we found
        if [ "$TORRENT_DEBUG" = true ] && [ $((video_wait % 25)) -eq 0 ]; then
            echo ""
            echo -e "${CYAN}Files found so far:${RESET}"
            echo "$all_files" | head -5 | while IFS= read -r file; do
                if [ -n "$file" ]; then
                    local rel_path="${file#$torrent_path/}"
                    local fsize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                    echo -e "  ${CYAN}→${RESET} $rel_path (${fsize} bytes)"
                fi
            done
            echo ""
        fi
        
        # Find the largest video file recursively (usually the main movie file)
        # Use find to get all video files, then sort by size
        video_file=$(find "$torrent_path" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.mov" -o -iname "*.webm" -o -iname "*.m4v" -o -iname "*.flv" -o -iname "*.wmv" \) 2>/dev/null | \
            while IFS= read -r file; do
                if [ -f "$file" ] && [ -s "$file" ]; then
                    local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                    echo "$size|$file"
                fi
            done | sort -t'|' -k1 -rn | head -1 | cut -d'|' -f2)
        
        if [ -n "$video_file" ] && [ -f "$video_file" ] && [ -s "$video_file" ]; then
            # Check if file is large enough (at least 1MB) to be a real video
            local file_size=$(stat -f%z "$video_file" 2>/dev/null || stat -c%s "$video_file" 2>/dev/null || echo "0")
            if [ "$file_size" -gt 1048576 ]; then  # 1MB
                printf "\r${GREEN}✓ Video file found${RESET}\n"
                break
            fi
        fi
        
        # Charm-style dual spinner
        local charm_chars=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
        local charm_len=${#charm_chars[@]}
        local idx1=$(( (charm_len - (video_wait % charm_len)) % charm_len ))
        local idx2=$(( video_wait % charm_len ))
        local search_secs=$((video_wait / 5))
        printf "\r${MAGENTA}${charm_chars[$idx1]}${CYAN}${charm_chars[$idx2]}${RESET} Searching for video file... ${PURPLE}[${CYAN}%ds${PURPLE}]${RESET}" "$search_secs"
        
        sleep 0.2
        video_wait=$((video_wait + 1))
    done
    
    if [ -z "$video_file" ] || [ ! -f "$video_file" ]; then
        echo ""
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${RED}Error:${RESET} Could not find video file in torrent"
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${YELLOW}Torrent path:${RESET} $torrent_path"
        echo ""
        echo -e "${YELLOW}Directory structure:${RESET}"
        ls -la "$torrent_path" 2>/dev/null | head -20 || echo "  (directory listing failed)"
        echo ""
        echo -e "${YELLOW}All files found (recursive):${RESET}"
        local found_any=false
        find "$torrent_path" -type f 2>/dev/null | while IFS= read -r file; do
            if [ -n "$file" ]; then
                found_any=true
                local rel_path="${file#$torrent_path/}"
                local fsize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                local fname=$(basename "$file")
                echo -e "  ${CYAN}→${RESET} $rel_path"
                echo -e "    ${YELLOW}Size:${RESET} ${fsize} bytes | ${YELLOW}Name:${RESET} $fname"
            fi
        done
        if [ "$found_any" = false ]; then
            echo -e "  ${YELLOW}(no files found - torrent may still be downloading)${RESET}"
            echo ""
            echo -e "${CYAN}Note:${RESET} This torrent may not have any video files, or files are still downloading."
            echo -e "${CYAN}Try:${RESET} Wait a moment and try again, or check the torrent contents manually."
        fi
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        kill $peerflix_pid 2>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        return 1
    fi
    
    local video_path=$(realpath "$video_file" 2>/dev/null || echo "$video_file")
    local video_dir=$(dirname "$video_path")
    local video_name=$(basename "$video_path")
    
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${GREEN}✓ Video file found:${RESET} $video_name"
    echo -e "${CYAN}Video directory:${RESET} $video_dir"
    echo -e "${CYAN}Full path:${RESET} $video_path"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    
    # Buffer video before starting player (wait for 3-4 minutes of content)
    # Estimate: assume average bitrate of 2-3 Mbps for 1080p, so 3-4 minutes = ~45-60 MB
    # We'll wait for at least 50MB to be downloaded
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${CYAN}Buffering video...${RESET}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    local target_buffer_size=52428800  # 50MB (3-4 minutes at ~2Mbps)
    local buffer_wait=0
    local max_buffer_wait=300  # 5 minutes max wait
    local last_size=0
    local stalled_count=0
    local connected_peers=0
    local total_peers=0
    
    while [ $buffer_wait -lt $max_buffer_wait ]; do
        if [ ! -f "$video_path" ]; then
            sleep 1
            buffer_wait=$((buffer_wait + 1))
            continue
        fi
        
        local current_size=$(stat -f%z "$video_path" 2>/dev/null || stat -c%s "$video_path" 2>/dev/null || echo "0")
        
        # Extract peer information from peerflix output
        if [ -f "$temp_output" ] && [ -s "$temp_output" ]; then
            local peer_info=$(grep "info streaming" "$temp_output" 2>/dev/null | tail -1)
            if [ -n "$peer_info" ]; then
                # Extract "from X/Y peers" pattern: "info streaming ... from 5/10 peers"
                # Pattern can be: "from 5/10 peers" or "from 5/10"
                local peer_match=$(echo "$peer_info" | grep -oE "from [0-9]+/[0-9]+" 2>/dev/null | head -1)
                if [ -n "$peer_match" ]; then
                    # Extract connected peers (first number)
                    connected_peers=$(echo "$peer_match" | sed -E 's/from ([0-9]+)\/[0-9]+/\1/' 2>/dev/null)
                    # Extract total peers (second number)
                    total_peers=$(echo "$peer_match" | sed -E 's/from [0-9]+\/([0-9]+)/\1/' 2>/dev/null)
                fi
            fi
        fi
        
        # Check if file is growing (not stalled)
        if [ "$current_size" -eq "$last_size" ] && [ "$current_size" -gt 0 ]; then
            stalled_count=$((stalled_count + 1))
            if [ $stalled_count -gt 10 ]; then
                # File hasn't grown in 10 seconds, might be stalled or complete
                # If we have enough buffer, proceed anyway
                if [ "$current_size" -ge $target_buffer_size ]; then
                    break
                fi
            fi
        else
            stalled_count=0
        fi
        
        last_size=$current_size
        
        # Show progress with peer information
        if [ "$current_size" -gt 0 ]; then
            # Calculate progress as percentage of target buffer
            local progress_percent=$((current_size * 100 / target_buffer_size))
            if [ $progress_percent -gt 100 ]; then
                progress_percent=100
            fi
            
            # Build progress bar
            local width=20
            local filled=$((progress_percent * width / 100))
            if [ "$filled" -gt "$width" ]; then
                filled=$width
            fi
            
            local bar=""
            local i=0
            while [ $i -lt $filled ]; do
                bar="${bar}🟩"
                i=$((i + 1))
            done
            while [ $i -lt $width ]; do
                bar="${bar}⬜"
                i=$((i + 1))
            done
            
            # Show peers if available, otherwise show percentage
            if [ "$total_peers" -gt 0 ]; then
                printf "\r${CYAN}Buffering:${RESET} %s %d%% (%d/%d peers) " "$bar" "$progress_percent" "$connected_peers" "$total_peers"
            else
                printf "\r${CYAN}Buffering:${RESET} %s %d%% " "$bar" "$progress_percent"
            fi
        else
            if [ "$total_peers" -gt 0 ]; then
                printf "\r${CYAN}Buffering...${RESET} [0%%] (%d/%d peers) " "$connected_peers" "$total_peers"
            else
                printf "\r${CYAN}Buffering...${RESET} [0%%]"
            fi
        fi
        
        # If we have enough buffer, proceed
        if [ "$current_size" -ge $target_buffer_size ]; then
            echo ""  # New line after progress bar
            echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
            echo -e "${GREEN}✓ Buffer ready (${current_size} bytes)${RESET}"
            if [ "$total_peers" -gt 0 ]; then
                echo -e "${CYAN}Connected to ${connected_peers}/${total_peers} peers${RESET}"
            fi
            echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
            break
        fi
        
        sleep 1
        buffer_wait=$((buffer_wait + 1))
    done
    
    # Final check
    local final_size=$(stat -f%z "$video_path" 2>/dev/null || stat -c%s "$video_path" 2>/dev/null || echo "0")
    if [ "$final_size" -lt $target_buffer_size ]; then
        echo ""  # New line after progress bar
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${YELLOW}⚠ Warning:${RESET} Buffer not fully ready (${final_size} bytes), but proceeding..."
        if [ "$total_peers" -gt 0 ]; then
            echo -e "${CYAN}Connected to ${connected_peers}/${total_peers} peers${RESET}"
        fi
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    fi
    echo
    
    # Prepare subtitle file path (relative to video file directory)
    local subtitle_arg=""
    if [ -n "$subtitle_file" ] && [ -f "$subtitle_file" ]; then
        local sub_abs=$(realpath "$subtitle_file" 2>/dev/null || echo "$subtitle_file")
        local sub_name=$(basename "$sub_abs")
        local sub_dir=$(dirname "$sub_abs")
        
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${GREEN}✓ SRT File Found:${RESET} $sub_abs"
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo
        
        # Check if subtitle is in the same directory as video
        if [ "$sub_dir" = "$video_dir" ]; then
            # Same directory - use relative path (just filename)
            subtitle_arg="$sub_name"
        else
            # Different directory - use absolute path
            subtitle_arg="$sub_abs"
        fi
    fi
    
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${GREEN}Launching $player from local directory...${RESET}"
    echo -e "  ${CYAN}Directory:${RESET} $video_dir"
    echo -e "  ${CYAN}Video:${RESET} $video_name"
    if [ -n "$subtitle_arg" ]; then
        echo -e "  ${CYAN}Subtitle:${RESET} $subtitle_arg"
    fi
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo
    
    # Launch player from the video directory
    local player_pid=""
    cd "$video_dir" || {
        echo -e "${RED}Error:${RESET} Could not change to video directory"
        kill $peerflix_pid 2>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        return 1
    }
    
    if [ "$player" = "vlc" ]; then
        if [ -n "$subtitle_arg" ]; then
            echo -e "${YELLOW}Command:${RESET} vlc \"$video_name\" --sub-file=\"$subtitle_arg\""
            vlc "$video_name" --sub-file="$subtitle_arg" >/dev/null 2>&1 &
            player_pid=$!
        else
            vlc "$video_name" >/dev/null 2>&1 &
            player_pid=$!
        fi
    else
        # mpv
        local mpv_args=("$video_name")
        if [ -n "$subtitle_arg" ]; then
            echo -e "${YELLOW}Command:${RESET} mpv \"$video_name\" --sub-file=\"$subtitle_arg\" --sid=1 --sub-visibility=yes"
            mpv_args+=("--sub-file=$subtitle_arg")
            mpv_args+=("--sid=1")
            mpv_args+=("--sub-visibility=yes")
        fi
        mpv "${mpv_args[@]}" >/dev/null 2>&1 &
        player_pid=$!
    fi
    
    if [ -z "$player_pid" ] || ! kill -0 "$player_pid" 2>/dev/null; then
        echo -e "${RED}Error:${RESET} Failed to launch player"
        kill $peerflix_pid 2>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        return 1
    fi
    
    echo -e "${CYAN}Player started (PID: $player_pid). Peerflix running (PID: $peerflix_pid)${RESET}"
    echo
    
    # Monitor player process - VLC/mpv may fork, so we need to check by process name
    # Use a trap to handle Ctrl+C gracefully
    cleanup_and_exit() {
        echo -e "\n${YELLOW}Interrupted. Stopping peerflix...${RESET}"
        kill $peerflix_pid 2>/dev/null || true
        sleep 1
        kill -9 $peerflix_pid 2>/dev/null || true
        wait $peerflix_pid 2>/dev/null &>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        exit 0
    }
    trap cleanup_and_exit INT TERM
    
    # Wait a moment for the process to potentially fork (especially VLC)
    sleep 2
    
    # Monitor player by checking if any player process is running
    # Escape the video name for use in pgrep
    local escaped_video_name=$(echo "$video_name" | sed 's/[[\.*^$()+?{|]/\\&/g')
    local player_running=true
    local check_count=0
    
    while [ "$player_running" = true ]; do
        # Check if any player process is running (by name, not just PID)
        # This handles cases where VLC/mpv fork and the original PID exits
        local player_processes=""
        if [ "$player" = "vlc" ]; then
            # Check for VLC processes - VLC on macOS might be "VLC" or "vlc" or in an app bundle
            # Try multiple methods: pgrep, ps, and check if video file is open
            player_processes=$(pgrep -i "vlc" 2>/dev/null | head -1 || echo "")
            if [ -z "$player_processes" ]; then
                # Try ps to find VLC (might be case-sensitive)
                player_processes=$(ps aux | grep -i "[V]LC" | grep -v grep | awk '{print $2}' | head -1 || echo "")
            fi
            # Also check if video file is open (lsof on macOS)
            if [ -z "$player_processes" ] && command -v lsof &> /dev/null; then
                local open_by=$(lsof "$video_path" 2>/dev/null | grep -i vlc | head -1 || echo "")
                if [ -n "$open_by" ]; then
                    player_processes="open"  # Mark as running
                fi
            fi
        else
            # Check for mpv processes
            player_processes=$(pgrep "mpv" 2>/dev/null | head -1 || echo "")
            if [ -z "$player_processes" ] && command -v lsof &> /dev/null; then
                local open_by=$(lsof "$video_path" 2>/dev/null | grep -i mpv | head -1 || echo "")
                if [ -n "$open_by" ]; then
                    player_processes="open"  # Mark as running
                fi
            fi
        fi
        
        # If no player processes found, player has exited
        if [ -z "$player_processes" ]; then
            # Double-check: wait a moment and check again (in case of brief process switch)
            sleep 1
            if [ "$player" = "vlc" ]; then
                player_processes=$(pgrep -i "vlc" 2>/dev/null | head -1 || echo "")
                if [ -z "$player_processes" ]; then
                    player_processes=$(ps aux | grep -i "[V]LC" | grep -v grep | awk '{print $2}' | head -1 || echo "")
                fi
            else
                player_processes=$(pgrep "mpv" 2>/dev/null | head -1 || echo "")
            fi
            
            if [ -z "$player_processes" ]; then
                player_running=false
                break
            fi
        fi
        
        # Player still running, continue monitoring
        sleep 1
        check_count=$((check_count + 1))
        
        # Safety: if we've been checking for too long (10 minutes), break
        if [ $check_count -gt 600 ]; then
            echo -e "${YELLOW}Warning:${RESET} Monitoring timeout, stopping peerflix anyway"
            player_running=false
            break
        fi
    done
    
    # Clear the trap
    trap - INT TERM
    
    # Player exited, kill peerflix
    echo -e "${CYAN}Player closed. Stopping peerflix...${RESET}"
    kill $peerflix_pid 2>/dev/null || true
    sleep 1
    kill -9 $peerflix_pid 2>/dev/null || true
    wait $peerflix_pid 2>/dev/null &>/dev/null || true
    
    rm -f "$temp_output" 2>/dev/null
    
    # Return special exit code to indicate player closed (not an error)
    # This allows the calling code to return to catalog view
    return 2
}


# Main streaming function
stream_torrent() {
    local source="$1"
    local index="${2:-}"
    local list_only="${3:-false}"
    local enable_subtitles="${4:-false}"
    
    # Validate source (must be magnet link or file path)
    if [ -z "$source" ]; then
        echo -e "${RED}Error:${RESET} No torrent source provided"
        return 1
    fi
    
    # Clean up source (remove whitespace, newlines)
    source=$(echo "$source" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    # Check if it's a magnet link or file path
    if [[ ! "$source" =~ ^magnet: ]] && [ ! -f "$source" ]; then
        echo -e "${RED}Error:${RESET} Invalid torrent source: '$source'"
        echo -e "${YELLOW}Expected:${RESET} magnet link (magnet:?xt=...) or path to .torrent file"
        return 1
    fi
    
    # Ensure TORRENT_TOOL is set (should always be peerflix now)
    if [ -z "$TORRENT_TOOL" ]; then
        check_deps
    fi
    
    # Only use peerflix
    if [ "$list_only" = true ]; then
        peerflix "$source" --list
    else
        stream_peerflix "$source" "$index" "$enable_subtitles"
    fi
}

# Auto-select best quality
select_best_quality() {
    local source="$1"
    
    echo -e "${YELLOW}Analyzing available files...${RESET}"
    
    # List files and find the largest video file
    # Use peerflix to list files
    local file_list=$(peerflix "$source" --list 2>/dev/null || echo "")
    
    if [ -z "$file_list" ]; then
        echo -e "${YELLOW}Could not list files, playing default...${RESET}"
        return 0
    fi
    
    # Find video files and select the largest one
    local best_file=$(echo "$file_list" | grep -iE '\.(mp4|mkv|avi|mov|webm|m4v)' | \
        awk '{print $1, $2}' | sort -k2 -rn | head -1 | awk '{print $1}')
    
    if [ -n "$best_file" ]; then
        echo -e "${GREEN}Selected best quality file (index $best_file)${RESET}"
        echo "$best_file"
    else
        echo -e "${YELLOW}No video files found, using default...${RESET}"
        echo "0"
    fi
}

# Global debug flag
TORRENT_DEBUG=false

# Main function
main() {
    local source=""
    local index=""
    local list_only=false
    local search_mode=false
    local auto_quality=false
    local enable_subtitles=false
    local args=("$@")
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -l|--list)
                list_only=true
                shift
                ;;
            -i|--index)
                index="$2"
                shift 2
                ;;
            -q|--quality)
                auto_quality=true
                shift
                ;;
            -s|--subtitles)
                enable_subtitles=true
                shift
                ;;
            -v|--verbose)
                set -x
                shift
                ;;
            --debug)
                TORRENT_DEBUG=true
                export TORRENT_DEBUG
                shift
                ;;
            --clear)
                local cache_dir="$HOME/.config/termflix/cache"
                if [ -d "$cache_dir" ]; then
                    local deleted_count=$(find "$cache_dir" -name "catalog_*.txt" -type f | wc -l | tr -d ' ')
                    rm -rf "$cache_dir"/catalog_*.txt 2>/dev/null
                    if [ "$deleted_count" -gt 0 ]; then
                        echo -e "${GREEN}✓ Cleared ${deleted_count} cache file(s)${RESET}"
                    else
                        echo -e "${YELLOW}No cache files found to clear${RESET}"
                    fi
                else
                    echo -e "${YELLOW}Cache directory does not exist${RESET}"
                fi
                exit 0
                ;;
            player)
                # Change player preference
                if [ -z "$2" ]; then
                    echo -e "${RED}Error:${RESET} Please specify a player (mpv or vlc)"
                    echo "Usage: termflix player <mpv|vlc>"
                    exit 1
                fi
                local new_player="$2"
                if [[ "$new_player" =~ ^(mpv|vlc)$ ]]; then
                    init_termflix_dirs
                    local config_file=$(get_termflix_config_file)
                    echo "PLAYER=$new_player" > "$config_file"
                    echo -e "${GREEN}Player preference changed to:${RESET} $new_player"
                    echo -e "${CYAN}Config saved to:${RESET} $config_file"
                    exit 0
                else
                    echo -e "${RED}Error:${RESET} Invalid player. Use 'mpv' or 'vlc'"
                    exit 1
                fi
                ;;
            search)
                search_mode=true
                shift
                ;;
            *)
                if [ -z "$source" ]; then
                    source="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Wrapper functions for YTSRS (defined before use)
    get_ytsrs_latest_wrapper() {
        get_ytsrs_movies "" "1080p" "year" "$1" "$2"
    }
    get_ytsrs_trending_wrapper() {
        get_ytsrs_movies "" "1080p" "seeds" "$1" "$2"
    }
    get_ytsrs_popular_wrapper() {
        get_ytsrs_movies "" "1080p" "rating" "$1" "$2"
    }
    get_ytsrs_genre_wrapper() {
        local genre="$1"
        shift
        get_ytsrs_movies "$genre" "1080p" "seeds" "$1" "$2"
    }
    
    # Filter args for routing (remove --debug)
    local routing_args=()
    for arg in "${args[@]}"; do
        [[ "$arg" != "--debug" ]] && routing_args+=("$arg")
    done
    
    # Handle catalog modes FIRST (doesn't need streaming tool)
    case "${routing_args[0]}" in
        latest)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # Show results from both TPB and YTSRS
                    display_catalog "🎬 Latest Movies" get_latest_movies 25 get_ytsrs_latest_wrapper 25
                    ;;
                shows)
                    display_catalog "📺 Latest TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "🎬 Latest Movies & Shows" get_latest_movies 15 get_ytsrs_latest_wrapper 15 get_latest_shows 20
                    ;;
            esac
            exit $?
            ;;
        trending)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # Show results from both TPB and YTSRS
                    display_catalog "🔥 Trending Movies" get_trending_movies 25 get_ytsrs_trending_wrapper 25
                    ;;
                shows)
                    display_catalog "🔥 Trending TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "🔥 Trending Content" get_trending_movies 15 get_ytsrs_trending_wrapper 15 get_latest_shows 20
                    ;;
            esac
            exit $?
            ;;
        popular)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # Show results from both TPB and YTSRS
                    display_catalog "⭐ Popular Movies" get_popular_movies 25 get_ytsrs_popular_wrapper 25
                    ;;
                shows)
                    display_catalog "⭐ Popular TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "⭐ Popular Content" get_popular_movies 15 get_ytsrs_popular_wrapper 15 get_latest_shows 20
                    ;;
            esac
            exit $?
            ;;
        catalog)
            check_jq
            local genre="${routing_args[1]:-}"
            if [ -z "$genre" ]; then
                echo -e "${BOLD}Available Genres:${RESET}"
                echo "  action, adventure, animation, comedy, crime, documentary,"
                echo "  drama, family, fantasy, horror, mystery, romance,"
                echo "  sci-fi, thriller, war, western"
                echo
                echo "Usage: torrent catalog <genre>"
                exit 1
            fi
            # Show results from both YTS/TPB and YTSRS
            # Create genre-specific wrapper
            eval "get_ytsrs_${genre}_wrapper() {
                get_ytsrs_movies \"$genre\" \"1080p\" \"seeds\" \"\$1\" \"\$2\"
            }"
            display_catalog "📚 $genre Movies" get_catalog_by_genre "$genre" 25 "get_ytsrs_${genre}_wrapper" 25
            exit $?
            ;;
        search)
            check_jq
            local query="${routing_args[1]:-}"
            if [ -z "$query" ]; then
                echo -e "${RED}Error:${RESET} Please provide a search query"
                echo "Usage: termflix search <query>"
                exit 1
            fi
            search_torrent "$query"
            exit $?
            ;;
    esac
    
    # If we get here and no source, default to "latest all"
    if [ -z "$source" ] && [ "$list_only" = false ] && [ "$search_mode" = false ]; then
        # Default behavior: show latest movies and shows
        check_jq
        display_catalog "🎬 Latest Movies & Shows" get_latest_movies 15 get_ytsrs_latest_wrapper 15 get_latest_shows 20
        exit $?
    fi
    
    # Check dependencies for streaming (only needed when actually streaming)
    check_deps
    check_jq
    
    # Get source from clipboard if not provided
    if [ -z "$source" ]; then
        if command -v pbpaste &> /dev/null; then
            # BSD grep compatible (no -P flag)
            source=$(pbpaste | grep -oE 'magnet:\?[^[:space:]]+' | head -1)
            if [ -n "$source" ]; then
                echo -e "${GREEN}Using magnet link from clipboard${RESET}"
            fi
        fi
        
        if [ -z "$source" ]; then
            echo -e "${RED}Error:${RESET} No magnet link or torrent file provided"
            echo "Usage: termflix <magnet_link|torrent_file>"
            echo "   or: termflix --help"
            exit 1
        fi
    fi
    
    # Handle auto-quality selection
    if [ "$auto_quality" = true ] && [ -z "$index" ]; then
        index=$(select_best_quality "$source")
    fi
    
    # Stream the torrent
    stream_torrent "$source" "$index" "$list_only" "$enable_subtitles"
}

# Run main function
# Run main function if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
