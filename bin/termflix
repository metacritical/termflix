#!/usr/bin/env bash
#
# Termflix - Torrent Streaming Tool - Stream torrents directly to mpv/vlc
# Usage: termflix [command] or termflix <magnet_link|torrent_file>
#

# Don't exit on error - we handle errors gracefully
set +e
# Suppress job control messages (like "Terminated: 15")
set +H 2>/dev/null || true

# Cleanup function for poster images and temp files
cleanup_on_exit() {
    # Kill background jobs
    jobs -p | xargs kill 2>/dev/null || true
    
    # Cleanup temp files
    rm -f /tmp/termflix_poster_* 2>/dev/null
    rm -f /tmp/termflix_search_* 2>/dev/null
    rm -rf /tmp/termflix_posters_* 2>/dev/null
    rm -f /tmp/torrent_* 2>/dev/null
    
    # Reset terminal
    tput cnorm 2>/dev/null || true
}
trap cleanup_on_exit EXIT INT TERM

# Resolve script directory (works even when called via PATH or symlinks)
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
TERMFLIX_SCRIPTS_DIR="$SCRIPT_DIR/scripts"
export TERMFLIX_SCRIPTS_DIR

# ============================================================
# MODULE LOADING
# ============================================================

# Core Modules
source "$SCRIPT_DIR/modules/core/colors.sh"
source "$SCRIPT_DIR/modules/core/config.sh"
source "$SCRIPT_DIR/modules/core/deps.sh"

# UI Modules
source "$SCRIPT_DIR/modules/ui/status.sh"

source "$SCRIPT_DIR/modules/ui/help.sh"
source "$SCRIPT_DIR/modules/ui/fzf_catalog.sh"

# Feature Modules
source "$SCRIPT_DIR/modules/posters.sh"
source "$SCRIPT_DIR/modules/search.sh"
source "$SCRIPT_DIR/modules/catalog.sh"
source "$SCRIPT_DIR/modules/torrent.sh"

# Initialize directories
init_termflix_dirs

# Export API keys for external scripts (required for get_poster.py)
export TMDB_API_KEY=$(get_tmdb_api_key)
export TMDB_READ_TOKEN=$(get_tmdb_read_token)
export OMDB_API_KEY=$(config_get "OMDB_API_KEY" "")

# ============================================================
# COMPATIBILITY & HELPERS
# ============================================================

# Wrapper for check_all_deps that sets TORRENT_TOOL global
check_deps() {
    check_all_deps
    TORRENT_TOOL=$(check_torrent_client)
    export TORRENT_TOOL
}
export -f check_deps

# Global debug flag
TORRENT_DEBUG=false

# ============================================================
# MAIN FUNCTION
# ============================================================

main() {
    local source=""
    local index=""
    local list_only=false
    local search_mode=false
    local auto_quality=false
    local enable_subtitles=false
    local args=("$@")
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -l|--list)
                list_only=true
                shift
                ;;
            -i|--index)
                index="$2"
                shift 2
                ;;
            -q|--quality)
                auto_quality=true
                shift
                ;;
            -s|--subtitles)
                enable_subtitles=true
                shift
                ;;
            -v|--verbose)
                set -x
                shift
                ;;
            --debug)
                TORRENT_DEBUG=true
                export TORRENT_DEBUG
                shift
                ;;
            -g|--grid)
                USE_GUM_MODE=true
                export USE_GUM_MODE
                shift
                ;;
            --clear)
                local cache_dir="$HOME/.config/termflix/cache"
                if [ -d "$cache_dir" ]; then
                    local deleted_count=$(find "$cache_dir" -name "catalog_*.txt" -type f | wc -l | tr -d ' ')
                    rm -rf "$cache_dir"/catalog_*.txt 2>/dev/null
                    if [ "$deleted_count" -gt 0 ]; then
                        echo -e "${GREEN}‚úì Cleared ${deleted_count} cache file(s)${RESET}"
                    else
                        echo -e "${YELLOW}No cache files found to clear${RESET}"
                    fi
                else
                    echo -e "${YELLOW}Cache directory does not exist${RESET}"
                fi
                exit 0
                ;;
            player)
                # Change player preference
                if [ -z "$2" ]; then
                    echo -e "${RED}Error:${RESET} Please specify a player (mpv or vlc)"
                    echo "Usage: termflix player <mpv|vlc>"
                    exit 1
                fi
                local new_player="$2"
                if [[ "$new_player" =~ ^(mpv|vlc)$ ]]; then
                    init_termflix_dirs
                    local config_file=$(get_termflix_config_file)
                    echo "PLAYER=$new_player" > "$config_file"
                    echo -e "${GREEN}Player preference changed to:${RESET} $new_player"
                    echo -e "${CYAN}Config saved to:${RESET} $config_file"
                    exit 0
                else
                    echo -e "${RED}Error:${RESET} Invalid player. Use 'mpv' or 'vlc'"
                    exit 1
                fi
                ;;
            search)
                search_mode=true
                shift
                ;;
            *)
                if [ -z "$source" ]; then
                    source="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Wrapper functions for YTSRS (defined before use)
    get_ytsrs_latest_wrapper() {
        get_ytsrs_movies "" "1080p" "year" "$1" "$2"
    }
    get_ytsrs_trending_wrapper() {
        get_ytsrs_movies "" "1080p" "seeds" "$1" "$2"
    }
    get_ytsrs_popular_wrapper() {
        get_ytsrs_movies "" "1080p" "rating" "$1" "$2"
    }
    get_ytsrs_genre_wrapper() {
        local genre="$1"
        shift
        get_ytsrs_movies "$genre" "1080p" "seeds" "$1" "$2"
    }
    
    # Filter args for routing (remove --debug)
    local routing_args=()
    for arg in "${args[@]}"; do
        [[ "$arg" != "--debug" ]] && routing_args+=("$arg")
    done
    
    # Handle catalog modes FIRST (doesn't need streaming tool)
    case "${routing_args[0]}" in
        latest)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # TPB only - YTS disabled
                    display_catalog "üé¨ Latest Movies" get_latest_movies 50
                    ;;
                shows)
                    display_catalog "üì∫ Latest TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "üé¨ Latest Movies" get_latest_movies 50
                    ;;
            esac
            exit $?
            ;;
        trending)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # TPB only - YTS disabled
                    display_catalog "üî• Trending Movies" get_latest_movies 50
                    ;;
                shows)
                    display_catalog "üî• Trending TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "üî• Trending Content" get_latest_movies 50
                    ;;
            esac
            exit $?
            ;;
        popular)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # TPB only - YTS disabled
                    display_catalog "‚≠ê Popular Movies" get_latest_movies 50
                    ;;
                shows)
                    display_catalog "‚≠ê Popular TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "‚≠ê Popular Content" get_latest_movies 50
                    ;;
            esac
            exit $?
            ;;
        catalog)
            check_jq
            local genre="${routing_args[1]:-}"
            if [ -z "$genre" ]; then
                echo -e "${BOLD}Available Genres:${RESET}"
                echo "  action, adventure, animation, comedy, crime, documentary,"
                echo "  drama, family, fantasy, horror, mystery, romance,"
                echo "  sci-fi, thriller, war, western"
                echo
                echo "Usage: torrent catalog <genre>"
                exit 1
            fi
            # TPB only - YTS disabled for genre search
            display_catalog "üìö $genre Movies" get_latest_movies 50
            exit $?
            ;;
        search)
            check_jq
            local query="${routing_args[1]:-}"
            if [ -z "$query" ]; then
                echo -e "${RED}Error:${RESET} Please provide a search query"
                echo "Usage: termflix search <query>"
                exit 1
            fi
            search_torrent "$query"
            exit $?
            ;;
    esac
    
    # If we get here and no source, default to "latest movies" with category switching
    if [ -z "$source" ] && [ "$list_only" = false ] && [ "$search_mode" = false ]; then
        check_jq
        
        # Category switching loop - NEW DESIGN
        local current_category="movies"
        local current_context="default" # default, year, rating, peers, title
        local current_sort="desc"       # desc, asc
        local current_min_rating=0
        local current_query=""
        
        while true; do
            # Export context for fetch functions
            local export_sort_by="year"
            case "$current_context" in
                default) export_sort_by="year" ;;
                title)   export_sort_by="title" ;;
                rating)  export_sort_by="rating" ;;
                peers)   export_sort_by="seeds" ;;
                year)    export_sort_by="year" ;;
                *)       export_sort_by="year" ;;
            esac
            
            # Map friendly context to API sort key
            if [[ "$current_context" == "default" ]]; then
                # Default "Most Recent" behavior
                export CURRENT_SORT="year"
                export CURRENT_ORDER="desc"
            else
                export CURRENT_SORT="$export_sort_by"
                export CURRENT_ORDER="$current_sort"
            fi
            
            export CURRENT_GENRE="" # Clear genre for now unless specific
            export CURRENT_MIN_RATING="$current_min_rating"
            export CURRENT_QUERY="$current_query"

            # Build title
            local title_prefix="üé¨"
            case "$current_context" in
                default) title_prefix="$title_prefix Recent Movies" ;;
                year)    title_prefix="$title_prefix Movies by Year ($current_sort)" ;;
                rating)  title_prefix="$title_prefix Top Rated (${current_min_rating}+) ($current_sort)" ;;
                peers)   title_prefix="$title_prefix Most Seeded ($current_sort)" ;;
                title)   title_prefix="$title_prefix Movies by Title ($current_sort)" ;;
            esac
            
            if [[ -n "$current_query" ]]; then
                 title_prefix="$title_prefix [Filter: $current_query]"
            fi
            
            # Map to data function - Unified
            # All contexts use the same python script, just different args via globals
            # We use 'get_latest_movies' as the base caller since it's generic
            data_func="get_latest_movies"

            display_catalog "$title_prefix" "$data_func" 50
            local ret=$?
            
            # Reset one-time flags
            [[ "$FORCE_REFRESH" == "true" ]] && export FORCE_REFRESH=false
            
            case $ret in
                # ... standard navigations ...
                101) current_category="movies"; current_context="default" ;;
                102) current_category="shows" ;;
                103) # Watchlist
                     # Placeholder for future Watchlist feature
                     clear
                     echo -e "\n${BOLD}${YELLOW}üìö Watchlist${RESET}\n"
                     echo -e "${CYAN}Coming Soon!${RESET}"
                     echo -e "\nThis feature will allow you to:"
                     echo -e "  ‚Ä¢ Save movies and shows to watch later"
                     echo -e "  ‚Ä¢ Get notified when new episodes arrive"
                     echo -e "  ‚Ä¢ Track your watch history"
                     echo -e "\n${GRAY}Press any key to go back...${RESET}"
                     read -n 1 -s
                     current_category="movies"
                     continue
                     ;;
                104) # Type Menu (^T) - Select CONTEXT
                     local type_opts="Movies (Default)\nShows\nBy Year\nBy Title\nBy Rating\nBy Peers"
                     local sel_type
                     sel_type=$(echo -e "$type_opts" | fzf --height=12 --layout=reverse --border --prompt="Browse by: " --header="Select Content Type" 2>/dev/null)
                     case "$sel_type" in
                        "Movies (Default)") current_category="movies"; current_context="default" ;;
                        "Shows") current_category="shows" ;;
                        "By Year") current_context="year"; current_sort="desc" ;;
                        "By Title") current_context="title"; current_sort="asc" ;;
                        "By Rating") current_context="rating"; current_sort="desc" ;;
                        "By Peers") current_context="peers"; current_sort="desc" ;;
                     esac
                     continue
                     ;;
                105) # Sort Menu (^V) - Context Aware
                     local sort_opts=""
                     case "$current_context" in
                        default|year) sort_opts="Newest First (desc)\nOldest First (asc)" ;;
                        rating)       sort_opts="Highest Rated (desc)\nLowest Rated (asc)" ;;
                        peers)        sort_opts="Most Seeds (desc)\nFewest Seeds (asc)" ;;
                        title)        sort_opts="A-Z (asc)\nZ-A (desc)" ;;
                     esac
                     
                     local sel_sort
                     sel_sort=$(echo -e "$sort_opts" | fzf --height=10 --layout=reverse --border --prompt="Sort: " --header="Sort Order" 2>/dev/null)
                     
                     if [[ -n "$sel_sort" ]]; then
                         if [[ "$sel_sort" == *"asc)" ]]; then current_sort="asc"; else current_sort="desc"; fi
                         
                         # If in Rating context, also show Min Rating picker after sort?
                         if [[ "$current_context" == "rating" && "$sel_sort" == *"Highest"* ]]; then
                             local r_opts="9+\n8+\n7+\n6+\nAny"
                             local r_sel=$(echo -e "$r_opts" | fzf --height=8 --layout=reverse --border --prompt="Min Rating: " 2>/dev/null)
                             case "$r_sel" in
                                "9+") current_min_rating=9 ;;
                                "8+") current_min_rating=8 ;;
                                "7+") current_min_rating=7 ;;
                                "6+") current_min_rating=6 ;;
                                *)    current_min_rating=0 ;;
                             esac
                         fi
                     fi
                     continue
                     ;;
                106)
                    # Genre dropdown: show FZF popup with genre list
                    local genre_list="All Genres\nAction\nAdventure\nAnimation\nComedy\nCrime\nDocumentary\nDrama\nFamily\nFantasy\nHorror\nMusic\nMystery\nRomance\nSci-Fi\nThriller\nWar\nWestern"
                    local selected_genre
                    selected_genre=$(echo -e "$genre_list" | fzf --height=15 --layout=reverse --border --prompt="Genre: " --header="Filter by genre" 2>/dev/null)
                    
                    if [[ -n "$selected_genre" && "$selected_genre" != "All Genres" ]]; then
                        export CURRENT_GENRE="$selected_genre" # Use export for CURRENT_GENRE
                    else
                        export CURRENT_GENRE=""
                    fi
                    continue
                    ;;
                110)
                    # Year dropdown (^Y)
                    # Generate years from current year down to 1950
                    local current_yr=$(date +%Y)
                    local year_list=$(seq "$current_yr" -1 1950)
                    local selected_year
                    selected_year=$(echo "$year_list" | fzf --height=15 --layout=reverse --border --prompt="Year: " --header="Filter by Year" 2>/dev/null)
                    
                    if [[ -n "$selected_year" ]]; then
                        current_query="$selected_year"
                    fi
                    continue
                    ;;
                109)
                    # Refresh: Force reload of catalog data
                    export FORCE_REFRESH=true
                    continue
                    ;;
                *)   break ;;  # User cancelled or streamed
            esac
        done
        
        exit 0
    fi
    
    # Check dependencies for streaming (only needed when actually streaming)
    check_deps
    check_jq
    
    # Get source from clipboard if not provided
    if [ -z "$source" ]; then
        if command -v pbpaste &> /dev/null; then
            # BSD grep compatible (no -P flag)
            source=$(pbpaste | grep -oE 'magnet:\?[^[:space:]]+' | head -1)
            if [ -n "$source" ]; then
                echo -e "${GREEN}Using magnet link from clipboard${RESET}"
            fi
        fi
        
        if [ -z "$source" ]; then
            echo -e "${RED}Error:${RESET} No magnet link or torrent file provided"
            echo "Usage: termflix <magnet_link|torrent_file>"
            echo "   or: termflix --help"
            exit 1
        fi
    fi
    
    # Handle auto-quality selection
    if [ "$auto_quality" = true ] && [ -z "$index" ]; then
        index=$(select_best_quality "$source")
    fi
    
    # Stream the torrent
    stream_torrent "$source" "$index" "$list_only" "$enable_subtitles"
}

# Run main function
# Run main function if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
