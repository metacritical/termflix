#!/usr/bin/env bash
#
# Termflix - Torrent Streaming Tool - Stream torrents directly to mpv/vlc
# Usage: termflix [command] or termflix <magnet_link|torrent_file>
#

# Don't exit on error - we handle errors gracefully
set +e
# Suppress job control messages (like "Terminated: 15")
set +H 2>/dev/null || true

# Cleanup function for poster images
cleanup_on_exit() {
    cleanup_posters
}
trap cleanup_on_exit EXIT INT TERM

# Resolve script directory (works even when called via PATH or symlinks)
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
export TERMFLIX_SCRIPTS_DIR="${SCRIPT_DIR}/scripts"

# Source termflix modules - NEW MODULAR STRUCTURE
# Core modules (load first - colors, config, errors, deps)
source "${SCRIPT_DIR}/modules/core/colors.sh"
source "${SCRIPT_DIR}/modules/core/errors.sh"
source "${SCRIPT_DIR}/modules/core/config.sh"
source "${SCRIPT_DIR}/modules/core/deps.sh"

# UI modules
source "${SCRIPT_DIR}/modules/ui/status.sh"
source "${SCRIPT_DIR}/modules/ui/sidebar_picker.sh"
source "${SCRIPT_DIR}/modules/ui/help.sh"

# Legacy modules (to be refactored into new structure)
source "${SCRIPT_DIR}/modules/posters.sh"
source "${SCRIPT_DIR}/modules/search.sh"
source "${SCRIPT_DIR}/modules/catalog.sh"
source "${SCRIPT_DIR}/modules/torrent.sh"

# Set up signal handlers from errors.sh
setup_signal_handlers


# Check for jq - now in core.sh module (keeping for backward compat)
check_jq() {
    if ! command -v jq &> /dev/null; then
        echo -e "${YELLOW}Warning:${RESET} jq not found. Some search features may be limited."
        if [[ "$OSTYPE" == "darwin"* ]]; then
            echo "Install with: ${CYAN}brew install jq${RESET}"
        else
            echo "Install with: ${CYAN}sudo apt-get install jq${RESET} (Debian/Ubuntu) or ${CYAN}sudo yum install jq${RESET} (RHEL/CentOS)"
        fi
        echo
    fi
}

# Check for viu (optional, for displaying images - cross-platform)
check_viu() {
    if ! command -v viu &> /dev/null; then
        echo -e "${YELLOW}Note:${RESET} viu not found. Movie posters will not be displayed."
        if [[ "$OSTYPE" == "darwin"* ]]; then
            echo "Install with: ${CYAN}brew install viu${RESET} or ${CYAN}cargo install viu${RESET}"
        else
            echo "Install with: ${CYAN}cargo install viu${RESET} or ${CYAN}sudo apt-get install viu${RESET} (if available in repos)"
        fi
        echo
        return 1
    fi
    return 0
}

# ============================================================
# VIU ANSI CACHING SYSTEM
# Pre-renders poster images with viu and caches the ANSI escape
# sequences for instant display (~4x faster than rendering each time)
# ============================================================

# Get the VIU render cache directory
get_viu_cache_dir() {
    local cache_dir="$HOME/.config/termflix/cache/viu_renders"
    mkdir -p "$cache_dir" 2>/dev/null
    echo "$cache_dir"
}

# Generate cache key from image source and dimensions
# Returns: hash string suitable for filename
viu_cache_key() {
    local image_source="$1"
    local width="${2:-15}"
    local height="${3:-10}"
    
    # Create unique key from source + dimensions
    local key_input="${image_source}_${width}x${height}"
    local hash
    hash=$(echo "$key_input" | md5 2>/dev/null || echo "$key_input" | md5sum 2>/dev/null | cut -d' ' -f1)
    echo "${hash:0:16}"
}

# Check if cached viu render exists and is valid
# Returns 0 if cache hit, 1 if cache miss
viu_cache_exists() {
    local cache_key="$1"
    local cache_dir
    cache_dir=$(get_viu_cache_dir)
    local cache_file="${cache_dir}/${cache_key}.ansi"
    
    if [ -f "$cache_file" ] && [ -s "$cache_file" ]; then
        return 0  # Cache hit
    fi
    return 1  # Cache miss
}

# Pre-render image with viu and cache the ANSI output
# This is the expensive operation (~300-1000ms) we want to do only once
prerender_poster_viu() {
    local image_file="$1"
    local width="${2:-15}"
    local height="${3:-10}"
    local cache_key="${4:-}"
    
    if [ ! -f "$image_file" ] || [ ! -s "$image_file" ]; then
        return 1
    fi
    
    # Generate cache key if not provided
    if [ -z "$cache_key" ]; then
        cache_key=$(viu_cache_key "$image_file" "$width" "$height")
    fi
    
    local cache_dir
    cache_dir=$(get_viu_cache_dir)
    local cache_file="${cache_dir}/${cache_key}.ansi"
    
    # Check if already cached
    if [ -f "$cache_file" ] && [ -s "$cache_file" ]; then
        echo "$cache_file"
        return 0
    fi
    
    # Check if viu is available
    if ! command -v viu &>/dev/null; then
        return 1
    fi
    
    # Pre-render with viu and capture ANSI output
    viu -w "$width" -h "$height" "$image_file" 2>/dev/null > "$cache_file"
    
    if [ -f "$cache_file" ] && [ -s "$cache_file" ]; then
        echo "$cache_file"
        return 0
    fi
    
    rm -f "$cache_file" 2>/dev/null
    return 1
}

# Display cached viu render (instant - just cat the ANSI file)
display_cached_viu() {
    local cache_file="$1"
    local x_pos="${2:-}"
    local y_pos="${3:-}"
    
    if [ ! -f "$cache_file" ] || [ ! -s "$cache_file" ]; then
        return 1
    fi
    
    # Position cursor if coordinates provided
    if [ -n "$x_pos" ] && [ -n "$y_pos" ]; then
        tput cup "$y_pos" "$x_pos" 2>/dev/null || true
    fi
    
    # Instant display - just cat the pre-rendered ANSI
    cat "$cache_file"
    return 0
}

# Background pre-render multiple posters in parallel
# Usage: prerender_posters_batch image1 image2 image3 ...
prerender_posters_batch() {
    local width="${1:-15}"
    local height="${2:-10}"
    shift 2
    local image_files=("$@")
    
    local pids=()
    for image_file in "${image_files[@]}"; do
        if [ -f "$image_file" ] && [ -s "$image_file" ]; then
            prerender_poster_viu "$image_file" "$width" "$height" &
            pids+=($!)
        fi
    done
    
    # Wait for all background renders to complete
    for pid in "${pids[@]}"; do
        wait "$pid" 2>/dev/null || true
    done
}

# Clean up old viu cache files (older than 7 days)
cleanup_viu_cache() {
    local cache_dir
    cache_dir=$(get_viu_cache_dir)
    
    if [ -d "$cache_dir" ]; then
        find "$cache_dir" -name "*.ansi" -type f -mtime +7 -delete 2>/dev/null || true
    fi
}

# Download and display poster image (with VIU caching for ~4x speedup)
display_poster() {
    local poster_source="$1"  # Can be a URL or a cached file path
    local width="${2:-20}"
    local height="${3:-15}"
    local x_pos="${4:-}"
    local y_pos="${5:-}"
    
    if [ -z "$poster_source" ] || [ "$poster_source" = "N/A" ] || [ "$poster_source" = "" ]; then
        return 1
    fi
    
    local image_file=""
    
    # Check if it's already a cached file path
    if [ -f "$poster_source" ]; then
        image_file="$poster_source"
    else
        # It's a URL, download it to temp directory
        local temp_dir="${TMPDIR:-/tmp}/torrent_posters_$$"
        mkdir -p "$temp_dir" 2>/dev/null || return 1
        
        # Use md5 on macOS, md5sum on Linux
        local hash=$(echo "$poster_source" | md5 2>/dev/null || echo "$poster_source" | md5sum 2>/dev/null | cut -d' ' -f1)
        image_file="${temp_dir}/poster_$(echo "$hash" | cut -c1-8).jpg"
        
        if [ ! -f "$image_file" ]; then
            curl -s --max-time 5 "$poster_source" -o "$image_file" 2>/dev/null || return 1
        fi
    fi
    
    if [ ! -f "$image_file" ] || [ ! -s "$image_file" ]; then
        return 1
    fi

    # Check for Kitty terminal (native image protocol - no caching needed)
    if [[ "$TERM" == "xterm-kitty" ]] && command -v kitty &> /dev/null; then
        if [ -n "$x_pos" ] && [ -n "$y_pos" ]; then
            tput cup "$y_pos" "$x_pos"
            kitty +kitten icat --align left --place "${width}x${height}@${x_pos}x${y_pos}" "$image_file" 2>/dev/null
        else
            kitty +kitten icat --align left --height "$height" "$image_file" 2>/dev/null
        fi
        return 0
    fi
    
    # VIU with ANSI caching (check cache first for instant display)
    if check_viu >/dev/null 2>&1; then
        # Generate cache key for this image + dimensions
        local cache_key
        cache_key=$(viu_cache_key "$image_file" "$width" "$height")
        local cache_dir
        cache_dir=$(get_viu_cache_dir)
        local cached_ansi="${cache_dir}/${cache_key}.ansi"
        
        # Try to use cached render first (instant display!)
        if [ -f "$cached_ansi" ] && [ -s "$cached_ansi" ]; then
            display_cached_viu "$cached_ansi" "$x_pos" "$y_pos"
            return 0
        fi
        
        # Cache miss - pre-render and cache for next time
        local new_cache
        new_cache=$(prerender_poster_viu "$image_file" "$width" "$height" "$cache_key")
        
        if [ -n "$new_cache" ] && [ -f "$new_cache" ]; then
            # Display the newly cached render
            display_cached_viu "$new_cache" "$x_pos" "$y_pos"
            return 0
        fi
        
        # Fallback: direct viu render (shouldn't happen often)
        if [ -n "$x_pos" ] && [ -n "$y_pos" ]; then
            tput cup "$y_pos" "$x_pos"
            viu -w "$width" -h "$height" "$image_file" 2>/dev/null
        else
            viu -w "$width" -h "$height" "$image_file" 2>/dev/null
        fi
        return 0
    fi
    
    return 1
}



# Cleanup poster images
cleanup_posters() {
    local temp_dir="${TMPDIR:-/tmp}/torrent_posters_$$"
    rm -rf "$temp_dir" 2>/dev/null
}

# Termflix config directory
get_termflix_config_dir() {
    echo "$HOME/.config/termflix"
}

# Termflix config file
get_termflix_config_file() {
    echo "$(get_termflix_config_dir)/config"
}

# Termflix cache directory
get_termflix_cache_dir() {
    echo "$(get_termflix_config_dir)/cache"
}

# Initialize termflix directories
init_termflix_dirs() {
    local config_dir=$(get_termflix_config_dir)
    local cache_dir=$(get_termflix_cache_dir)
    mkdir -p "$config_dir" 2>/dev/null
    mkdir -p "$cache_dir" 2>/dev/null
    mkdir -p "$cache_dir/tmdb" 2>/dev/null
}

# Generate cache key from function names and arguments
generate_cache_key() {
    local args=("$@")
    local key_parts=()
    for arg in "${args[@]}"; do
        key_parts+=("$arg")
    done
    # Create a hash-like key from all arguments
    local key=$(printf '%s|' "${key_parts[@]}" | shasum -a 256 | cut -d' ' -f1)
    echo "$key"
}

# Check if cache is valid (less than 1 hour old)
is_cache_valid() {
    local cache_file="$1"
    if [ ! -f "$cache_file" ]; then
        return 1
    fi
    
    local cache_age=$(($(date +%s) - $(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null)))
    local max_age=$((1 * 60 * 60))  # 1 hour in seconds
    
    if [ "$cache_age" -lt "$max_age" ]; then
        return 0  # Cache is valid
    else
        return 1  # Cache is expired
    fi
}

# Get TMDB API Key
get_tmdb_api_key() {
    local config_file=$(get_termflix_config_file)
    
    if [ -f "$config_file" ]; then
        # Try specific TMDB_API_KEY first, then generic API_KEY
        local key=$(grep "^TMDB_API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        if [ -z "$key" ]; then
            key=$(grep "^API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        fi
        echo "$key"
    fi
}

# Get TMDB Read Access Token
get_tmdb_read_token() {
    local config_file=$(get_termflix_config_file)
    
    if [ -f "$config_file" ]; then
        local token=$(grep "^TMDB_READ_TOKEN=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        echo "$token"
    fi
}

# Get OMDB API Key (deprecated, kept for backward compatibility)
get_omdb_api_key() {
    local config_file=$(get_termflix_config_file)
    
    if [ -f "$config_file" ]; then
        # Try specific OMDB_API_KEY first, then generic API_KEY
        local key=$(grep "^OMDB_API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        if [ -z "$key" ]; then
            key=$(grep "^API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        fi
        echo "$key"
    fi
}

# Fetch poster from Google Images (fallback)
fetch_google_poster() {
    local title="$1"
    local year="$2"
    
    if [ -z "$title" ]; then
        echo "N/A"
        return 1
    fi
    
    # Use external Python script
    export GOOGLE_QUERY="$title $year movie poster"
    
    python3 "$TERMFLIX_SCRIPTS_DIR/google_poster.py"
}

# Fetch poster from TMDB (TheMovieDB) with caching
fetch_tmdb_poster() {
    local title="$1"
    local year="$2"
    
    if [ -z "$title" ]; then
        echo "N/A"
        return 1
    fi
    
    init_termflix_dirs
    
    # Clean title for cache key (remove special chars)
    local clean_title=$(echo "$title" | tr -cd '[:alnum:]')
    local cache_key="${clean_title}_${year}"
    local cache_dir=$(get_termflix_cache_dir)/tmdb
    local images_cache_dir="$cache_dir/images"
    local cache_file="$cache_dir/${cache_key}.json"
    local cached_image="$images_cache_dir/${cache_key}.jpg"
    
    mkdir -p "$cache_dir" 2>/dev/null
    mkdir -p "$images_cache_dir" 2>/dev/null
    
    # Check if we have a cached image file
    if [ -f "$cached_image" ]; then
        echo "$cached_image"
        return 0
    fi
    
    # Check cache for movie data
    local movie_id=""
    local poster_path=""
    
    if [ -f "$cache_file" ]; then
        # Extract movie_id and poster_path from cached JSON
        if command -v jq &> /dev/null; then
            movie_id=$(cat "$cache_file" | jq -r '.id // empty' 2>/dev/null)
            poster_path=$(cat "$cache_file" | jq -r '.poster_path // empty' 2>/dev/null)
        else
            movie_id=$(cat "$cache_file" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
            poster_path=$(cat "$cache_file" | grep -o '"poster_path":"[^"]*"' | cut -d'"' -f4)
        fi
        
        # If we have a cached poster_path but no image file, try to download it
        if [ -n "$poster_path" ] && [ "$poster_path" != "null" ] && [ "$poster_path" != "N/A" ] && [ -n "$movie_id" ]; then
            local image_url="https://image.tmdb.org/t/p/w500${poster_path}"
            if curl -s --max-time 5 "$image_url" -o "$cached_image" 2>/dev/null && [ -f "$cached_image" ] && [ -s "$cached_image" ]; then
                echo "$cached_image"
                return 0
            fi
        fi
    fi
    
    # Get API credentials
    local api_key=$(get_tmdb_api_key)
    local read_token=$(get_tmdb_read_token)
    
    if [ -z "$api_key" ]; then
        echo "N/A"
        return 1
    fi
    
    # Step 1: Search for movie to get movie_id
    local encoded_title
    if command -v jq &> /dev/null; then
        encoded_title=$(echo "$title" | jq -sRr @uri | tr -d '\r\n')
    else
        encoded_title=$(echo "$title" | sed 's/ /%20/g')
    fi
    
    local search_url="https://api.themoviedb.org/3/search/movie?api_key=${api_key}&query=${encoded_title}"
    if [ -n "$year" ]; then
        search_url="${search_url}&year=${year}"
    fi
    
    if ! command -v curl &> /dev/null; then
        echo "N/A"
        return 1
    fi
    
    local search_response=$(curl -s --max-time 5 "$search_url" 2>/dev/null)
    
    if [ -z "$search_response" ]; then
        echo "N/A"
        return 1
    fi
    
    # Extract movie_id from search results
    if [ -z "$movie_id" ]; then
        if command -v jq &> /dev/null; then
            movie_id=$(echo "$search_response" | jq -r '.results[0].id // empty' 2>/dev/null)
            poster_path=$(echo "$search_response" | jq -r '.results[0].poster_path // empty' 2>/dev/null)
        else
            movie_id=$(echo "$search_response" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
            poster_path=$(echo "$search_response" | grep -o '"poster_path":"[^"]*"' | head -1 | cut -d'"' -f4)
        fi
    fi
    
    if [ -z "$movie_id" ] || [ "$movie_id" = "null" ]; then
        # Cache the response even if no movie found
        echo "$search_response" > "$cache_file"
        echo "N/A"
        return 1
    fi
    
    # Step 2: Use images API to verify and get poster information
    local images_url="https://api.themoviedb.org/3/movie/${movie_id}/images"
    local images_response=""
    
    # Try with Bearer token first (more reliable)
    if [ -n "$read_token" ]; then
        images_response=$(curl -s --max-time 5 \
            --header "Authorization: Bearer ${read_token}" \
            --header "accept: application/json" \
            "$images_url" 2>/dev/null)
    fi
    
    # Fallback to API key if Bearer token didn't work or wasn't available
    if [ -z "$images_response" ] || echo "$images_response" | grep -q "Invalid\|Unauthorized\|401"; then
        images_url="${images_url}?api_key=${api_key}"
        images_response=$(curl -s --max-time 5 "$images_url" 2>/dev/null)
    fi
    
    # Extract poster_path from images API response (more reliable)
    if [ -n "$images_response" ]; then
        if command -v jq &> /dev/null; then
            # Get the first poster from the posters array
            poster_path=$(echo "$images_response" | jq -r '.posters[0].file_path // empty' 2>/dev/null)
            # If no poster in images API, try the original from search
            if [ -z "$poster_path" ] || [ "$poster_path" = "null" ]; then
                poster_path=$(echo "$search_response" | jq -r '.results[0].poster_path // empty' 2>/dev/null)
            fi
        else
            poster_path=$(echo "$images_response" | grep -o '"file_path":"[^"]*"' | head -1 | cut -d'"' -f4)
            if [ -z "$poster_path" ]; then
                poster_path=$(echo "$search_response" | grep -o '"poster_path":"[^"]*"' | head -1 | cut -d'"' -f4)
            fi
        fi
    fi
    
    # Fetch full movie details to get genre names and other metadata
    local movie_details=""
    if [ -n "$movie_id" ] && [ "$movie_id" != "null" ]; then
        local details_url="https://api.themoviedb.org/3/movie/${movie_id}"
        if [ -n "$read_token" ]; then
            movie_details=$(curl -s --max-time 5 \
                --header "Authorization: Bearer ${read_token}" \
                "$details_url" 2>/dev/null)
        fi
        if [ -z "$movie_details" ] || echo "$movie_details" | grep -q "Invalid\|Unauthorized\|401"; then
            details_url="${details_url}?api_key=${api_key}"
            movie_details=$(curl -s --max-time 5 "$details_url" 2>/dev/null)
        fi
    fi
    
    # Save to cache (prefer movie details if available, otherwise use search response)
    if [ -n "$movie_details" ] && [ "$movie_details" != "" ]; then
        # Use movie details which includes genre names
        if command -v jq &> /dev/null; then
            echo "$movie_details" | jq --arg path "$poster_path" '. + {poster_path: $path}' > "$cache_file" 2>/dev/null || \
            echo "$movie_details" > "$cache_file" 2>/dev/null
        else
            echo "$movie_details" > "$cache_file"
        fi
    elif command -v jq &> /dev/null; then
        # Fallback to search response
        echo "$search_response" | jq --arg id "$movie_id" --arg path "$poster_path" '.results[0] | .id = ($id | tonumber) | .poster_path = $path' > "$cache_file" 2>/dev/null || \
        echo "$search_response" | jq '.results[0] // {}' > "$cache_file" 2>/dev/null
    else
        echo "$search_response" > "$cache_file"
    fi
    
    # Step 3: Download and cache the image if we have a poster_path
    if [ -n "$poster_path" ] && [ "$poster_path" != "null" ] && [ "$poster_path" != "N/A" ]; then
        local image_url="https://image.tmdb.org/t/p/w500${poster_path}"
        
        # Download the image
        if curl -s --max-time 10 "$image_url" -o "$cached_image" 2>/dev/null && [ -f "$cached_image" ] && [ -s "$cached_image" ]; then
            # Verify it's actually an image file
            if file "$cached_image" 2>/dev/null | grep -q "image"; then
                echo "$cached_image"
                return 0
            else
                rm -f "$cached_image" 2>/dev/null
            fi
        fi
    fi
    
    echo "N/A"
    return 1
}

# Fetch poster from OMDB with caching (deprecated, now uses TMDB only)
fetch_omdb_poster() {
    # Use TMDB only (no OMDB fallback)
    fetch_tmdb_poster "$1" "$2"
}

# Enrich entries with missing posters by looking them up on TMDB
# Input: array of result lines (passed via global variable name)
# Modifies the array in place, updating N/A posters with TMDB URLs
enrich_missing_posters() {
    local -n results_ref=$1  # nameref to results array
    local max_to_enrich=${2:-20}  # Limit to first N entries for speed
    local enriched=0
    local pids=()
    local tmpdir=$(mktemp -d)
    
    # Extract title and year from entry name, fetch poster in background
    for i in "${!results_ref[@]}"; do
        [ "$enriched" -ge "$max_to_enrich" ] && break
        
        local entry="${results_ref[$i]}"
        local poster_field=""
        
        # Get the poster field (last field in pipe-delimited format)
        if [[ "$entry" =~ ^COMBINED\| ]]; then
            # COMBINED|Name|Sources|Seeds|Qualities|Sizes|Magnets|Poster
            poster_field=$(echo "$entry" | cut -d'|' -f8)
        else
            # Source|Name|Magnet|Quality|Size|Extra|Poster
            poster_field=$(echo "$entry" | cut -d'|' -f7)
        fi
        
        # Skip if already has poster
        if [[ -n "$poster_field" && "$poster_field" != "N/A" && "$poster_field" != "" ]]; then
            continue
        fi
        
        # Extract name for TMDB lookup
        local name=""
        if [[ "$entry" =~ ^COMBINED\| ]]; then
            name=$(echo "$entry" | cut -d'|' -f2)
        else
            name=$(echo "$entry" | cut -d'|' -f2)
        fi
        
        # Extract year if present (e.g., "Movie Name (2025)")
        local year=""
        if [[ "$name" =~ \(([0-9]{4})\) ]]; then
            year="${BASH_REMATCH[1]}"
        fi
        
        # Clean title (remove year, quality tags, etc.)
        local clean_title=$(echo "$name" | sed -E 's/\([0-9]{4}\)//g' | sed -E 's/\[[^\]]+\]//g' | sed -E 's/(1080p|720p|480p|HDRip|WEBRip|BluRay|HEVC|x264|x265).*//gi' | xargs)
        
        if [ -n "$clean_title" ]; then
            # Fetch poster in background and save to temp file
            (
                local poster_url=$(fetch_tmdb_poster "$clean_title" "$year" 2>/dev/null)
                if [[ -n "$poster_url" && "$poster_url" != "N/A" ]]; then
                    echo "$poster_url" > "$tmpdir/poster_$i"
                fi
            ) &
            pids+=($!)
            enriched=$((enriched + 1))
        fi
    done
    
    # Wait for all fetches to complete (with timeout)
    local wait_count=0
    while [ $wait_count -lt 20 ]; do  # 10 second timeout
        local all_done=true
        for pid in "${pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                all_done=false
                break
            fi
        done
        [ "$all_done" = true ] && break
        sleep 0.5
        wait_count=$((wait_count + 1))
    done
    
    # Kill remaining background processes
    for pid in "${pids[@]}"; do
        kill "$pid" 2>/dev/null || true
    done
    wait "${pids[@]}" 2>/dev/null || true
    
    # Update entries with fetched posters
    for i in "${!results_ref[@]}"; do
        if [ -f "$tmpdir/poster_$i" ]; then
            local new_poster=$(cat "$tmpdir/poster_$i")
            local entry="${results_ref[$i]}"
            
            # Replace the N/A poster with the fetched URL
            if [[ "$entry" =~ ^COMBINED\| ]]; then
                # Replace last field (poster)
                results_ref[$i]=$(echo "$entry" | sed "s/|N/A$/|$new_poster/" | sed "s/|$/|$new_poster/")
            else
                results_ref[$i]=$(echo "$entry" | sed "s/|N/A$/|$new_poster/" | sed "s/|$/|$new_poster/")
            fi
        fi
    done
    
    rm -rf "$tmpdir" 2>/dev/null
}

export -f get_omdb_api_key get_tmdb_api_key get_tmdb_read_token fetch_omdb_poster fetch_tmdb_poster fetch_google_poster enrich_missing_posters

# Colors - Charm/Charmbracelet style palette
# Inspired by Charm CLI tools (gum, bubbletea, lipgloss)
RED='\033[0;31m'
GREEN='\033[1;38;5;46m'       # Bright luminous green (like Charm selection highlight)
YELLOW='\033[1;38;5;220m'     # Warm yellow/gold
BLUE='\033[1;38;5;81m'        # Light blue (like Charm keywords)
CYAN='\033[1;38;5;87m'        # Bright cyan
MAGENTA='\033[1;38;5;213m'    # Vibrant magenta/pink (Charm accent - like ////// separators)
PURPLE='\033[1;38;5;135m'     # Medium purple (Charm border color)
PINK='\033[1;38;5;219m'       # Soft pink for secondary accents
BOLD='\033[1m'
RESET='\033[0m'

# Charm-style spinner configuration (unified across all spinners)
CHARM_SPINNER_CHARS=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
CHARM_SPINNER_1_COLOR="$MAGENTA"   # First spinner - vibrant magenta
CHARM_SPINNER_2_COLOR="$CYAN"      # Second spinner - bright cyan

# Get or set player preference
get_player_preference() {
    init_termflix_dirs
    local config_file=$(get_termflix_config_file)
    
    # Check if preference exists
    if [ -f "$config_file" ]; then
        local player=$(grep "^PLAYER=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        if [ -n "$player" ] && [[ "$player" =~ ^(mpv|vlc)$ ]]; then
            echo "$player"
            return 0
        fi
    fi
    
    # Ask user for preference (first time) - check if /dev/tty is available
    # Don't check stdin (-t 0) as it may be consumed by previous reads
    if [ -c /dev/tty ] 2>/dev/null && [ -r /dev/tty ] 2>/dev/tty; then
        # Use a timeout to prevent hanging - try to read with a timeout
        echo
        echo -e "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${PINK}First time setup:${RESET} Which media player would you like to use?"
        echo -e "  ${MAGENTA}1${RESET}) mpv (recommended)"
        echo -e "  ${MAGENTA}2${RESET}) VLC"
        echo -ne "${PINK}Enter choice (1 or 2, default: 1):${RESET} "
        
        # Try to read with timeout (10 seconds) - if it fails, default to mpv
        # Use read -t which is built into bash and won't block forever
        local choice=""
        if ! read -t 10 -r choice < /dev/tty 2>/dev/null; then
            # Timeout or error - default to mpv
            choice="1"
            echo ""  # New line after timeout
        fi
        
        # Default to 1 if empty or invalid
        [ -z "$choice" ] && choice="1"
        
        local selected_player="mpv"
        case "$choice" in
            2) selected_player="vlc" ;;
            *) selected_player="mpv" ;;
        esac
        
        # Verify player is installed
        if ! command -v "$selected_player" &> /dev/null; then
            echo -e "${RED}Error:${RESET} $selected_player is not installed."
            if [[ "$OSTYPE" == "darwin"* ]]; then
                echo "Please install it first: ${CYAN}brew install $selected_player${RESET}"
            else
                echo "Please install it first: ${CYAN}sudo apt-get install $selected_player${RESET} (Debian/Ubuntu) or ${CYAN}sudo yum install $selected_player${RESET} (RHEL/CentOS)"
            fi
            echo "Defaulting to mpv..."
            selected_player="mpv"
        fi
        
        # Save preference
        echo "PLAYER=$selected_player" > "$config_file"
        echo -e "${GREEN}✓ Preference saved to:${RESET} $config_file"
        echo -e "${CYAN}Note:${RESET} Edit this file to change your preference later."
        echo -e "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo
        
        echo "$selected_player"
        return 0
    else
        # Non-interactive mode or no TTY, default to mpv
        echo "mpv"
        return 0
    fi
}

# Check dependencies
check_deps() {
    local missing=()
    
    # Check for peerflix (primary tool) or webtorrent (alternative)
    if command -v peerflix &> /dev/null; then
        TORRENT_TOOL="peerflix"
    elif command -v webtorrent &> /dev/null; then
        TORRENT_TOOL="webtorrent"
        echo -e "${YELLOW}Note:${RESET} Using webtorrent (peerflix not found)"
        echo "  For better compatibility, install peerflix: ${CYAN}npm install -g peerflix${RESET}"
    else
        echo -e "${RED}Error:${RESET} No torrent streaming tool found."
        echo
        echo "Please install one of:"
        echo "  ${GREEN}npm install -g peerflix${RESET}  (recommended)"
        echo "  ${GREEN}npm install -g webtorrent-cli${RESET}  (alternative)"
        echo
        if [[ "$OSTYPE" == "darwin"* ]]; then
            echo "Or use: ${CYAN}brew install peerflix${RESET}"
        else
            echo "Or use: ${CYAN}npm install -g peerflix${RESET} (works on all platforms)"
        fi
        exit 1
    fi
    
    # Check for transmission-cli (fallback for problematic magnet links)
    if ! command -v transmission-cli &> /dev/null; then
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${YELLOW}Warning:${RESET} transmission-cli not found"
        echo ""
        echo "transmission-cli is used as a fallback when peerflix fails to handle"
        echo "certain magnet links. It's recommended to install it for better compatibility."
        echo ""
        echo -e "${CYAN}Would you like to install transmission-cli now? (y/n)${RESET} "
        read -r install_transmission
        
        if [[ "$install_transmission" =~ ^[Yy]$ ]]; then
            echo ""
            echo -e "${CYAN}Installing transmission-cli...${RESET}"
            
            # Try brew first (macOS)
            if command -v brew &> /dev/null; then
                echo -e "${GREEN}Using Homebrew...${RESET}"
                if brew install transmission-cli; then
                    echo -e "${GREEN}✓ transmission-cli installed successfully${RESET}"
                    echo ""
                else
                    echo -e "${RED}✗ Installation failed. Please install manually:${RESET}"
                    echo "  ${GREEN}brew install transmission-cli${RESET}"
                    echo ""
                    echo -e "${YELLOW}You can continue without it, but some magnet links may not work.${RESET}"
                fi
            else
                echo -e "${YELLOW}Homebrew not found. Please install transmission-cli manually:${RESET}"
                echo ""
                echo "  ${GREEN}macOS:${RESET} brew install transmission-cli"
                echo "  ${GREEN}Linux:${RESET} sudo apt-get install transmission-cli  (Debian/Ubuntu)"
                echo "  ${GREEN}Linux:${RESET} sudo yum install transmission-cli    (RHEL/CentOS)"
                echo ""
                echo -e "${YELLOW}You can continue without it, but some magnet links may not work.${RESET}"
            fi
        else
            echo -e "${YELLOW}Skipping transmission-cli installation.${RESET}"
            echo -e "${YELLOW}Note:${RESET} Some magnet links may not work without transmission-cli."
            echo ""
        fi
    fi
    
    # Note: Player preference will be checked when streaming starts
    # This avoids prompting during catalog browsing
}

# Search using YTS API (movies) - same as Stremio YTS addon
# Uses same approach as YTS-Streaming app
search_yts() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}YTS${MAGENTA}]${RESET} Searching movies..." >&2
    
    if ! command -v python3 &> /dev/null; then
        echo -e "${YELLOW}Warning:${RESET} python3 required for YTS scraping" >&2
        return 1
    fi
    
    export YTS_QUERY="$query"
    python3 "$TERMFLIX_SCRIPTS_DIR/search_yts.py"
}

# Search using YTSRS (en.ytsrs.com) - web crawler approach
search_ytsrs() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}YTS${MAGENTA}]${RESET} Searching movies..." >&2
    
    if ! command -v python3 &> /dev/null; then
        return 1
    fi

    # Pass query as argument to python script
    python3 - "$query" << 'PYEOF'
import sys, re, json, urllib.parse, urllib.request, os

def scrape_yts_movies(sort='date_added', order='desc', limit=20, page=1, genre=None, quality='1080p', keyword=None):
    """Scrape movies from YTS website - uses working domains: yts.rs and yts.hn"""
    domains = ['https://yts.mx', 'https://yts.ag', 'https://yts.am', 'https://yts.pm', 'https://yts.lt', 'https://yts.rs', 'https://yts.hn']
    base_url = None
    
    # Test which domain works
    for domain in domains:
        try:
            req = urllib.request.Request(f"{domain}/browse-movies", headers={'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'})
            with urllib.request.urlopen(req, timeout=5) as response:
                if response.status == 200:
                    base_url = domain
                    break
        except: continue
    
    if not base_url: base_url = 'https://yts.rs'
    
    # Build browse URL
    url = f"{base_url}/browse-movies"
    params = []
    if sort: params.append(f"sort_by={sort}")
    if keyword: params.append(f"keyword={urllib.parse.quote(keyword)}")
    
    if params: url += "?" + "&".join(params)
    
    try:
        req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'})
        with urllib.request.urlopen(req, timeout=15) as response:
            html = response.read().decode('utf-8', errors='ignore')
    except: return []
    
    if not html: return []
    
    movie_links = re.findall(r'<a[^>]+href="/movies/([^"]+)"[^>]*class="[^"]*browse-movie-link[^"]*"[^>]*>', html)
    if not movie_links:
        movie_links = re.findall(r'<a[^>]+href="/movies/([^"]+)"[^>]*>', html)
    
    count = 0
    for slug in movie_links[:limit]:
        try:
            movie_url = f"{base_url}/movies/{slug}"
            req = urllib.request.Request(movie_url, headers={'User-Agent': 'Mozilla/5.0'})
            with urllib.request.urlopen(req, timeout=10) as response:
                movie_html = response.read().decode('utf-8', errors='ignore')
            
            title_match = re.search(r'<h1[^>]*>([^<]+)</h1>', movie_html)
            if not title_match: continue
            title = title_match.group(1).strip()
            
            year_match = re.search(r'<span[^>]*class="[^"]*year[^"]*"[^>]*>(\d{4})</span>', movie_html)
            year = year_match.group(1) if year_match else None
            
            poster_match = re.search(r'<img[^>]+class="[^"]*movie-poster[^"]*"[^>]+src="([^"]+)"', movie_html)
            poster = poster_match.group(1) if poster_match else 'N/A'
            if poster.startswith('/'): poster = f"{base_url}{poster}"
            
            hash_match = re.search(r'magnet:\?xt=urn:btih:([a-fA-F0-9]{40})', movie_html)
            if not hash_match: hash_match = re.search(r'data-hash="([a-fA-F0-9]{40})"', movie_html)
            if not hash_match: continue
            hash_val = hash_match.group(1)
            
            quality_match = re.search(r'<span[^>]*class="[^"]*quality[^"]*"[^>]*>([^<]+)</span>', movie_html, re.IGNORECASE)
            quality = quality_match.group(1).strip() if quality_match else "1080p"
            
            size_match = re.search(r'<span[^>]*class="[^"]*size[^"]*"[^>]*>([^<]+)</span>', movie_html, re.IGNORECASE)
            size = size_match.group(1).strip() if size_match else 'N/A'
            
            seeds_match = re.search(r'<span[^>]*class="[^"]*seeds[^"]*"[^>]*>(\d+)</span>', movie_html, re.IGNORECASE)
            seeds = int(seeds_match.group(1)) if seeds_match else 0
            
            year_str = f" ({year})" if year else ""
            extra = f"{seeds} seeds"
            print(f"YTS|{title}{year_str}|magnet:?xt=urn:btih:{hash_val}|{quality}|{size}|{extra}|{poster}", flush=True)
            count += 1
        except: continue

if __name__ == '__main__':
    keyword = sys.argv[1] if len(sys.argv) > 1 else None
    scrape_yts_movies(keyword=keyword, sort='seeds', limit=20)
PYEOF
    return 0
}



# Group results by Title and Year using external Python script
group_results() {
    tee /tmp/termflix_last_input.txt | python3 "$TERMFLIX_SCRIPTS_DIR/group_results.py" 2>/tmp/termflix_last_error.log
}

# Search using 1337x API - same as Stremio 1337x addon
search_1337x() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}1337x${MAGENTA}]${RESET} Searching..." >&2
    
    if ! command -v python3 &> /dev/null; then
        return 1
    fi
    
    export SEARCH_QUERY="$query"
    python3 "$TERMFLIX_SCRIPTS_DIR/search_1337x.py" 2>/tmp/termflix_last_error.log
}

# Search using ThePirateBay API - same as Stremio TPB addon
search_tpb() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}ThePirateBay${MAGENTA}]${RESET} Searching..." >&2
    
    if ! command -v python3 &> /dev/null; then
        return 1
    fi
    
    export SEARCH_QUERY="$query"
    python3 "$TERMFLIX_SCRIPTS_DIR/search_tpb.py" 2>/tmp/termflix_last_error.log
}

# Search using EZTV API (TV shows) - same as Stremio EZTV addon
search_eztv() {
    local query="$1"
    
    echo -e "${MAGENTA}[${PINK}EZTV${MAGENTA}]${RESET} Searching TV shows..." >&2
    
    if ! command -v python3 &> /dev/null; then
        return 1
    fi
    
    export SEARCH_QUERY="$query"
    python3 "$TERMFLIX_SCRIPTS_DIR/search_eztv.py" 2>/tmp/termflix_last_error.log
}

# Scrape movies from YTSRS (en.ytsrs.com) using external Python script
# Supports genre, quality, sort parameters
get_ytsrs_movies() {
    local genre="${1:-}"
    local quality="${2:-1080p}"
    local sort="${3:-seeds}"
    local limit="${4:-20}"
    local page="${5:-1}"

    if ! command -v python3 &> /dev/null; then
        return 1
    fi
    
    
    python3 "$TERMFLIX_SCRIPTS_DIR/get_ytsrs_movies.py" "$sort" "$limit" "$page" "$genre"
    return 0
}
# Helper function to get source name from function name
get_source_name() {
    local func_name="$1"
    case "$func_name" in
        get_latest_movies|get_trending_movies|get_popular_movies|get_catalog_by_genre)
            echo "YTS"
            ;;
        get_latest_shows)
            echo "EZTV"
            ;;
        search_ytsrs|get_ytsrs_movies)
            echo "YTS"
            ;;
        search_tpb)
            echo "TPB"
            ;;
        search_eztv)
            echo "EZTV"
            ;;
        search_1337x)
            echo "1337x"
            ;;
        *)
            echo "Unknown"
            ;;
    esac
}

# Get latest movies from YTS (like Stremio catalog)
# Uses same approach as YTS-Streaming app
# Supports pagination via page parameter
get_latest_movies() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Try YTS first (same as YTS-Streaming app)
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching latest movies..." >&2
    
    # Build URL the same way as YTS-Streaming app (with pagination)
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?limit=${limit}&sort_by=date_added&order_by=desc&page=${page}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        # Try with timeout - YTS API may be slow or down
        local response=$(curl -s --max-time 3 --connect-timeout 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                # Get movies and their torrents - same structure as YTS-Streaming
                # Include poster URL (medium_cover_image)
                local results=$(echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.date_uploaded // "N/A")|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20)
                
                if [ -n "$results" ]; then
                    echo "$results"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fallback to TPB if YTS fails (YTS API is often down)
    echo -e "${YELLOW}[TPB]${RESET} YTS unavailable, using ThePirateBay..." >&2
    # TPB doesn't have pagination in precompiled, so we fetch more and paginate client-side
    local tpb_url="https://apibay.org/precompiled/data_top100_207.json"
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local tpb_response=$(curl -s --max-time 5 "$tpb_url" 2>/dev/null)
        if [ -n "$tpb_response" ]; then
            # Fetch all available and let display_catalog handle pagination
            echo "$tpb_response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB|Latest"' 2>/dev/null
        fi
    fi
}

# Get trending movies from YTS
# Uses same approach as YTS-Streaming app
# Supports pagination via page parameter
get_trending_movies() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching trending movies..." >&2
    
    # Build URL the same way as YTS-Streaming app (with pagination)
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?limit=${limit}&sort_by=download_count&order_by=desc&page=${page}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 3 --connect-timeout 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                local results=$(echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.download_count // 0)|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20)
                
                if [ -n "$results" ]; then
                    echo "$results"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fallback to TPB trending
    echo -e "${YELLOW}[TPB]${RESET} YTS unavailable, using ThePirateBay trending..." >&2
    local tpb_url="https://apibay.org/precompiled/data_top100_201.json"
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local tpb_response=$(curl -s --max-time 5 "$tpb_url" 2>/dev/null)
        if [ -n "$tpb_response" ]; then
            # Fetch all available for pagination
            echo "$tpb_response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB|Trending"' 2>/dev/null
        fi
    fi
}

# Get popular movies from YTS
# Uses same approach as YTS-Streaming app
# Supports pagination via page parameter
get_popular_movies() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching popular movies..." >&2
    
    # Build URL the same way as YTS-Streaming app (with pagination)
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?limit=${limit}&sort_by=rating&order_by=desc&minimum_rating=7&page=${page}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 3 --connect-timeout 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                local results=$(echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year)) - ⭐\(.rating // "N/A")|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.rating // "N/A")|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20)
                
                if [ -n "$results" ]; then
                    echo "$results"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fallback to TPB popular
    echo -e "${YELLOW}[TPB]${RESET} YTS unavailable, using ThePirateBay popular..." >&2
    local tpb_url="https://apibay.org/precompiled/data_top100_205.json"
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local tpb_response=$(curl -s --max-time 5 "$tpb_url" 2>/dev/null)
        if [ -n "$tpb_response" ]; then
            # Fetch all available for pagination
            echo "$tpb_response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB|Popular"' 2>/dev/null
        fi
    fi
}

# Get latest TV shows from EZTV
# Supports pagination via page parameter
get_latest_shows() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[EZTV]${RESET} Fetching latest TV shows..." >&2
    
    local api_url="https://eztv.re/api/get-torrents?limit=$limit&page=$page"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 5 "$api_url" 2>/dev/null)
        local count=$(echo "$response" | jq -r '.torrents_count // 0' 2>/dev/null)
        
        if [ "$count" -gt 0 ] 2>/dev/null; then
            echo "$response" | jq -r '.torrents[]? | select(.magnet_url != null and .magnet_url != "") | "EZTV|\(.title)|\(.magnet_url)|\(.seeds) seeds|\(.size_bytes / 1024 / 1024 | floor)MB|\(.date_released_unix // 0)"' 2>/dev/null
        fi
    fi
}

# Get catalog by genre
# Uses same approach as YTS-Streaming app
get_catalog_by_genre() {
    local genre="$1"
    local limit="${2:-20}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching $genre movies..." >&2
    
    # Map common genre names to YTS genre IDs (same as YTS-Streaming)
    local genre_id=""
    case "$(echo "$genre" | tr '[:upper:]' '[:lower:]')" in
        action) genre_id="Action" ;;
        adventure) genre_id="Adventure" ;;
        animation) genre_id="Animation" ;;
        comedy) genre_id="Comedy" ;;
        crime) genre_id="Crime" ;;
        documentary) genre_id="Documentary" ;;
        drama) genre_id="Drama" ;;
        family) genre_id="Family" ;;
        fantasy) genre_id="Fantasy" ;;
        horror) genre_id="Horror" ;;
        mystery) genre_id="Mystery" ;;
        romance) genre_id="Romance" ;;
        sci-fi|scifi|science-fiction) genre_id="Sci-Fi" ;;
        thriller) genre_id="Thriller" ;;
        war) genre_id="War" ;;
        western) genre_id="Western" ;;
        *) genre_id="$genre" ;;
    esac
    
    # Build URL the same way as YTS-Streaming app
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?genre=${genre_id}&limit=${limit}&sort_by=date_added&order_by=desc"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        # Add User-Agent header like browsers do
        local response=$(curl -s --max-time 10 --retry 1 --retry-delay 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.genres | join(", "))|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20
            fi
        fi
    fi
}


# Unified search using Stremio-style APIs
search_torrent() {
    local query="$1"
    local all_results=()
    
    echo -e "${BOLD}${YELLOW}Searching for:${RESET} ${BOLD}$query${RESET}"
    echo
    
    # Search all sources (similar to how Stremio aggregates)
    # Collect results into array using process substitution
    {
        search_yts "$query" 2>/dev/null
        search_tpb "$query" 2>/dev/null
        search_eztv "$query" 2>/dev/null
        search_1337x "$query" 2>/dev/null
    } | while IFS= read -r line || [ -n "$line" ]; do
        if [ -n "$line" ] && [[ "$line" =~ \| ]]; then
            all_results+=("$line")
        fi
    done
    
    # Note: Due to pipe creating subshell, we need to use a different approach
    # Let's use a temp file instead and run searches in parallel with timeouts
    local temp_file=$(mktemp 2>/dev/null || echo "/tmp/torrent_$$")
    local search_pids=()
    
    # Run all searches in parallel (each has its own timeout via curl --max-time)
    (search_yts "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_ytsrs "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_tpb "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_eztv "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_1337x "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    
    # Wait for all searches to complete (max 10 seconds total)
    local wait_count=0
    while [ $wait_count -lt 20 ]; do
        local all_done=true
        for pid in "${search_pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                all_done=false
                break
            fi
        done
        if [ "$all_done" = true ]; then
            break
        fi
        sleep 0.5
        wait_count=$((wait_count + 1))
    done
    
    # Kill any remaining processes after timeout
    for pid in "${search_pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
    done
    wait "${search_pids[@]}" 2>/dev/null || true
    
    # Read results from temp file
    if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip empty lines and lines without pipe separator
            if [ -n "$line" ] && echo "$line" | grep -q '|'; then
                # Remove any trailing whitespace
                line=$(echo "$line" | sed 's/[[:space:]]*$//')
                all_results+=("$line")
            fi
        done < "$temp_file"
    fi
    
    rm -f "$temp_file" 2>/dev/null
    
    rm -f "$temp_file" 2>/dev/null
    
    # Group results
    local grouped_results=()
    if [ ${#all_results[@]} -gt 0 ]; then
        local group_input=$(mktemp)
        printf "%s\n" "${all_results[@]}" > "$group_input"
        local group_output=$(cat "$group_input" | group_results)
        if [ -n "$group_output" ]; then
             while IFS= read -r line || [ -n "$line" ]; do
                 grouped_results+=("$line")
             done <<< "$group_output"
             all_results=("${grouped_results[@]}")
        fi
        rm -f "$group_input"
    fi
    
    # Remove duplicates (fallback)
    if [ ${#all_results[@]} -gt 0 ]; then
        local unique_results=()
        local seen_hashes=()
        for result in "${all_results[@]}"; do
            IFS='|' read -r source name magnet quality size extra <<< "$result"
            # Extract hash from magnet link
            local hash=$(echo "$magnet" | grep -oE 'btih:[a-fA-F0-9]+' | cut -d: -f2 | tr '[:upper:]' '[:lower:]')
            if [ -n "$hash" ]; then
                # Check if we've seen this hash before
                local seen=false
                for seen_hash in "${seen_hashes[@]}"; do
                    if [ "$hash" = "$seen_hash" ]; then
                        seen=true
                        break
                    fi
                done
                if [ "$seen" = false ]; then
                    unique_results+=("$result")
                    seen_hashes+=("$hash")
                fi
            else
                # If no hash, just add it (shouldn't happen but be safe)
                unique_results+=("$result")
            fi
        done
        all_results=("${unique_results[@]}")
    fi
    
    if [ ${#all_results[@]} -eq 0 ]; then
        echo -e "${RED}No results found${RESET}"
        echo
        echo "Try:"
        echo "  - Check your internet connection"
        if [[ "$OSTYPE" == "darwin"* ]]; then
            echo "  - Install jq: ${CYAN}brew install jq${RESET}"
            echo "  - Install python3: ${CYAN}brew install python3${RESET} (for YTSRS search)"
        else
            echo "  - Install jq: ${CYAN}sudo apt-get install jq${RESET} (Debian/Ubuntu) or ${CYAN}sudo yum install jq${RESET} (RHEL/CentOS)"
            echo "  - Install python3: ${CYAN}sudo apt-get install python3${RESET} (Debian/Ubuntu) or ${CYAN}sudo yum install python3${RESET} (RHEL/CentOS)"
        fi
        echo "  - Try a different search query"
        echo "  - The search APIs may be temporarily unavailable"
        return 1
    fi
    
    # Display results
    echo -e "${BOLD}${GREEN}Found ${#all_results[@]} results:${RESET}\n"
    
    local index=0
    for result in "${all_results[@]}"; do
        if [ -z "$result" ]; then
            continue
        fi
        
        IFS='|' read -r source name magnet quality size <<< "$result"
        
        if [ -z "$name" ] || [ -z "$magnet" ]; then
            continue
        fi
        
        index=$((index + 1))
        
        local source_color="$CYAN"
        case "$source" in
            YTS) source_color="$GREEN" ;;
            TPB) source_color="$YELLOW" ;;
            EZTV) source_color="$BLUE" ;;
            1337x) source_color="$MAGENTA" ;;
        esac
        
        echo -e "${BOLD}[$index]${RESET} ${source_color}[$source]${RESET} ${BOLD}$name${RESET}"
        if [ "$quality" != "N/A" ] && [ -n "$quality" ] && [ "$quality" != "" ]; then
            echo -e "     Quality: $quality | Size: $size"
        fi
        echo -e "     ${CYAN}$magnet${RESET}"
        echo
    done
    
    # Interactive selection
    if [ -t 0 ]; then
        echo -e "${YELLOW}Select a torrent (1-$index) or press Enter to cancel:${RESET} "
        read -r selection
        
        if [ -n "$selection" ] && [ "$selection" -ge 1 ] && [ "$selection" -le "$index" ] 2>/dev/null; then
            local selected_result="${all_results[$((selection - 1))]}"

            IFS='|' read -r source name magnet quality size extra poster <<< "$selected_result"
            
            # Check if item is COMBINED
            if [[ "$source" == "COMBINED" ]]; then
                # Parse output from group_results
                # Format: COMBINED|Name|Sources|Seeds|Qualities|Sizes|Magnets|Poster
                IFS='|' read -r _ c_name c_sources c_seeds c_qualities c_sizes c_magnets _ <<< "$selected_result"
                
                local sources_arr=() 
                local seeds_arr=()
                local qualities_arr=()
                local sizes_arr=()
                local magnets_arr=()
                
                IFS='^' read -ra sources_arr <<< "$c_sources"
                IFS='^' read -ra seeds_arr <<< "$c_seeds"
                IFS='^' read -ra qualities_arr <<< "$c_qualities"
                IFS='^' read -ra sizes_arr <<< "$c_sizes"
                IFS='^' read -ra magnets_arr <<< "$c_magnets"
                
                echo -e "\n${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo -e "${CYAN}Multiple versions found for:${RESET} ${BOLD}${YELLOW}$c_name${RESET}"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}\n"
                
                local selected_idx=0
                
                if command -v gum &> /dev/null; then
                     echo -e "${GREEN}Select a version:${RESET}"
                     # Create a numbered list for gum
                     local gum_opts=()
                     for i in "${!sources_arr[@]}"; do
                         local src="${sources_arr[$i]}"
                         local qty="${qualities_arr[$i]}"
                         local sz="${sizes_arr[$i]}"
                         local sd="${seeds_arr[$i]}"
                         gum_opts+=("$((i+1)). [${src}] ${qty} - ${sz} (${sd} seeds)")
                     done
                     local choice=$(printf "%s\n" "${gum_opts[@]}" | gum choose --height=10 --cursor="➤ " --header="Available Versions" --header.foreground="212")
                     
                     if [ -n "$choice" ]; then
                         # Extract number from choice (format: "1. ...")
                         local choice_num=$(echo "$choice" | grep -oE '^([0-9]+)' | head -1)
                         if [ -n "$choice_num" ] && [ "$choice_num" -ge 1 ] && [ "$choice_num" -le "${#sources_arr[@]}" ]; then
                             selected_idx=$((choice_num - 1))
                         else
                             return 1
                         fi
                     else
                         return 1
                     fi
                else
                    echo -e "${GREEN}Available versions:${RESET}"
                    for i in "${!sources_arr[@]}"; do
                        local src="${sources_arr[$i]}"
                        local qty="${qualities_arr[$i]}"
                        local sz="${sizes_arr[$i]}"
                        local sd="${seeds_arr[$i]}"
                        
                        # Color code sources
                        local src_color=""
                        case "$src" in
                            YTS) src_color="${GREEN}" ;;
                            TPB) src_color="${YELLOW}" ;;
                            EZTV) src_color="${BLUE}" ;;
                            1337x) src_color="${MAGENTA}" ;;
                            *) src_color="${CYAN}" ;;
                        esac
                        
                        echo -e "  ${BOLD}$((i+1)))${RESET} ${src_color}[${src}]${RESET} ${CYAN}${qty}${RESET} - ${sz} (${YELLOW}${sd}${RESET} seeds)"
                    done
                    echo
                    read -p "Enter choice [1-${#sources_arr[@]}]: " choice_num
                    if [[ "$choice_num" =~ ^[0-9]+$ ]] && [ "$choice_num" -ge 1 ] && [ "$choice_num" -le "${#sources_arr[@]}" ]; then
                        selected_idx=$((choice_num - 1))
                    else
                        return 1
                    fi
                fi
                
                source="${sources_arr[$selected_idx]}"
                magnet="${magnets_arr[$selected_idx]}"
                quality="${qualities_arr[$selected_idx]}"
                size="${sizes_arr[$selected_idx]}"
                name="$c_name"
                
                echo -e "${GREEN}Selected:${RESET} $source $quality - $size"
            fi
            
            # Validate magnet link
            magnet=$(echo "$magnet" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [ -z "$magnet" ] || [[ ! "$magnet" =~ ^magnet: ]]; then
                echo -e "${RED}Error:${RESET} Invalid or missing magnet link for selected torrent"
                echo -e "${YELLOW}Debug info:${RESET}"
                echo "  Source: $source"
                echo "  Name: $name"
                echo "  Magnet: '$magnet'"
                exit 1
            fi
            
            # Debug output
            if [ "$TORRENT_DEBUG" = true ]; then
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo -e "${CYAN}DEBUG MODE${RESET}"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo -e "${YELLOW}Selected torrent:${RESET}"
                echo "  Index: $selection"
                echo "  Source: $source"
                echo "  Name: $name"
                echo "  Quality: $quality"
                echo "  Size: $size"
                echo -e "${YELLOW}Magnet link:${RESET}"
                echo "  $magnet"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
                echo
            fi
            
            echo
            echo -e "${GREEN}Streaming:${RESET} $name"
            echo
            
            # Ensure dependencies are checked before streaming
            if [ -z "$TORRENT_TOOL" ]; then
                check_deps
            fi
            
            # Stream the selected torrent (subtitles auto-detected)
            stream_torrent "$magnet" "" false false
            local exit_code=$?
            
            # Exit code 2 means player closed normally - just return (search results don't have pagination to return to)
            if [ $exit_code -eq 2 ]; then
                # Player closed, just return
                return 0
            elif [ $exit_code -ne 0 ]; then
                # Other error occurred
                echo
                echo -e "${YELLOW}Playback failed.${RESET}"
                echo -e "${YELLOW}Would you like to search for alternative versions of \"$name\"? (y/n)${RESET} "
                read -r answer
                if [[ "$answer" =~ ^[Yy]$ ]]; then
                    # Clean up name for search
                    local search_query=$(echo "$name" | tr '.' ' ')
                    search_query=$(echo "$search_query" | sed -E 's/ (1080p|720p|4k|2160p|WEB-DL|BluRay|HDRip|x265|HEVC).*//i')
                    search_query=$(echo "$search_query" | sed -E 's/ \([0-9]{4}\)//')
                    
                    echo -e "${CYAN}Searching for: $search_query${RESET}"
                    search_torrent "$search_query"
                fi
            fi
        else
            echo "Cancelled."
        fi
    else
        echo -e "${YELLOW}Non-interactive mode. Use:${RESET}"
        echo "  torrent \"<magnet_link>\""
    fi
}

# Global debug flag
TORRENT_DEBUG=false

# Main function
main() {
    local source=""
    local index=""
    local list_only=false
    local search_mode=false
    local auto_quality=false
    local enable_subtitles=false
    local args=("$@")
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -l|--list)
                list_only=true
                shift
                ;;
            -i|--index)
                index="$2"
                shift 2
                ;;
            -q|--quality)
                auto_quality=true
                shift
                ;;
            -s|--subtitles)
                enable_subtitles=true
                shift
                ;;
            -v|--verbose)
                set -x
                shift
                ;;
            --debug)
                TORRENT_DEBUG=true
                export TORRENT_DEBUG
                shift
                ;;
            --clear)
                local cache_dir="$HOME/.config/termflix/cache"
                if [ -d "$cache_dir" ]; then
                    local deleted_count=$(find "$cache_dir" -name "catalog_*.txt" -type f | wc -l | tr -d ' ')
                    rm -rf "$cache_dir"/catalog_*.txt 2>/dev/null
                    if [ "$deleted_count" -gt 0 ]; then
                        echo -e "${GREEN}✓ Cleared ${deleted_count} cache file(s)${RESET}"
                    else
                        echo -e "${YELLOW}No cache files found to clear${RESET}"
                    fi
                else
                    echo -e "${YELLOW}Cache directory does not exist${RESET}"
                fi
                exit 0
                ;;
            player)
                # Change player preference
                if [ -z "$2" ]; then
                    echo -e "${RED}Error:${RESET} Please specify a player (mpv or vlc)"
                    echo "Usage: termflix player <mpv|vlc>"
                    exit 1
                fi
                local new_player="$2"
                if [[ "$new_player" =~ ^(mpv|vlc)$ ]]; then
                    init_termflix_dirs
                    local config_file=$(get_termflix_config_file)
                    echo "PLAYER=$new_player" > "$config_file"
                    echo -e "${GREEN}Player preference changed to:${RESET} $new_player"
                    echo -e "${CYAN}Config saved to:${RESET} $config_file"
                    exit 0
                else
                    echo -e "${RED}Error:${RESET} Invalid player. Use 'mpv' or 'vlc'"
                    exit 1
                fi
                ;;
            search)
                search_mode=true
                shift
                ;;
            *)
                if [ -z "$source" ]; then
                    source="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Wrapper functions for YTSRS (defined before use)
    get_ytsrs_latest_wrapper() {
        get_ytsrs_movies "" "1080p" "year" "$1" "$2"
    }
    get_ytsrs_trending_wrapper() {
        get_ytsrs_movies "" "1080p" "seeds" "$1" "$2"
    }
    get_ytsrs_popular_wrapper() {
        get_ytsrs_movies "" "1080p" "rating" "$1" "$2"
    }
    get_ytsrs_genre_wrapper() {
        local genre="$1"
        shift
        get_ytsrs_movies "$genre" "1080p" "seeds" "$1" "$2"
    }
    
    # Filter args for routing (remove --debug)
    local routing_args=()
    for arg in "${args[@]}"; do
        [[ "$arg" != "--debug" ]] && routing_args+=("$arg")
    done
    
    # Handle catalog modes FIRST (doesn't need streaming tool)
    case "${routing_args[0]}" in
        latest)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # Show results from both TPB and YTSRS
                    display_catalog "🎬 Latest Movies" get_latest_movies 25 get_ytsrs_latest_wrapper 25
                    ;;
                shows)
                    display_catalog "📺 Latest TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "🎬 Latest Movies & Shows" get_latest_movies 15 get_ytsrs_latest_wrapper 15 get_latest_shows 20
                    ;;
            esac
            exit $?
            ;;
        trending)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # Show results from both TPB and YTSRS
                    display_catalog "🔥 Trending Movies" get_trending_movies 25 get_ytsrs_trending_wrapper 25
                    ;;
                shows)
                    display_catalog "🔥 Trending TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "🔥 Trending Content" get_trending_movies 15 get_ytsrs_trending_wrapper 15 get_latest_shows 20
                    ;;
            esac
            exit $?
            ;;
        popular)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # Show results from both TPB and YTSRS
                    display_catalog "⭐ Popular Movies" get_popular_movies 25 get_ytsrs_popular_wrapper 25
                    ;;
                shows)
                    display_catalog "⭐ Popular TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "⭐ Popular Content" get_popular_movies 15 get_ytsrs_popular_wrapper 15 get_latest_shows 20
                    ;;
            esac
            exit $?
            ;;
        catalog)
            check_jq
            local genre="${routing_args[1]:-}"
            if [ -z "$genre" ]; then
                echo -e "${BOLD}Available Genres:${RESET}"
                echo "  action, adventure, animation, comedy, crime, documentary,"
                echo "  drama, family, fantasy, horror, mystery, romance,"
                echo "  sci-fi, thriller, war, western"
                echo
                echo "Usage: torrent catalog <genre>"
                exit 1
            fi
            # Show results from both YTS/TPB and YTSRS
            # Create genre-specific wrapper
            eval "get_ytsrs_${genre}_wrapper() {
                get_ytsrs_movies \"$genre\" \"1080p\" \"seeds\" \"\$1\" \"\$2\"
            }"
            display_catalog "📚 $genre Movies" get_catalog_by_genre "$genre" 25 "get_ytsrs_${genre}_wrapper" 25
            exit $?
            ;;
        search)
            check_jq
            local query="${routing_args[1]:-}"
            if [ -z "$query" ]; then
                echo -e "${RED}Error:${RESET} Please provide a search query"
                echo "Usage: termflix search <query>"
                exit 1
            fi
            search_torrent "$query"
            exit $?
            ;;
    esac
    
    # If we get here and no source, default to "latest all"
    if [ -z "$source" ] && [ "$list_only" = false ] && [ "$search_mode" = false ]; then
        # Default behavior: show latest movies and shows
        check_jq
        display_catalog "🎬 Latest Movies & Shows" get_latest_movies 15 get_ytsrs_latest_wrapper 15 get_latest_shows 20
        exit $?
    fi
    
    # Check dependencies for streaming (only needed when actually streaming)
    check_deps
    check_jq
    
    # Get source from clipboard if not provided
    if [ -z "$source" ]; then
        if command -v pbpaste &> /dev/null; then
            # BSD grep compatible (no -P flag)
            source=$(pbpaste | grep -oE 'magnet:\?[^[:space:]]+' | head -1)
            if [ -n "$source" ]; then
                echo -e "${GREEN}Using magnet link from clipboard${RESET}"
            fi
        fi
        
        if [ -z "$source" ]; then
            echo -e "${RED}Error:${RESET} No magnet link or torrent file provided"
            echo "Usage: termflix <magnet_link|torrent_file>"
            echo "   or: termflix --help"
            exit 1
        fi
    fi
    
    # Handle auto-quality selection
    if [ "$auto_quality" = true ] && [ -z "$index" ]; then
        index=$(select_best_quality "$source")
    fi
    
    # Stream the torrent
    stream_torrent "$source" "$index" "$list_only" "$enable_subtitles"
}

# Run main function
# Run main function if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
