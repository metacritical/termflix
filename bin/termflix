#!/usr/bin/env bash
#
# Termflix - Torrent Streaming Tool - Stream torrents directly to mpv/vlc
# Usage: termflix [command] or termflix <magnet_link|torrent_file>
#

# Don't exit on error - we handle errors gracefully
set +e
# Suppress job control messages (like "Terminated: 15")
set +H 2>/dev/null || true

# Cleanup function for poster images
cleanup_on_exit() {
    cleanup_posters
}
trap cleanup_on_exit EXIT INT TERM

# Spinner function for waiting/searching
show_spinner() {
    local pid=$1
    local message="${2:-Processing...}"
    local spinstr='|/-\'
    local delay=0.1
    while kill -0 "$pid" 2>/dev/null; do
        local temp=${spinstr#?}
        printf "\r${CYAN}%s${RESET} [%c]" "$message" "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
    done
    printf "\r${GREEN}%s${RESET} [‚úì]\n" "$message"
}

# Progress bar with emojis
show_progress() {
    local current=$1
    local total=$2
    local label="${3:-Progress}"
    local width=20
    
    # Ensure current doesn't exceed total
    if [ "$current" -gt "$total" ]; then
        current=$total
    fi
    
    local filled=$((current * width / total))
    if [ "$filled" -gt "$width" ]; then
        filled=$width
    fi
    local empty=$((width - filled))
    
    # Build progress bar
    local bar=""
    local i=0
    while [ $i -lt $filled ]; do
        bar="${bar}üü©"
        i=$((i + 1))
    done
    while [ $i -lt $width ]; do
        bar="${bar}‚¨ú"
        i=$((i + 1))
    done
    
    local percent=$((current * 100 / total))
    if [ "$percent" -gt 100 ]; then
        percent=100
    fi
    printf "\r${CYAN}%s:${RESET} %s %d%% (%d/%d) " "$label" "$bar" "$percent" "$current" "$total"
}

# Check for jq (needed for API parsing)
check_jq() {
    if ! command -v jq &> /dev/null; then
        echo -e "${YELLOW}Warning:${RESET} jq not found. Some search features may be limited."
        echo "Install with: ${CYAN}brew install jq${RESET}"
        echo
    fi
}

# Check for viu (optional, for displaying images on Mac)
check_viu() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        if ! command -v viu &> /dev/null; then
            echo -e "${YELLOW}Note:${RESET} viu not found. Movie posters will not be displayed."
            echo "Install with: ${CYAN}brew install viu${RESET} or ${CYAN}cargo install viu${RESET}"
            echo
            return 1
        fi
        return 0
    fi
    return 1
}

# Download and display poster image
display_poster() {
    local poster_source="$1"  # Can be a URL or a cached file path
    local width="${2:-20}"
    local height="${3:-15}"
    local x_pos="${4:-}"
    local y_pos="${5:-}"
    
    if [ -z "$poster_source" ] || [ "$poster_source" = "N/A" ] || [ "$poster_source" = "" ]; then
        return 1
    fi
    
    local image_file=""
    
    # Check if it's already a cached file path
    if [ -f "$poster_source" ]; then
        image_file="$poster_source"
    else
        # It's a URL, download it to temp directory
        local temp_dir="${TMPDIR:-/tmp}/torrent_posters_$$"
        mkdir -p "$temp_dir" 2>/dev/null || return 1
        
        image_file="${temp_dir}/poster_$(echo "$poster_source" | md5 2>/dev/null | cut -c1-8).jpg"
        
        if [ ! -f "$image_file" ]; then
            curl -s --max-time 5 "$poster_source" -o "$image_file" 2>/dev/null || return 1
        fi
    fi
    
    if [ ! -f "$image_file" ] || [ ! -s "$image_file" ]; then
        return 1
    fi

    # Check for Kitty terminal
    if [[ "$TERM" == "xterm-kitty" ]] && command -v kitty &> /dev/null; then
        if [ -n "$x_pos" ] && [ -n "$y_pos" ]; then
            # Move cursor to position first
            tput cup "$y_pos" "$x_pos"
            kitty +kitten icat --align left --place "${width}x${height}@${x_pos}x${y_pos}" "$image_file" 2>/dev/null
        else
            kitty +kitten icat --align left --height "$height" "$image_file" 2>/dev/null
        fi
        return 0
    fi
    
    # Check if viu is available
    if check_viu >/dev/null 2>&1; then
        if [ -n "$x_pos" ] && [ -n "$y_pos" ]; then
            # Move cursor to position
            tput cup "$y_pos" "$x_pos"
            viu -w "$width" -h "$height" "$image_file" 2>/dev/null
        else
            viu -w "$width" -h "$height" "$image_file" 2>/dev/null
        fi
        return 0
    fi
    
    return 1
}

# Draw a row of up to 3 items in a grid
# Offline rendering: Pre-render images, then draw row-by-row with proper cursor positioning
draw_grid_row() {
    local start_row="$1"
    local start_index="$2"
    local num_cols="$3"
    shift 3
    local items=("$@")
    
    local col_width=40  # Approximate column width in characters
    local img_width=20
    local img_height=15
    local row_height=20  # Total height for one row (image + text)
    
    # Calculate column positions based on terminal width
    # Ensure proper spacing: each column needs at least img_width + padding
    local term_cols=$(tput cols)
    # Calculate spacing to evenly distribute columns with proper padding
    # Each column needs ~40 chars (20 for image + 20 for text), but we'll use dynamic spacing
    local total_cols_needed=$((num_cols * 40))
    local spacing
    if [ "$total_cols_needed" -le "$term_cols" ]; then
        # We have enough space, use even distribution
        spacing=$((term_cols / num_cols))
    else
        # Not enough space, use minimum spacing
        spacing=40
    fi
    local col_positions=()
    for ((c=0; c<num_cols; c++)); do
        col_positions+=($((c * spacing)))
    done

    # Pass 1: Pre-download all images in parallel
    local temp_dir="${TMPDIR:-/tmp}/torrent_posters_$$"
    mkdir -p "$temp_dir" 2>/dev/null
    
    local pids=()
    local image_files=()
    
    for i in "${!items[@]}"; do
        local result="${items[$i]}"
        IFS='|' read -r source name magnet quality size extra poster_url <<< "$result"
        
        if [[ -n "$poster_url" ]] && [[ "$poster_url" != "N/A" ]]; then
            # Check if it's already a cached file path
            if [ -f "$poster_url" ]; then
                # It's a file path, use it directly
                image_files[$i]="$poster_url"
            else
                # It's a URL, download it
                local image_file="${temp_dir}/poster_$(echo "$poster_url" | md5 2>/dev/null | cut -c1-8).jpg"
                image_files[$i]="$image_file"
                
                # Download in background if not already cached
                if [ ! -f "$image_file" ]; then
                    ( curl -s --max-time 5 "$poster_url" -o "$image_file" 2>/dev/null ) &
                    pids+=($!)
                fi
            fi
        else
            image_files[$i]=""
        fi
    done
    
    # Wait for all downloads to complete
    for pid in "${pids[@]}"; do
        wait "$pid" 2>/dev/null
    done
    
    # Pass 2: Pre-render all images offline - capture each line separately
    # Store rendered lines: image_lines[item_index][row_index] = line_content
    declare -a has_image=()
    declare -a is_kitty=()
    # Use associative array-like structure with temp files for each item's lines
    local image_line_files=()
    
    for i in "${!items[@]}"; do
        local image_file="${image_files[$i]}"
        has_image[$i]=0
        is_kitty[$i]=0
        image_line_files[$i]=""
        
        if [[ -n "$image_file" ]] && [[ -f "$image_file" ]]; then
            # Check if we're using kitty (which handles positioning differently)
            if [[ "$TERM" == "xterm-kitty" ]] && command -v kitty &> /dev/null; then
                is_kitty[$i]=1
                has_image[$i]=1
            elif check_viu >/dev/null 2>&1; then
                # Pre-render image with viu and capture output line by line
                local rendered_file="${temp_dir}/rendered_${i}.txt"
                viu -w "$img_width" -h "$img_height" "$image_file" 2>/dev/null > "$rendered_file"
                if [ $? -eq 0 ] && [ -s "$rendered_file" ]; then
                    image_line_files[$i]="$rendered_file"
                    has_image[$i]=1
                else
                    rm -f "$rendered_file" 2>/dev/null
                fi
            fi
        fi
    done
    
    # Pass 3: Draw images row by row (offline rendering)
    # For each row (0 to img_height-1), draw that row for all columns
    for ((row=0; row<img_height; row++)); do
        for i in "${!items[@]}"; do
            local x_pos="${col_positions[$i]}"
            local current_y=$((start_row + row + 1))
            
            if [[ "${has_image[$i]}" -eq 1 ]]; then
                if [[ "${is_kitty[$i]}" -eq 1 ]]; then
                    # For kitty, render once on first row only
                    if [[ "$row" -eq 0 ]]; then
                        local image_file="${image_files[$i]}"
                        kitty +kitten icat --align left --place "${img_width}x${img_height}@${x_pos}x$((start_row + 1))" "$image_file" 2>/dev/null
                    fi
                else
                    # For viu: Read specific row from pre-rendered file and draw at correct position
                    local rendered_file="${image_line_files[$i]}"
                    if [[ -n "$rendered_file" ]] && [[ -f "$rendered_file" ]]; then
                        # Move cursor to exact position for this row and column
                        tput cup "$current_y" "$x_pos"
                        # Read and output the specific line (row+1 because sed line numbers start at 1)
                        local image_line
                        image_line=$(sed -n "$((row + 1))p" "$rendered_file" 2>/dev/null)
                        if [[ -n "$image_line" ]]; then
                            # Remove trailing newline
                            local clean_line="${image_line%$'\n'}"
                            # Output the line - viu should already respect width
                            printf "%s" "$clean_line"
                            # Position cursor at end of image area (x_pos + img_width) to prevent overwrite
                            # This ensures next column starts at correct position
                            local end_x=$((x_pos + img_width))
                            local term_cols=$(tput cols)
                            if [ "$end_x" -gt "$term_cols" ]; then
                                end_x=$term_cols
                            fi
                            tput cup "$current_y" "$end_x"
                        fi
                    fi
                fi
            else
                # Draw placeholder box row by row
                local image_file="${image_files[$i]}"
                if [[ -z "$image_file" ]] || [[ ! -f "$image_file" ]]; then
                    tput cup "$current_y" "$x_pos"
                    if [[ "$row" -eq 0 ]]; then
                        echo -ne "${CYAN}‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê${RESET}"
                    elif [[ "$row" -eq $((img_height-1)) ]]; then
                        echo -ne "${CYAN}‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò${RESET}"
                    elif [[ "$row" -eq 7 ]]; then
                        # Center row - show "No Poster" text
                        echo -ne "${CYAN}‚îÇ${RESET}"
                        tput cup "$current_y" $((x_pos + 5))
                        echo -ne "${CYAN}No Poster${RESET}"
                        tput cup "$current_y" $((x_pos + 19))
                        echo -ne "${CYAN}‚îÇ${RESET}"
                    else
                        echo -ne "${CYAN}‚îÇ                  ‚îÇ${RESET}"
                    fi
                    # Ensure cursor is positioned after placeholder
                    tput cup "$current_y" $((x_pos + 20))
                fi
            fi
        done
        # CRITICAL: After drawing each image row, don't move cursor - let it stay at end of row
        # We'll position it correctly before drawing text
    done
    
    # CRITICAL: After drawing all images, ensure cursor is positioned correctly
    # Images occupy rows: start_row+1 to start_row+img_height (15 lines)
    # Text should start at: start_row + img_height + 1
    # Don't move cursor here - we'll position it per-item when drawing text
    
    # Pass 4: Draw all text below images
    # Calculate text starting row (below images with 1 line spacing for compact layout)
    # Images are drawn from start_row+1 to start_row+img_height (15 lines)
    # Add 1 line spacing, so text starts at start_row + 16
    # CRITICAL: text_row must always be relative to start_row, not adjusted by scrolling
    local text_row=$((start_row + img_height + 1))
    local term_cols=$(tput cols)
    local term_lines_check=$(tput lines)
    
    # CRITICAL: Ensure text_row is within terminal bounds
    if [ "$text_row" -ge "$term_lines_check" ] || [ "$text_row" -lt 1 ]; then
        # If text row is beyond terminal, adjust it
        text_row=$((term_lines_check - 5))
        if [ "$text_row" -lt 1 ]; then
            text_row=1
        fi
    fi
    
    # CRITICAL: Ensure text_row is at least below the image area
    local image_end_row=$((start_row + img_height))
    if [ "$text_row" -le "$image_end_row" ]; then
        text_row=$((image_end_row + 1))
    fi
    
    # Draw text for each item completely before moving to next
    # This prevents overwrites from cursor positioning
    for i in "${!items[@]}"; do
        local item="${items[$i]}"
        local x_pos="${col_positions[$i]}"
        IFS='|' read -r source name magnet quality size extra poster_url <<< "$item"
        
        local item_num=$((start_index + i + 1))
        local source_color="$CYAN"
        case "$source" in
            YTS) source_color="$GREEN" ;;
            TPB) source_color="$YELLOW" ;;
            EZTV) source_color="$BLUE" ;;
            1337x) source_color="$MAGENTA" ;;
        esac
        
        local display_name="${name:0:38}"
        if [ "${#name}" -gt 38 ]; then
            display_name="${display_name}..."
        fi
        
        # Calculate available width for this column (needed for both row 2 and row 3)
        local next_x
        if [ "$i" -lt $((${#items[@]} - 1)) ]; then
            next_x="${col_positions[$((i + 1))]}"
        else
            next_x=$term_cols
        fi
        local col_width=$((next_x - x_pos - 1))  # Leave 1 char margin
        if [ "$col_width" -gt 35 ]; then col_width=35; fi
        if [ "$col_width" -lt 20 ]; then col_width=20; fi
        
        # Write all three lines of text for this item at once
        # CRITICAL: Calculate text_row relative to start_row (where images were drawn)
        # Images are drawn from start_row+1 to start_row+img_height (15 lines)
        # Text should start at start_row + img_height + 1 (row 16 from start_row)
        local image_end_row=$((start_row + img_height))
        local actual_text_row=$((image_end_row + 1))
        
        # CRITICAL: Ensure text_row is below image area first
        if [ "$actual_text_row" -le "$image_end_row" ]; then
            actual_text_row=$((image_end_row + 1))
        fi
        
        # CRITICAL: Then check if it's within terminal bounds
        # If beyond terminal, we still need to draw it, but it might scroll
        # Don't skip drawing - let the terminal handle scrolling
        if [ "$actual_text_row" -lt 1 ]; then
            actual_text_row=1
        fi
        
        # CRITICAL: Clear each line before writing to prevent overlap
        # Row 1: [num] [source]
        # Calculate clear end position
        local clear_end
        if [ "$i" -lt $((${#items[@]} - 1)) ]; then
            clear_end="${col_positions[$((i + 1))]}"
        else
            clear_end=$term_cols
        fi
        
        # Ensure we're writing below images
        # Draw text even if it's beyond visible terminal - terminal will scroll
        if [ "$actual_text_row" -ge 1 ]; then
            tput cup "$actual_text_row" "$x_pos"
            # Clear to end of column
            printf "%*s" $((clear_end - x_pos)) ""
            tput cup "$actual_text_row" "$x_pos"
            echo -ne "${BOLD}[${item_num}]${RESET} ${source_color}[${source}]${RESET}"
        fi
        
        # Row 2: Movie name (truncate to fit column width)
        local text_row_2=$((actual_text_row + 1))
        local truncated_name="${display_name:0:$col_width}"
        if [ "${#display_name}" -gt "$col_width" ]; then
            truncated_name="${truncated_name}..."
        fi
        
        if [ "$text_row_2" -ge 1 ]; then
            tput cup "$text_row_2" "$x_pos"
            # Clear to end of column
            printf "%*s" $((clear_end - x_pos)) ""
            tput cup "$text_row_2" "$x_pos"
            echo -ne "${BOLD}${truncated_name}${RESET}"
        fi
        
        # Row 3: Quality, size, seeds, and IMDB rating
        # Parse seeds from extra field (format: "1234 seeds" or "1234 seeds, 567 peers")
        # CRITICAL: Strip ANSI codes first before parsing
        local clean_extra=$(echo -n "$extra" | sed 's/\x1b\[[0-9;]*m//g')
        local seeds=""
        if [[ "$clean_extra" =~ ([0-9]+)[[:space:]]*seeds ]]; then
            seeds="${BASH_REMATCH[1]}"
        fi
        
        # Get IMDB rating from TMDB API (cache it)
        local imdb_rating=""
        local rating_stars=""
        if [ -n "$name" ]; then
            # Extract year from name if available
            local year=$(echo "$name" | grep -oE '[0-9]{4}' | head -1)
            local clean_title=$(echo "$name" | sed -E 's/\./ /g' | sed -E 's/ \([0-9]{4}\).*//' | sed 's/\[.*\]//g' | xargs)
            
            # Check cache for rating (using TMDB cache)
            local cache_dir=$(get_termflix_cache_dir)/tmdb
            local cache_key=$(echo "${clean_title}_${year}" | tr -cd '[:alnum:]')
            local cache_file="$cache_dir/${cache_key}.json"
            
            if [ -f "$cache_file" ]; then
                # Try to get rating from cached file
                imdb_rating=$(cat "$cache_file" 2>/dev/null | grep -o '"imdbRating":"[^"]*"' | cut -d'"' -f4)
                # If not found, try alternative JSON parsing
                if [ -z "$imdb_rating" ] || [ "$imdb_rating" == "N/A" ]; then
                    if command -v jq &> /dev/null; then
                        imdb_rating=$(cat "$cache_file" 2>/dev/null | jq -r '.imdbRating // empty' 2>/dev/null)
                    fi
                fi
            fi
            
            # Convert rating to stars (0-5 stars)
            if [ -n "$imdb_rating" ] && [ "$imdb_rating" != "N/A" ] && [ "$imdb_rating" != "" ] && [ "$imdb_rating" != "null" ]; then
                local rating_num=$(echo "$imdb_rating" | awk '{print int($1 + 0.5)}')
                if [ "$rating_num" -ge 9 ] && [ "$rating_num" -le 10 ]; then
                    rating_stars="‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê"
                elif [ "$rating_num" -ge 8 ] && [ "$rating_num" -lt 9 ]; then
                    rating_stars="‚≠ê‚≠ê‚≠ê‚≠ê"
                elif [ "$rating_num" -ge 7 ] && [ "$rating_num" -lt 8 ]; then
                    rating_stars="‚≠ê‚≠ê‚≠ê"
                elif [ "$rating_num" -ge 6 ] && [ "$rating_num" -lt 7 ]; then
                    rating_stars="‚≠ê‚≠ê"
                elif [ "$rating_num" -ge 5 ] && [ "$rating_num" -lt 6 ]; then
                    rating_stars="‚≠ê"
                fi
            fi
        fi
        
        # Build display text: quality | size | seeds | rating
        local display_parts=()
        if [ -n "$quality" ] && [ "$quality" != "N/A" ]; then
            display_parts+=("${CYAN}${quality}${RESET}")
        fi
        if [ -n "$size" ] && [ "$size" != "N/A" ]; then
            display_parts+=("${CYAN}${size}${RESET}")
        fi
        if [ -n "$seeds" ]; then
            display_parts+=("${YELLOW}${seeds} seeds${RESET}")
        fi
        if [ -n "$rating_stars" ]; then
            display_parts+=("${rating_stars}")
        fi
        
        # Join parts with " | "
        local display_text=""
        for part in "${display_parts[@]}"; do
            if [ -n "$display_text" ]; then
                display_text="${display_text} | "
            fi
            display_text="${display_text}${part}"
        done
        
        # Truncate if too long (remove ANSI codes for length calculation)
        local clean_text=$(echo -n "$display_text" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/‚≠ê//g')
        if [ "${#clean_text}" -gt "$col_width" ]; then
            # Truncate the clean text, then reconstruct (simplified - just show first part)
            local truncated_clean="${clean_text:0:$col_width}"
            display_text="${CYAN}${truncated_clean}${RESET}"
        fi
        
        # CRITICAL: Clear the line first to prevent overlap
        local text_row_3=$((actual_text_row + 2))
        if [ "$text_row_3" -ge 1 ]; then
            tput cup "$text_row_3" "$x_pos"
            # Clear to end of column (clear_end already calculated above)
            printf "%*s" $((clear_end - x_pos)) ""
            tput cup "$text_row_3" "$x_pos"
            echo -ne "$display_text"
            
            # After writing all text for this item, move cursor to end of its column area
            # This prevents overwrites when we write the next column
            tput cup "$text_row_3" $((clear_end - 1))
        fi
    done
    
    # Cleanup rendered files
    for rendered_file in "${image_line_files[@]}"; do
        [[ -n "$rendered_file" ]] && rm -f "$rendered_file" 2>/dev/null
    done
    
    # Calculate the next row position
    # Layout: start_row + img_height (15) + spacing (1) + text_lines (3) = start_row + 19
    # But we use row_height=20 for consistency with scrolling logic
    local next_row=$((start_row + row_height))
    
    # Ensure cursor is positioned at the next row before returning
    # This ensures the cursor is in a known state for the next row
    tput cup "$next_row" 0
    
    # Return the next row position via stderr (so it doesn't mix with stdout output)
    echo "$next_row" >&2
}

# Cleanup poster images
cleanup_posters() {
    local temp_dir="${TMPDIR:-/tmp}/torrent_posters_$$"
    rm -rf "$temp_dir" 2>/dev/null
}

# Termflix config directory
get_termflix_config_dir() {
    echo "$HOME/.config/termflix"
}

# Termflix config file
get_termflix_config_file() {
    echo "$(get_termflix_config_dir)/config"
}

# Termflix cache directory
get_termflix_cache_dir() {
    echo "$(get_termflix_config_dir)/cache"
}

# Initialize termflix directories
init_termflix_dirs() {
    local config_dir=$(get_termflix_config_dir)
    local cache_dir=$(get_termflix_cache_dir)
    mkdir -p "$config_dir" 2>/dev/null
    mkdir -p "$cache_dir" 2>/dev/null
    mkdir -p "$cache_dir/tmdb" 2>/dev/null
}

# Generate cache key from function names and arguments
generate_cache_key() {
    local args=("$@")
    local key_parts=()
    for arg in "${args[@]}"; do
        key_parts+=("$arg")
    done
    # Create a hash-like key from all arguments
    local key=$(printf '%s|' "${key_parts[@]}" | shasum -a 256 | cut -d' ' -f1)
    echo "$key"
}

# Check if cache is valid (less than 8 hours old)
is_cache_valid() {
    local cache_file="$1"
    if [ ! -f "$cache_file" ]; then
        return 1
    fi
    
    local cache_age=$(($(date +%s) - $(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null)))
    local max_age=$((8 * 60 * 60))  # 8 hours in seconds
    
    if [ "$cache_age" -lt "$max_age" ]; then
        return 0  # Cache is valid
    else
        return 1  # Cache is expired
    fi
}

# Get TMDB API Key
get_tmdb_api_key() {
    local config_file=$(get_termflix_config_file)
    
    if [ -f "$config_file" ]; then
        # Try specific TMDB_API_KEY first, then generic API_KEY
        local key=$(grep "^TMDB_API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        if [ -z "$key" ]; then
            key=$(grep "^API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        fi
        echo "$key"
    fi
}

# Get TMDB Read Access Token
get_tmdb_read_token() {
    local config_file=$(get_termflix_config_file)
    
    if [ -f "$config_file" ]; then
        local token=$(grep "^TMDB_READ_TOKEN=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        echo "$token"
    fi
}

# Get OMDB API Key (deprecated, kept for backward compatibility)
get_omdb_api_key() {
    local config_file=$(get_termflix_config_file)
    
    if [ -f "$config_file" ]; then
        # Try specific OMDB_API_KEY first, then generic API_KEY
        local key=$(grep "^OMDB_API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        if [ -z "$key" ]; then
            key=$(grep "^API_KEY=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        fi
        echo "$key"
    fi
}

# Fetch poster from TMDB (TheMovieDB) with caching
fetch_tmdb_poster() {
    local title="$1"
    local year="$2"
    
    if [ -z "$title" ]; then
        echo "N/A"
        return 1
    fi
    
    init_termflix_dirs
    
    # Clean title for cache key (remove special chars)
    local clean_title=$(echo "$title" | tr -cd '[:alnum:]')
    local cache_key="${clean_title}_${year}"
    local cache_dir=$(get_termflix_cache_dir)/tmdb
    local images_cache_dir="$cache_dir/images"
    local cache_file="$cache_dir/${cache_key}.json"
    local cached_image="$images_cache_dir/${cache_key}.jpg"
    
    mkdir -p "$cache_dir" 2>/dev/null
    mkdir -p "$images_cache_dir" 2>/dev/null
    
    # Check if we have a cached image file
    if [ -f "$cached_image" ]; then
        echo "$cached_image"
        return 0
    fi
    
    # Check cache for movie data
    local movie_id=""
    local poster_path=""
    
    if [ -f "$cache_file" ]; then
        # Extract movie_id and poster_path from cached JSON
        if command -v jq &> /dev/null; then
            movie_id=$(cat "$cache_file" | jq -r '.id // empty' 2>/dev/null)
            poster_path=$(cat "$cache_file" | jq -r '.poster_path // empty' 2>/dev/null)
        else
            movie_id=$(cat "$cache_file" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
            poster_path=$(cat "$cache_file" | grep -o '"poster_path":"[^"]*"' | cut -d'"' -f4)
        fi
        
        # If we have a cached poster_path but no image file, try to download it
        if [ -n "$poster_path" ] && [ "$poster_path" != "null" ] && [ "$poster_path" != "N/A" ] && [ -n "$movie_id" ]; then
            local image_url="https://image.tmdb.org/t/p/w500${poster_path}"
            if curl -s --max-time 5 "$image_url" -o "$cached_image" 2>/dev/null && [ -f "$cached_image" ] && [ -s "$cached_image" ]; then
                echo "$cached_image"
                return 0
            fi
        fi
    fi
    
    # Get API credentials
    local api_key=$(get_tmdb_api_key)
    local read_token=$(get_tmdb_read_token)
    
    if [ -z "$api_key" ]; then
        echo "N/A"
        return 1
    fi
    
    # Step 1: Search for movie to get movie_id
    local encoded_title
    if command -v jq &> /dev/null; then
        encoded_title=$(echo "$title" | jq -sRr @uri | tr -d '\r\n')
    else
        encoded_title=$(echo "$title" | sed 's/ /%20/g')
    fi
    
    local search_url="https://api.themoviedb.org/3/search/movie?api_key=${api_key}&query=${encoded_title}"
    if [ -n "$year" ]; then
        search_url="${search_url}&year=${year}"
    fi
    
    if ! command -v curl &> /dev/null; then
        echo "N/A"
        return 1
    fi
    
    local search_response=$(curl -s --max-time 5 "$search_url" 2>/dev/null)
    
    if [ -z "$search_response" ]; then
        echo "N/A"
        return 1
    fi
    
    # Extract movie_id from search results
    if [ -z "$movie_id" ]; then
        if command -v jq &> /dev/null; then
            movie_id=$(echo "$search_response" | jq -r '.results[0].id // empty' 2>/dev/null)
            poster_path=$(echo "$search_response" | jq -r '.results[0].poster_path // empty' 2>/dev/null)
        else
            movie_id=$(echo "$search_response" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
            poster_path=$(echo "$search_response" | grep -o '"poster_path":"[^"]*"' | head -1 | cut -d'"' -f4)
        fi
    fi
    
    if [ -z "$movie_id" ] || [ "$movie_id" = "null" ]; then
        # Cache the response even if no movie found
        echo "$search_response" > "$cache_file"
        echo "N/A"
        return 1
    fi
    
    # Step 2: Use images API to verify and get poster information
    local images_url="https://api.themoviedb.org/3/movie/${movie_id}/images"
    local images_response=""
    
    # Try with Bearer token first (more reliable)
    if [ -n "$read_token" ]; then
        images_response=$(curl -s --max-time 5 \
            --header "Authorization: Bearer ${read_token}" \
            --header "accept: application/json" \
            "$images_url" 2>/dev/null)
    fi
    
    # Fallback to API key if Bearer token didn't work or wasn't available
    if [ -z "$images_response" ] || echo "$images_response" | grep -q "Invalid\|Unauthorized\|401"; then
        images_url="${images_url}?api_key=${api_key}"
        images_response=$(curl -s --max-time 5 "$images_url" 2>/dev/null)
    fi
    
    # Extract poster_path from images API response (more reliable)
    if [ -n "$images_response" ]; then
        if command -v jq &> /dev/null; then
            # Get the first poster from the posters array
            poster_path=$(echo "$images_response" | jq -r '.posters[0].file_path // empty' 2>/dev/null)
            # If no poster in images API, try the original from search
            if [ -z "$poster_path" ] || [ "$poster_path" = "null" ]; then
                poster_path=$(echo "$search_response" | jq -r '.results[0].poster_path // empty' 2>/dev/null)
            fi
        else
            poster_path=$(echo "$images_response" | grep -o '"file_path":"[^"]*"' | head -1 | cut -d'"' -f4)
            if [ -z "$poster_path" ]; then
                poster_path=$(echo "$search_response" | grep -o '"poster_path":"[^"]*"' | head -1 | cut -d'"' -f4)
            fi
        fi
    fi
    
    # Save movie data to cache
    if command -v jq &> /dev/null; then
        echo "$search_response" | jq --arg id "$movie_id" --arg path "$poster_path" '.results[0] | .id = ($id | tonumber) | .poster_path = $path' > "$cache_file" 2>/dev/null || \
        echo "$search_response" | jq '.results[0] // {}' > "$cache_file" 2>/dev/null
    else
        echo "$search_response" > "$cache_file"
    fi
    
    # Step 3: Download and cache the image if we have a poster_path
    if [ -n "$poster_path" ] && [ "$poster_path" != "null" ] && [ "$poster_path" != "N/A" ]; then
        local image_url="https://image.tmdb.org/t/p/w500${poster_path}"
        
        # Download the image
        if curl -s --max-time 10 "$image_url" -o "$cached_image" 2>/dev/null && [ -f "$cached_image" ] && [ -s "$cached_image" ]; then
            # Verify it's actually an image file
            if file "$cached_image" 2>/dev/null | grep -q "image"; then
                echo "$cached_image"
                return 0
            else
                rm -f "$cached_image" 2>/dev/null
            fi
        fi
    fi
    
    echo "N/A"
    return 1
}

# Fetch poster from OMDB with caching (deprecated, now uses TMDB only)
fetch_omdb_poster() {
    # Use TMDB only (no OMDB fallback)
    fetch_tmdb_poster "$1" "$2"
}
export -f get_omdb_api_key get_tmdb_api_key get_tmdb_read_token fetch_omdb_poster fetch_tmdb_poster

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

# Get or set player preference
get_player_preference() {
    init_termflix_dirs
    local config_file=$(get_termflix_config_file)
    
    # Check if preference exists
    if [ -f "$config_file" ]; then
        local player=$(grep "^PLAYER=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d '[:space:]')
        if [ -n "$player" ] && [[ "$player" =~ ^(mpv|vlc)$ ]]; then
            echo "$player"
            return 0
        fi
    fi
    
    # Ask user for preference (first time) - check if /dev/tty is available
    # Don't check stdin (-t 0) as it may be consumed by previous reads
    if [ -c /dev/tty ] 2>/dev/null && [ -r /dev/tty ] 2>/dev/null; then
        # Use a timeout to prevent hanging - try to read with a timeout
        echo
        echo -e "${YELLOW}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo -e "${YELLOW}First time setup:${RESET} Which media player would you like to use?"
        echo -e "  ${GREEN}1${RESET}) mpv (recommended)"
        echo -e "  ${GREEN}2${RESET}) VLC"
        echo -ne "${YELLOW}Enter choice (1 or 2, default: 1):${RESET} "
        
        # Try to read with timeout (10 seconds) - if it fails, default to mpv
        # Use read -t which is built into bash and won't block forever
        local choice=""
        if ! read -t 10 -r choice < /dev/tty 2>/dev/null; then
            # Timeout or error - default to mpv
            choice="1"
            echo ""  # New line after timeout
        fi
        
        # Default to 1 if empty or invalid
        [ -z "$choice" ] && choice="1"
        
        local selected_player="mpv"
        case "$choice" in
            2) selected_player="vlc" ;;
            *) selected_player="mpv" ;;
        esac
        
        # Verify player is installed
        if ! command -v "$selected_player" &> /dev/null; then
            echo -e "${RED}Error:${RESET} $selected_player is not installed."
            echo "Please install it first: ${CYAN}brew install $selected_player${RESET}"
            echo "Defaulting to mpv..."
            selected_player="mpv"
        fi
        
        # Save preference
        echo "PLAYER=$selected_player" > "$config_file"
        echo -e "${GREEN}‚úì Preference saved to:${RESET} $config_file"
        echo -e "${CYAN}Note:${RESET} Edit this file to change your preference later."
        echo -e "${YELLOW}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo
        
        echo "$selected_player"
        return 0
    else
        # Non-interactive mode or no TTY, default to mpv
        echo "mpv"
        return 0
    fi
}

# Check dependencies
check_deps() {
    local missing=()
    
    # Check for peerflix (primary tool) or webtorrent (alternative)
    if command -v peerflix &> /dev/null; then
        TORRENT_TOOL="peerflix"
    elif command -v webtorrent &> /dev/null; then
        TORRENT_TOOL="webtorrent"
        echo -e "${YELLOW}Note:${RESET} Using webtorrent (peerflix not found)"
        echo "  For better compatibility, install peerflix: ${CYAN}npm install -g peerflix${RESET}"
    else
        echo -e "${RED}Error:${RESET} No torrent streaming tool found."
        echo
        echo "Please install one of:"
        echo "  ${GREEN}npm install -g peerflix${RESET}  (recommended)"
        echo "  ${GREEN}npm install -g webtorrent-cli${RESET}  (alternative)"
        echo
        echo "Or use: ${CYAN}brew install peerflix${RESET}"
        exit 1
    fi
    
    # Check for transmission-cli (fallback for problematic magnet links)
    if ! command -v transmission-cli &> /dev/null; then
        echo -e "${YELLOW}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo -e "${YELLOW}Warning:${RESET} transmission-cli not found"
        echo ""
        echo "transmission-cli is used as a fallback when peerflix fails to handle"
        echo "certain magnet links. It's recommended to install it for better compatibility."
        echo ""
        echo -e "${CYAN}Would you like to install transmission-cli now? (y/n)${RESET} "
        read -r install_transmission
        
        if [[ "$install_transmission" =~ ^[Yy]$ ]]; then
            echo ""
            echo -e "${CYAN}Installing transmission-cli...${RESET}"
            
            # Try brew first (macOS)
            if command -v brew &> /dev/null; then
                echo -e "${GREEN}Using Homebrew...${RESET}"
                if brew install transmission-cli; then
                    echo -e "${GREEN}‚úì transmission-cli installed successfully${RESET}"
                    echo ""
                else
                    echo -e "${RED}‚úó Installation failed. Please install manually:${RESET}"
                    echo "  ${GREEN}brew install transmission-cli${RESET}"
                    echo ""
                    echo -e "${YELLOW}You can continue without it, but some magnet links may not work.${RESET}"
                fi
            else
                echo -e "${YELLOW}Homebrew not found. Please install transmission-cli manually:${RESET}"
                echo ""
                echo "  ${GREEN}macOS:${RESET} brew install transmission-cli"
                echo "  ${GREEN}Linux:${RESET} sudo apt-get install transmission-cli  (Debian/Ubuntu)"
                echo "  ${GREEN}Linux:${RESET} sudo yum install transmission-cli    (RHEL/CentOS)"
                echo ""
                echo -e "${YELLOW}You can continue without it, but some magnet links may not work.${RESET}"
            fi
        else
            echo -e "${YELLOW}Skipping transmission-cli installation.${RESET}"
            echo -e "${YELLOW}Note:${RESET} Some magnet links may not work without transmission-cli."
            echo ""
        fi
    fi
    
    # Note: Player preference will be checked when streaming starts
    # This avoids prompting during catalog browsing
}

# Show help
show_help() {
    cat << EOF
${BOLD}${CYAN}Termflix - Torrent Streaming Tool${RESET}

Stream torrents directly to mpv or VLC player using peerflix.

${BOLD}Usage:${RESET}
  termflix                                    Show latest movies and shows (default)
  termflix <magnet_link>
  termflix <torrent_file>
  termflix search <query>
  termflix latest [movies|shows|all]
  termflix trending [movies|shows|all]
  termflix popular [movies|shows|all]
  termflix catalog [genre]

${BOLD}Options:${RESET}
  -h, --help          Show this help
  -l, --list          List available files in torrent
  -i, --index <num>   Select specific file by index
  -q, --quality       Auto-select best quality
  -s, --subtitles     Enable subtitle loading (auto-detected if available)
  -v, --verbose       Verbose output
      --debug         Show debug information (magnet links, etc.)

${BOLD}Commands:${RESET}
  player <mpv|vlc>    Change default media player preference

${BOLD}Examples:${RESET}
  termflix                                    # Show latest movies and shows
  termflix "magnet:?xt=urn:btih:..."
  termflix movie.torrent
  termflix search "movie name"
  termflix latest movies
  termflix trending shows
  termflix catalog action

${BOLD}Catalog Features:${RESET}
  - Browse latest movies and TV shows (like Stremio)
  - View trending and popular content
  - Browse by genre/category

EOF
}

# Search using YTS API (movies) - same as Stremio YTS addon
# Uses same approach as YTS-Streaming app
search_yts() {
    local query="$1"
    
    echo -e "${CYAN}[YTS]${RESET} Searching movies..." >&2
    
    # Build URL the same way as YTS-Streaming app
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?query_term=${query// /+}&limit=10"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 5 --connect-timeout 3 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                # Same structure as YTS-Streaming app
                echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -10
            fi
        fi
    fi
}

# Search using YTSRS (en.ytsrs.com) - web crawler approach
search_ytsrs() {
    local query="$1"
    
    echo -e "${CYAN}[YTSRS]${RESET} Searching movies..." >&2
    
    if ! command -v python3 &> /dev/null; then
        return 1
    fi
    
    # YTSRS doesn't have a direct search API, so we need to crawl the home page
    # and filter by title. For now, let's try searching via their movies page
    # with a query parameter if they support it, otherwise crawl and filter
    
    local search_url="https://en.ytsrs.com/home"
    local html=$(curl -s --max-time 8 --connect-timeout 3 \
        -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
        "$search_url" 2>/dev/null)
    
    if [ -z "$html" ] || [ ${#html} -lt 100 ]; then
        return 1
    fi
    
    # Use Python to search through the HTML
    local temp_html=$(mktemp)
    echo "$html" > "$temp_html"
    
    export YTSRS_QUERY="$query"
    export YTSRS_TEMP_FILE="$temp_html"
    
    python3 << 'PYEOF'
import sys, re, json, urllib.parse, urllib.request, os

try:
    temp_file = os.environ.get('YTSRS_TEMP_FILE', '/tmp/ytsrs_search_temp.html')
    query = os.environ.get('YTSRS_QUERY', '').lower()
    
    if not query or not os.path.exists(temp_file):
        sys.exit(1)
    
    with open(temp_file, "r", encoding="utf-8", errors="ignore") as f:
        html = f.read()
    
    if not html or len(html) < 100:
        sys.exit(1)
    
    # Find all movie cards with openModal onclick
    movie_pattern = r'onclick=[\'"]openModal\((\d+),\s*["\']([^"\']+)["\'],\s*["\']([^"\']+)["\'],\s*["\'](\d+)["\']\)'
    movies = re.findall(movie_pattern, html)
    
    if not movies:
        sys.exit(1)
    
    # Filter movies by query (case-insensitive)
    matching_movies = []
    for movie_id, imdb_id, title, year in movies:
        if query in title.lower() or query in year:
            matching_movies.append((movie_id, imdb_id, title, year))
    
    if not matching_movies:
        sys.exit(1)
    
    # Limit to top 10 matches
    count = 0
    for movie_id, imdb_id, title, year in matching_movies[:10]:
        if count >= 10:
            break
        
        # Extract quality from nearby HTML
        card_start = html.find(f'openModal({movie_id},')
        if card_start == -1:
            continue
        card_section = html[max(0, card_start-200):card_start+1000]
        
        quality_match = re.search(r'<span[^>]*class="[^"]*movie-quality[^"]*"[^>]*>([^<]+)</span>', card_section)
        quality = quality_match.group(1).strip() if quality_match else "1080p"
        
        # Fetch movie details to get hash
        detail_url = f"https://en.ytsrs.com/?ajax=movie_details&movie_id={movie_id}&imdb_id={urllib.parse.quote(imdb_id)}&title={urllib.parse.quote(title)}&year={year}"
        
        try:
            req = urllib.request.Request(detail_url, headers={'User-Agent': 'Mozilla/5.0'})
            with urllib.request.urlopen(req, timeout=3) as response:
                detail_data = json.loads(response.read().decode())
                
                torrents = detail_data.get('yts', {}).get('data', {}).get('movie', {}).get('torrents', [])
                if not torrents:
                    continue
                
                # Find matching quality or use first
                torrent = next((t for t in torrents if t.get('quality') == quality), torrents[0])
                if not torrent.get('hash'):
                    continue
                
                hash_val = torrent['hash']
                size = torrent.get('size', 'N/A')
                seeds = torrent.get('seeds', 0)
                
                print(f"YTSRS|{title} ({year})|magnet:?xt=urn:btih:{hash_val}|{quality}|{size}|{seeds} seeds")
                count += 1
        except Exception as e:
            continue
    
    os.unlink(temp_file)
    sys.exit(0 if count > 0 else 1)
except Exception as e:
    if 'temp_file' in locals() and os.path.exists(temp_file):
        os.unlink(temp_file)
    sys.exit(1)
PYEOF
    local result=$?
    rm -f "$temp_html" 2>/dev/null
    return $result
}

# Search using 1337x API - same as Stremio 1337x addon
search_1337x() {
    local query="$1"
    
    echo -e "${CYAN}[1337x]${RESET} Searching..." >&2
    
    # Use 1337x unofficial API (similar to what Stremio uses)
    local search_url="https://1337x.to/search/${query// /+/}/1/"
    
    if command -v curl &> /dev/null; then
        # Try to parse 1337x HTML (they don't have official API)
        local html=$(curl -s -L --max-time 5 --connect-timeout 3 -H "User-Agent: Mozilla/5.0" "$search_url" 2>/dev/null)
        
        if [ -n "$html" ]; then
            # Extract torrent links and names (BSD grep compatible)
            echo "$html" | grep -o '<a href="/torrent/[^"]*">[^<]*</a>' | head -10 | while read -r line; do
                local name=$(echo "$line" | sed -E 's/.*>([^<]*)<.*/\1/')
                local id=$(echo "$line" | sed -E 's|.*/torrent/([^/]+)/.*|\1|')
                if [ -n "$id" ] && [ -n "$name" ] && [ "$id" != "href" ]; then
                    echo "1337x|$name|https://1337x.to/torrent/$id|N/A|N/A"
                fi
            done
        fi
    fi
}

# Search using ThePirateBay API - same as Stremio TPB addon
search_tpb() {
    local query="$1"
    
    echo -e "${CYAN}[ThePirateBay]${RESET} Searching..." >&2
    
    # TPB has an official API
    local api_url="https://apibay.org/q.php?q=${query// /%20}&cat=0"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 5 --connect-timeout 3 "$api_url" 2>/dev/null)
        
        if [ -n "$response" ]; then
            echo "$response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB"' 2>/dev/null | head -10
        fi
    fi
}

# Search using EZTV API (TV shows) - same as Stremio EZTV addon
search_eztv() {
    local query="$1"
    
    echo -e "${CYAN}[EZTV]${RESET} Searching TV shows..." >&2
    
    local api_url="https://eztv.re/api/get-torrents?imdb_id=&limit=20&page=1&query_string=${query// /+}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 5 --connect-timeout 3 "$api_url" 2>/dev/null)
        
        if [ -n "$response" ]; then
            local count=$(echo "$response" | jq -r '.torrents_count // 0' 2>/dev/null)
            
            if [ "$count" -gt 0 ] 2>/dev/null; then
                echo "$response" | jq -r '.torrents[]? | select(.magnet_url != null and .magnet_url != "") | "EZTV|\(.title)|\(.magnet_url)|\(.seeds) seeds|\(.size_bytes / 1024 / 1024 | floor)MB"' 2>/dev/null | head -10
            fi
        fi
    fi
}

# Scrape movies from YTSRS (en.ytsrs.com)
# Supports genre, quality, sort parameters
get_ytsrs_movies() {
    local genre="${1:-}"
    local quality="${2:-1080p}"
    local sort="${3:-seeds}"
    local limit="${4:-20}"
    local page="${5:-1}"  # Page not used for YTSRS but kept for compatibility
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTSRS]${RESET} Fetching movies (genre=$genre, quality=$quality, sort=$sort)..." >&2
    
    # Build URL
    local base_url="https://en.ytsrs.com/movies"
    local params="quality=${quality}&sort=${sort}"
    if [ -n "$genre" ] && [ "$genre" != "" ]; then
        params="${params}&genre=${genre}"
    fi
    local api_url="${base_url}?${params}"
    
    if ! command -v python3 &> /dev/null; then
        echo -e "${YELLOW}Warning:${RESET} python3 required for YTSRS scraping" >&2
        return 1
    fi
    
    # Scrape the HTML page
    local html=$(curl -s --max-time 10 -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$api_url" 2>/dev/null)
    
    if [ -z "$html" ]; then
        return 1
    fi
    
    # Use Python to parse HTML and extract movie data
    # Save to temp file to avoid shell escaping issues
    local temp_html=$(mktemp)
    echo "$html" > "$temp_html"
    
    # Pass variables as environment variables
    export YTSRS_LIMIT="$limit"
    export YTSRS_QUALITY="$quality"
    export YTSRS_TEMP_FILE="$temp_html"
    
    python3 << 'PYEOF'
import sys, re, json, urllib.parse, urllib.request, os

try:
    temp_file = os.environ.get('YTSRS_TEMP_FILE', '/tmp/ytsrs_temp.html')
    limit = int(os.environ.get('YTSRS_LIMIT', '20'))
    default_quality = os.environ.get('YTSRS_QUALITY', '1080p')
    
    if not os.path.exists(temp_file):
        sys.exit(1)
    
    with open(temp_file, "r", encoding="utf-8", errors="ignore") as f:
        html = f.read()
    
    if not html or len(html) < 100:
        sys.exit(1)
    
    # Find all movie cards with openModal onclick
    movie_pattern = r'onclick=[\'"]openModal\((\d+),\s*["\']([^"\']+)["\'],\s*["\']([^"\']+)["\'],\s*["\'](\d+)["\']\)'
    movies = re.findall(movie_pattern, html)
    
    if not movies:
        sys.exit(1)
    
    count = 0
    # Limit to fewer movies for speed (fetch details for top results only)
    max_fetch = min(limit, 10)  # Only fetch details for first 10 to keep it fast
    
    for movie_id, imdb_id, title, year in movies:
        if count >= max_fetch:
            break
        
        # Extract quality from nearby HTML
        card_start = html.find(f'openModal({movie_id},')
        if card_start == -1:
            continue
        card_section = html[max(0, card_start-200):card_start+1000]
        
        quality_match = re.search(r'<span[^>]*class="[^"]*movie-quality[^"]*"[^>]*>([^<]+)</span>', card_section)
        quality = quality_match.group(1).strip() if quality_match else default_quality
        
        # Get poster image - handle multiline and attribute order
        img_match = re.search(r'<img[^>]+class="[^"]*movie-poster[^"]*"[^>]*>', card_section, re.DOTALL)
        poster = "N/A"
        if img_match:
            img_tag = img_match.group(0)
            src_match = re.search(r'src="([^"]+)"', img_tag)
            if src_match:
                poster = src_match.group(1)
        
        # Fetch movie details to get hash (with shorter timeout for speed)
        detail_url = f"https://en.ytsrs.com/?ajax=movie_details&movie_id={movie_id}&imdb_id={urllib.parse.quote(imdb_id)}&title={urllib.parse.quote(title)}&year={year}"
        try:
            req = urllib.request.Request(detail_url, headers={'User-Agent': 'Mozilla/5.0'})
            with urllib.request.urlopen(req, timeout=2) as response:
                detail_data = json.loads(response.read().decode())
                torrents = detail_data.get('yts', {}).get('data', {}).get('movie', {}).get('torrents', [])
                if torrents:
                    # Use first torrent or find matching quality
                    torrent = next((t for t in torrents if t.get('quality') == quality), torrents[0])
                    hash_val = torrent.get('hash', '')
                    size = torrent.get('size', 'N/A')
                    seeds = torrent.get('seeds', 0)
                    peers = torrent.get('peers', 0)
                    
                    if hash_val:
                        magnet = f"magnet:?xt=urn:btih:{hash_val}&dn={urllib.parse.quote(title)}"
                        print(f"YTSRS|{title} ({year})|{magnet}|{quality}|{size}|{seeds} seeds, {peers} peers|{poster}", flush=True)
                        count += 1
        except Exception as e:
            # Skip on error - continue to next movie
            pass
except Exception as e:
    # Fail silently
    pass
PYEOF
    
    rm -f "$temp_html" 2>/dev/null
    unset YTSRS_LIMIT YTSRS_QUALITY YTSRS_TEMP_FILE
}

# Get latest movies from YTS (like Stremio catalog)
# Uses same approach as YTS-Streaming app
# Supports pagination via page parameter
get_latest_movies() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Try YTS first (same as YTS-Streaming app)
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching latest movies..." >&2
    
    # Build URL the same way as YTS-Streaming app (with pagination)
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?limit=${limit}&sort_by=date_added&order_by=desc&page=${page}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        # Try with timeout - YTS API may be slow or down
        local response=$(curl -s --max-time 3 --connect-timeout 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                # Get movies and their torrents - same structure as YTS-Streaming
                # Include poster URL (medium_cover_image)
                local results=$(echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.date_uploaded // "N/A")|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20)
                
                if [ -n "$results" ]; then
                    echo "$results"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fallback to TPB if YTS fails (YTS API is often down)
    echo -e "${YELLOW}[TPB]${RESET} YTS unavailable, using ThePirateBay..." >&2
    # TPB doesn't have pagination in precompiled, so we fetch more and paginate client-side
    local tpb_url="https://apibay.org/precompiled/data_top100_207.json"
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local tpb_response=$(curl -s --max-time 5 "$tpb_url" 2>/dev/null)
        if [ -n "$tpb_response" ]; then
            # Fetch all available and let display_catalog handle pagination
            echo "$tpb_response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB|Latest"' 2>/dev/null
        fi
    fi
}

# Get trending movies from YTS
# Uses same approach as YTS-Streaming app
# Supports pagination via page parameter
get_trending_movies() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching trending movies..." >&2
    
    # Build URL the same way as YTS-Streaming app (with pagination)
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?limit=${limit}&sort_by=download_count&order_by=desc&page=${page}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 3 --connect-timeout 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                local results=$(echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.download_count // 0)|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20)
                
                if [ -n "$results" ]; then
                    echo "$results"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fallback to TPB trending
    echo -e "${YELLOW}[TPB]${RESET} YTS unavailable, using ThePirateBay trending..." >&2
    local tpb_url="https://apibay.org/precompiled/data_top100_201.json"
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local tpb_response=$(curl -s --max-time 5 "$tpb_url" 2>/dev/null)
        if [ -n "$tpb_response" ]; then
            # Fetch all available for pagination
            echo "$tpb_response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB|Trending"' 2>/dev/null
        fi
    fi
}

# Get popular movies from YTS
# Uses same approach as YTS-Streaming app
# Supports pagination via page parameter
get_popular_movies() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching popular movies..." >&2
    
    # Build URL the same way as YTS-Streaming app (with pagination)
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?limit=${limit}&sort_by=rating&order_by=desc&minimum_rating=7&page=${page}"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 3 --connect-timeout 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ] && [ "$response" != "" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                local results=$(echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year)) - ‚≠ê\(.rating // "N/A")|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.rating // "N/A")|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20)
                
                if [ -n "$results" ]; then
                    echo "$results"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fallback to TPB popular
    echo -e "${YELLOW}[TPB]${RESET} YTS unavailable, using ThePirateBay popular..." >&2
    local tpb_url="https://apibay.org/precompiled/data_top100_205.json"
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local tpb_response=$(curl -s --max-time 5 "$tpb_url" 2>/dev/null)
        if [ -n "$tpb_response" ]; then
            # Fetch all available for pagination
            echo "$tpb_response" | jq -r '.[]? | select(.info_hash != null and .info_hash != "") | "TPB|\(.name)|magnet:?xt=urn:btih:\(.info_hash)|\(.seeders) seeds|\(.size / 1024 / 1024 | floor)MB|Popular"' 2>/dev/null
        fi
    fi
}

# Get latest TV shows from EZTV
# Supports pagination via page parameter
get_latest_shows() {
    local limit="${1:-50}"
    local page="${2:-1}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[EZTV]${RESET} Fetching latest TV shows..." >&2
    
    local api_url="https://eztv.re/api/get-torrents?limit=$limit&page=$page"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        local response=$(curl -s --max-time 5 "$api_url" 2>/dev/null)
        local count=$(echo "$response" | jq -r '.torrents_count // 0' 2>/dev/null)
        
        if [ "$count" -gt 0 ] 2>/dev/null; then
            echo "$response" | jq -r '.torrents[]? | select(.magnet_url != null and .magnet_url != "") | "EZTV|\(.title)|\(.magnet_url)|\(.seeds) seeds|\(.size_bytes / 1024 / 1024 | floor)MB|\(.date_released_unix // 0)"' 2>/dev/null
        fi
    fi
}

# Get catalog by genre
# Uses same approach as YTS-Streaming app
get_catalog_by_genre() {
    local genre="$1"
    local limit="${2:-20}"
    
    # Progress is shown by display_catalog, so suppress this message
    # echo -e "${CYAN}[YTS]${RESET} Fetching $genre movies..." >&2
    
    # Map common genre names to YTS genre IDs (same as YTS-Streaming)
    local genre_id=""
    case "$(echo "$genre" | tr '[:upper:]' '[:lower:]')" in
        action) genre_id="Action" ;;
        adventure) genre_id="Adventure" ;;
        animation) genre_id="Animation" ;;
        comedy) genre_id="Comedy" ;;
        crime) genre_id="Crime" ;;
        documentary) genre_id="Documentary" ;;
        drama) genre_id="Drama" ;;
        family) genre_id="Family" ;;
        fantasy) genre_id="Fantasy" ;;
        horror) genre_id="Horror" ;;
        mystery) genre_id="Mystery" ;;
        romance) genre_id="Romance" ;;
        sci-fi|scifi|science-fiction) genre_id="Sci-Fi" ;;
        thriller) genre_id="Thriller" ;;
        war) genre_id="War" ;;
        western) genre_id="Western" ;;
        *) genre_id="$genre" ;;
    esac
    
    # Build URL the same way as YTS-Streaming app
    local base_url="https://yts.mx/api/v2/list_movies.json"
    local api_url="${base_url}?genre=${genre_id}&limit=${limit}&sort_by=date_added&order_by=desc"
    
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        # Add User-Agent header like browsers do
        local response=$(curl -s --max-time 10 --retry 1 --retry-delay 2 \
            -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
            -H "Accept: application/json" \
            "$api_url" 2>/dev/null)
        
        if [ -n "$response" ]; then
            local status=$(echo "$response" | jq -r '.status // "fail"' 2>/dev/null)
            
            if [ "$status" = "ok" ]; then
                echo "$response" | jq -r '.data.movies[]? | select(.torrents != null and (.torrents | length) > 0) | .torrents[0] as $torrent | select($torrent.hash != null and $torrent.hash != "") | "YTS|\(.title) (\(.year))|magnet:?xt=urn:btih:\($torrent.hash)|\($torrent.quality // "N/A")|\($torrent.size // "N/A")|\(.genres | join(", "))|\(.medium_cover_image // "N/A")"' 2>/dev/null | head -20
            fi
        fi
    fi
}

# Helper function to redraw a specific page from cached results
# This function displays a page without re-fetching data
redraw_catalog_page() {
    local title="$1"
    local cached_results_ref="$2"  # Name of array variable containing cached results
    local page="$3"
    local per_page="$4"
    local total="$5"
    
    # Get the cached results array
    eval "local all_results=(\"\${${cached_results_ref}[@]}\")"
    
    # Calculate pagination
    local total_pages=$(( (total + per_page - 1) / per_page ))
    local start_idx=$(( (page - 1) * per_page ))
    local end_idx=$(( start_idx + per_page ))
    
    # Clear screen and redraw
    clear
    echo -e "${BOLD}${YELLOW}$title${RESET}\n"
    
    # Display pagination info
    echo -e "${BOLD}${GREEN}Found ${total} results${RESET} (Page ${page}/${total_pages})"
    
    # Check if we have any results with posters
    local has_posters=false
    for result in "${all_results[@]}"; do
        IFS='|' read -r result_source result_name result_magnet result_quality result_size result_extra result_poster <<< "$result"
        if [[ -n "$result_poster" ]] && [[ "$result_poster" != "N/A" ]]; then
            has_posters=true
            break
        fi
    done
    
    # Show note about posters
    if [ "$has_posters" = false ] && check_viu >/dev/null 2>&1; then
        echo -e "${YELLOW}Note:${RESET} Movie posters are not available for these results."
    elif [ "$has_posters" = true ] && ! check_viu >/dev/null 2>&1; then
        echo -e "${YELLOW}Note:${RESET} Install ${CYAN}viu${RESET} to see movie posters: ${CYAN}brew install viu${RESET}"
    fi
    echo
    
    # Display results in grid layout (same logic as before)
    local term_cols=$(tput cols)
    local num_cols=$((term_cols / 40))
    if [ "$num_cols" -lt 1 ]; then num_cols=1; fi
    if [ "$num_cols" -gt 5 ]; then num_cols=5; fi
    
    local index=$start_idx
    local current_start_row=5
    local term_lines=$(tput lines)
    local term_cols=$(tput cols)
    local row_height=20
    
    local row_items=()
    local row_count=0
    
    tput cup "$current_start_row" 0
    echo
    
    while [ $index -lt $end_idx ] && [ $index -lt $total ]; do
        local result="${all_results[$index]}"
        
        if [ -z "$result" ]; then
            index=$((index + 1))
            continue
        fi
        
        row_items+=("$result")
        row_count=$((row_count + 1))
        
        if [ $row_count -eq $num_cols ] || [ $index -eq $((end_idx - 1)) ] || [ $index -eq $((total - 1)) ]; then
            # Parallel Fetching of Posters (same as before)
            local pids=()
            local temp_files=()
            local fetch_indices=()
            local fetching=false
            
            for i in "${!row_items[@]}"; do
                local item="${row_items[$i]}"
                IFS='|' read -r source name magnet quality size extra poster_url <<< "$item"
                
                local title_year=$(echo "$name" | sed -E 's/\./ /g' | sed -E 's/([0-9]{4}).*/\1/')
                local title=$(echo "$title_year" | sed -E 's/ [0-9]{4}//')
                local year=$(echo "$title_year" | grep -oE '[0-9]{4}' | head -1)
                local clean_title=$(echo "$title" | sed -E 's/ \([0-9]{4}\).*//' | sed 's/\[.*\]//g' | xargs)
                
                if [[ -z "$poster_url" ]] || [[ "$poster_url" == "N/A" ]]; then
                    if [ -n "$clean_title" ]; then
                        fetching=true
                        local temp_file=$(mktemp)
                        temp_files[$i]="$temp_file"
                        fetch_indices+=($i)
                        (
                            local new_poster=$(fetch_tmdb_poster "$clean_title" "$year")
                            echo "$new_poster" > "$temp_file"
                        ) &
                        pids+=($!)
                    fi
                else
                    local cache_dir=$(get_termflix_cache_dir)/tmdb
                    local cache_key=$(echo "${clean_title}_${year}" | tr -cd '[:alnum:]')
                    local cache_file="$cache_dir/${cache_key}.json"
                    
                    if [ ! -f "$cache_file" ] && [ -n "$clean_title" ]; then
                        (
                            fetch_tmdb_poster "$clean_title" "$year" > /dev/null 2>&1
                        ) &
                        pids+=($!)
                    fi
                fi
            done
            
            if [ "$fetching" = true ]; then
                tput sc
                echo -ne "${YELLOW}Fetching posters...${RESET}"
                for pid in "${pids[@]}"; do
                    wait "$pid" 2>/dev/null
                done
                tput rc
                tput el
                
                for i in "${fetch_indices[@]}"; do
                    local temp_file="${temp_files[$i]}"
                    if [ -f "$temp_file" ]; then
                        local new_poster=$(cat "$temp_file")
                        rm -f "$temp_file"
                        if [ -n "$new_poster" ] && [ "$new_poster" != "N/A" ]; then
                            local item="${row_items[$i]}"
                            IFS='|' read -r source name magnet quality size extra old_poster <<< "$item"
                            row_items[$i]="$source|$name|$magnet|$quality|$size|$extra|$new_poster"
                        fi
                    fi
                done
            fi
            
            if [ "$current_start_row" -lt 1 ]; then
                current_start_row=1
            fi
            if [ "$current_start_row" -ge "$term_lines" ]; then
                local scroll_needed=$((current_start_row - term_lines + row_height + 5))
                if [ "$scroll_needed" -lt 3 ]; then
                    scroll_needed=3
                fi
                for ((scroll=0; scroll<scroll_needed; scroll++)); do
                    echo
                done
                current_start_row=$((current_start_row - scroll_needed))
                if [ "$current_start_row" -lt 1 ]; then
                    current_start_row=1
                fi
            fi
            tput cup "$current_start_row" 0
            
            local item_start_index=$((index - row_count + 1))
            if [ "$item_start_index" -lt 0 ]; then
                item_start_index=0
            fi
            
            local temp_return=$(mktemp)
            draw_grid_row "$current_start_row" "$item_start_index" "$num_cols" "${row_items[@]}" 2>"$temp_return"
            local next_row
            next_row=$(tail -1 "$temp_return" 2>/dev/null | grep -E '^[0-9]+$' | tail -1)
            rm -f "$temp_return"
            
            if ! [[ "$next_row" =~ ^[0-9]+$ ]] || [ -z "$next_row" ]; then
                next_row=$((current_start_row + row_height))
            fi
            
            # Check if this is the first or last row
            local is_first_row=false
            if [ "$item_start_index" -eq 0 ]; then
                is_first_row=true
            fi
            
            local is_last_row=false
            if [ $index -eq $((end_idx - 1)) ] || [ $index -eq $((total - 1)) ]; then
                is_last_row=true
            fi
            
            if [ "$row_count" -eq "$num_cols" ]; then
                # Skip spacing for first or last row
                if [ "$is_first_row" = true ] || [ "$is_last_row" = true ]; then
                    # Minimal spacing for first/last row
                    echo
                    next_row=$((next_row + 1))
                else
                    # Standard spacing (3 echo statements) + additional spacing (4 echo statements) for middle rows
                    echo
                    echo
                    echo
                    next_row=$((next_row + 3))
                    echo
                    echo
                    echo
                    echo
                    next_row=$((next_row + 4))
                fi
                current_start_row=$next_row
            else
                current_start_row=$next_row
                if [ "$current_start_row" -lt "$term_lines" ]; then
                    tput cup "$current_start_row" 0
                fi
            fi
            
            if [ "$row_count" -eq "$num_cols" ]; then
                local available_lines=$((term_lines - current_start_row))
                if [ "$current_start_row" -ge "$term_lines" ] || [ "$available_lines" -lt "$row_height" ]; then
                    local lines_to_scroll=$((row_height - available_lines + 3))
                    if [ "$lines_to_scroll" -lt 3 ]; then
                        lines_to_scroll=3
                    fi
                    for ((scroll=0; scroll<lines_to_scroll; scroll++)); do
                        echo
                    done
                    current_start_row=$((term_lines - row_height - 5))
                    if [ "$current_start_row" -lt 1 ]; then
                        current_start_row=1
                    fi
                    if [ "$current_start_row" -lt "$term_lines" ]; then
                        tput cup "$current_start_row" 0
                    fi
                fi
            fi
            
            row_items=()
            row_count=0
        fi
        index=$((index + 1))
    done
    
    # Navigation will be displayed by the calling function
    # Just ensure we're at a reasonable position
    local term_lines=$(tput lines)
    local final_cursor_row=$((term_lines - 8))
    if [ "$final_cursor_row" -lt 1 ]; then
        final_cursor_row=1
    fi
    tput cup "$final_cursor_row" 0
    echo
}

# Display catalog results in columns with pagination
display_catalog() {
    local title="$1"
    local all_results=()
    local page="${CATALOG_PAGE:-1}"
    local per_page=20
    shift
    
    # Store original arguments for pagination navigation
    local original_args=("$@")
    
    echo -e "${BOLD}${YELLOW}$title${RESET}\n"
    
    # Initialize termflix directories
    init_termflix_dirs
    
    # Generate cache key from function names and arguments
    local cache_key=$(generate_cache_key "$title" "${original_args[@]}")
    local cache_dir=$(get_termflix_cache_dir)
    local cache_file="$cache_dir/catalog_${cache_key}.txt"
    
    # Check if cache is valid (less than 8 hours old)
    if is_cache_valid "$cache_file"; then
        echo -e "${CYAN}Loading from cache...${RESET}"
        # Read results from cache
        local result_count=0
        if [ -f "$cache_file" ] && [ -s "$cache_file" ]; then
            while IFS= read -r line || [ -n "$line" ]; do
                if [ -n "$line" ] && echo "$line" | grep -q '|'; then
                    all_results+=("$line")
                    result_count=$((result_count + 1))
                fi
            done < "$cache_file"
        fi
        
        if [ ${#all_results[@]} -gt 0 ]; then
            printf "\r${GREEN}‚úì Loaded ${result_count} results from cache${RESET}                    \n"
            # Skip to pagination logic
            goto_pagination=true
        else
            goto_pagination=false
        fi
    else
        goto_pagination=false
    fi
    
    # Collect results from all functions passed as arguments
    local temp_file=$(mktemp 2>/dev/null || echo "/tmp/torrent_catalog_$$")
    local args_copy=("$@")
    local arg_idx=0
    local ytsrs_pids=()
    local all_pids=()
    local func_names=()
    
    # Determine source names for display
    get_source_name() {
        local func="$1"
        # Check for YTSRS first (more specific patterns)
        if [[ "$func" == *"ytsrs"* ]] || [[ "$func" == *"YTSRS"* ]] || [[ "$func" == "get_ytsrs"* ]] || ([[ "$func" == *"_wrapper"* ]] && [[ "$func" == *"ytsrs"* ]]); then
            echo "YTSRS"
        elif [[ "$func" == "get_latest_movies" ]] || [[ "$func" == "get_trending_movies" ]] || [[ "$func" == "get_popular_movies" ]] || [[ "$func" == "get_catalog_by_genre" ]]; then
            echo "YTS"
        elif [[ "$func" == "get_tpb_movies" ]] || [[ "$func" == "get_tpb_trending" ]] || [[ "$func" == "get_tpb_popular" ]]; then
            echo "TPB"
        elif [[ "$func" == "get_latest_shows" ]] || [[ "$func" == *"eztv"* ]]; then
            echo "EZTV"
        else
            echo "API"
        fi
    }
    
    # Only fetch if cache was not used
    if [ "$goto_pagination" != "true" ]; then
        echo -e "${CYAN}Fetching data from sources (all pages)...${RESET}"
        
        # CRITICAL: Fetch ALL pages at once and cache in memory
        # Fetch pages 1-10 in parallel to get all results
        local max_pages=10
        local page_pids=()
        local page_files=()
        
        while [ $arg_idx -lt ${#args_copy[@]} ]; do
        local func="${args_copy[$arg_idx]}"
        arg_idx=$((arg_idx + 1))
        local source_name=$(get_source_name "$func")
        
        # Call the function with remaining arguments
        if [ $arg_idx -lt ${#args_copy[@]} ] && [[ "${args_copy[$arg_idx]}" =~ ^[0-9]+$ ]]; then
            local limit="${args_copy[$arg_idx]}"
            arg_idx=$((arg_idx + 1))
            
            # Fetch all pages (1-10) in parallel for this function
            printf "\r${CYAN}Fetching all pages from ${source_name}...${RESET}"
            for p in $(seq 1 $max_pages); do
                local page_file="${temp_file}.page${p}"
                page_files+=("$page_file")
                ($func "$limit" "$p" >> "$page_file" 2>&1) &
                page_pids+=($!)
            done
        else
            # Fetch all pages (1-10) in parallel for this function
            printf "\r${CYAN}Fetching all pages from ${source_name}...${RESET}"
            for p in $(seq 1 $max_pages); do
                local page_file="${temp_file}.page${p}"
                page_files+=("$page_file")
                ($func "$p" >> "$page_file" 2>&1) &
                page_pids+=($!)
            done
        fi
    done
        
        # Wait for all page fetches to complete
        printf "\r${CYAN}Waiting for all pages to load...${RESET}"
        for pid in "${page_pids[@]}"; do
            wait "$pid" 2>/dev/null || true
        done
        
        # Combine all page files into one temp file
        for page_file in "${page_files[@]}"; do
            if [ -f "$page_file" ]; then
                cat "$page_file" >> "$temp_file" 2>/dev/null || true
                rm -f "$page_file" 2>/dev/null || true
            fi
        done
        
        printf "\r${GREEN}‚úì Fetched all pages${RESET}                    \n"
        
        
        echo -e "${CYAN}Parsing results...${RESET}"
        
        # Read results from temp file
        local result_count=0
        if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
            while IFS= read -r line || [ -n "$line" ]; do
                if [ -n "$line" ] && echo "$line" | grep -q '|'; then
                    all_results+=("$line")
                    result_count=$((result_count + 1))
                    # Show progress while parsing
                    if [ $((result_count % 5)) -eq 0 ]; then
                        printf "\r${CYAN}Parsing results...${RESET} [%d found]" "$result_count"
                    fi
                fi
            done < "$temp_file"
            
            # Save results to cache
            if [ ${#all_results[@]} -gt 0 ]; then
                printf "%s\n" "${all_results[@]}" > "$cache_file" 2>/dev/null
            fi
        fi
        
        rm -f "$temp_file" 2>/dev/null
        
        printf "\r${GREEN}‚úì Parsed ${result_count} results${RESET}                    \n"
    fi
    
    if [ ${#all_results[@]} -eq 0 ]; then
        echo -e "${RED}No results found${RESET}"
        echo -e "${YELLOW}Note:${RESET} This might be due to API timeouts or rate limiting."
        echo "Try again in a moment or use: ${CYAN}torrent search \"query\"${RESET}"
        return 1
    fi
    
    echo  # Blank line before results
    
    # Calculate pagination
    local total=${#all_results[@]}
    local total_pages=$(( (total + per_page - 1) / per_page ))
    
    # Store cached results in a variable name for redraw function
    local cached_results_var="cached_results_$$"
    eval "declare -a ${cached_results_var}=()"
    for result in "${all_results[@]}"; do
        eval "${cached_results_var}+=(\"\$result\")"
    done
    
    # Display initial page using redraw function
    redraw_catalog_page "$title" "$cached_results_var" "$page" "$per_page" "$total"
    
    # Interactive selection with pagination using keypress detection
    if [ -t 0 ]; then
        
        # Navigation loop with keypress detection
        local current_page=$page
        local selection=""
        local number_input=""
        
        while true; do
            # Display navigation instructions at bottom of screen
            local term_lines=$(tput lines)
            local nav_row=$((term_lines - 8))
            if [ "$nav_row" -lt 1 ]; then
                nav_row=1
            fi
            tput cup "$nav_row" 0
            echo
            echo
            
            if [ $total_pages -gt 1 ]; then
                echo -e "${CYAN}Navigation:${RESET}"
                echo -e "  ${GREEN}n${RESET} - Next page (press key, no Enter needed)"
                echo -e "  ${GREEN}p${RESET} - Previous page (press key, no Enter needed)"
                echo -e "  ${GREEN}1-${total}${RESET} - Select torrent (type number, press Enter)"
                echo -e "  ${GREEN}q${RESET} or ${GREEN}Esc${RESET} - Cancel/Quit"
                echo
            else
                echo -e "${CYAN}Navigation:${RESET}"
                echo -e "  ${GREEN}1-${total}${RESET} - Select torrent (type number, press Enter)"
                echo -e "  ${GREEN}q${RESET} or ${GREEN}Esc${RESET} - Cancel/Quit"
                echo
            fi
            
            # Setup terminal for keypress detection
            local old_stty
            old_stty=$(stty -g 2>/dev/null) || true
            stty -icanon -echo 2>/dev/null || true
            
            # Read a single keypress
            local key
            if IFS= read -rsn1 key 2>/dev/null; then
                # Handle escape sequences (arrow keys, etc.)
                if [ "$key" = $'\033' ]; then
                    read -rsn1 -t 0.1 key 2>/dev/null || true
                    if [ "$key" = "[" ]; then
                        read -rsn1 -t 0.1 key 2>/dev/null || true
                        # Arrow keys - ignore for now, could add later
                    else
                        # ESC key - cancel
                        key="q"
                    fi
                fi
            else
                # No input or error
                key=""
            fi
            
            # Restore terminal settings
            [ -n "$old_stty" ] && stty "$old_stty" 2>/dev/null || true
            
            # Handle keypress
            case "$key" in
                n|N)
                    if [ $current_page -lt $total_pages ]; then
                        current_page=$((current_page + 1))
                        # Redraw page from cache (no re-fetch)
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        continue
                    else
                        echo -e "${YELLOW}Already on last page.${RESET}"
                        sleep 0.5
                        # Redraw to clear message
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                    fi
                    ;;
                p|P)
                    if [ $current_page -gt 1 ]; then
                        current_page=$((current_page - 1))
                        # Redraw page from cache (no re-fetch)
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        continue
                    else
                        echo -e "${YELLOW}Already on first page.${RESET}"
                        sleep 0.5
                        # Redraw to clear message
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                    fi
                    ;;
                q|Q|$'\033')
                    echo "Cancelled."
                    unset CATALOG_PAGE
                    cleanup_posters
                    return
                    ;;
                [0-9])
                    # Start collecting number input
                    number_input="$key"
                    # Read remaining digits (if any) with normal input mode
                    local old_stty2
                    old_stty2=$(stty -g 2>/dev/null) || true
                    stty icanon echo 2>/dev/null || true
                    echo -ne "${YELLOW}Enter selection: ${number_input}${RESET}"
                    while IFS= read -rsn1 -t 1 key2 2>/dev/null; do
                        if [[ "$key2" =~ [0-9] ]]; then
                            number_input="${number_input}${key2}"
                            echo -ne "$key2"
                        elif [ "$key2" = "" ] || [ "$key2" = $'\n' ] || [ "$key2" = $'\r' ]; then
                            # Enter pressed
                            break
                        elif [ "$key2" = $'\177' ] || [ "$key2" = $'\b' ]; then
                            # Backspace
                            if [ ${#number_input} -gt 1 ]; then
                                number_input="${number_input%?}"
                                echo -ne "\b \b"
                            fi
                        else
                            break
                        fi
                    done
                    [ -n "$old_stty2" ] && stty "$old_stty2" 2>/dev/null || true
                    echo
                    
                    selection="$number_input"
                    number_input=""
                    ;;
                *)
                    # Ignore other keys
                    continue
                    ;;
            esac
            
            # Handle numeric selection
            if [ -n "$selection" ] && [[ "$selection" =~ ^[0-9]+$ ]]; then
                if [ "$selection" -ge 1 ] && [ "$selection" -le "$total" ] 2>/dev/null; then
                    local selected_result
                    eval "selected_result=\"\${${cached_results_var}[$((selection - 1))]}\""
                    IFS='|' read -r source name magnet quality size extra poster_url <<< "$selected_result"
                    
                    # Validate magnet link
                    magnet=$(echo "$magnet" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    if [ -z "$magnet" ] || [[ ! "$magnet" =~ ^magnet: ]]; then
                        echo -e "${RED}Error:${RESET} Invalid or missing magnet link for selected torrent"
                        echo -e "${YELLOW}Debug info:${RESET}"
                        echo "  Source: $source"
                        echo "  Name: $name"
                        echo "  Magnet: '$magnet'"
                        sleep 2
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        selection=""
                        continue
                    fi
                    
                    # Debug output
                    if [ "$TORRENT_DEBUG" = true ]; then
                        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                        echo -e "${CYAN}DEBUG MODE${RESET}"
                        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                        echo -e "${YELLOW}Selected torrent:${RESET}"
                        echo "  Index: $selection"
                        echo "  Source: $source"
                        echo "  Name: $name"
                        echo "  Quality: $quality"
                        echo "  Size: $size"
                        echo -e "${YELLOW}Magnet link:${RESET}"
                        echo "  $magnet"
                        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                        echo
                    fi
                    
                    echo
                    echo -e "${GREEN}Streaming:${RESET} $name"
                    echo
                    
                    # Check dependencies before streaming
                    if [ -z "$TORRENT_TOOL" ]; then
                        check_deps
                    fi
                    
                    # Stream the selected torrent (subtitles auto-detected)
                    stream_torrent "$magnet" "" false false
                    local exit_code=$?
                    
                    # Exit code 2 means player closed normally - return to catalog
                    if [ $exit_code -eq 2 ]; then
                        # Player closed, return to catalog view
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        selection=""
                        continue
                    elif [ $exit_code -ne 0 ]; then
                        # Other error occurred
                        echo
                        echo -e "${YELLOW}Playback failed.${RESET}"
                        echo -e "${YELLOW}Would you like to search for alternative versions of \"$name\"? (y/n)${RESET} "
                        read -r answer
                        if [[ "$answer" =~ ^[Yy]$ ]]; then
                            # Clean up name for search
                            local search_query=$(echo "$name" | tr '.' ' ')
                            search_query=$(echo "$search_query" | sed -E 's/ (1080p|720p|4k|2160p|WEB-DL|BluRay|HDRip|x265|HEVC).*//i')
                            search_query=$(echo "$search_query" | sed -E 's/ \([0-9]{4}\)//')
                            
                            echo -e "${CYAN}Searching for: $search_query${RESET}"
                            search_torrent "$search_query"
                        fi
                        # Redraw catalog after search or if user said no
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        selection=""
                        continue
                    else
                        # Player exited normally (exit code 0) - also return to catalog
                        redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                        selection=""
                        continue
                    fi
                    
                    # Exit navigation loop after selection
                    break
                else
                    echo -e "${YELLOW}Invalid selection. Please enter a number between 1 and $total.${RESET}"
                    sleep 1
                    redraw_catalog_page "$title" "$cached_results_var" "$current_page" "$per_page" "$total"
                    selection=""
                fi
            fi
        done
        
        # Cleanup
        unset CATALOG_PAGE
        eval "unset ${cached_results_var}"
        cleanup_posters
    fi
}

# Unified search using Stremio-style APIs
search_torrent() {
    local query="$1"
    local all_results=()
    
    echo -e "${BOLD}${YELLOW}Searching for:${RESET} ${BOLD}$query${RESET}"
    echo
    
    # Search all sources (similar to how Stremio aggregates)
    # Collect results into array using process substitution
    {
        search_yts "$query" 2>/dev/null
        search_tpb "$query" 2>/dev/null
        search_eztv "$query" 2>/dev/null
        search_1337x "$query" 2>/dev/null
    } | while IFS= read -r line || [ -n "$line" ]; do
        if [ -n "$line" ] && [[ "$line" =~ \| ]]; then
            all_results+=("$line")
        fi
    done
    
    # Note: Due to pipe creating subshell, we need to use a different approach
    # Let's use a temp file instead and run searches in parallel with timeouts
    local temp_file=$(mktemp 2>/dev/null || echo "/tmp/torrent_$$")
    local search_pids=()
    
    # Run all searches in parallel (each has its own timeout via curl --max-time)
    (search_yts "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_ytsrs "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_tpb "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_eztv "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    (search_1337x "$query" 2>/dev/null || true) >> "$temp_file" &
    search_pids+=($!)
    
    # Wait for all searches to complete (max 10 seconds total)
    local wait_count=0
    while [ $wait_count -lt 20 ]; do
        local all_done=true
        for pid in "${search_pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                all_done=false
                break
            fi
        done
        if [ "$all_done" = true ]; then
            break
        fi
        sleep 0.5
        wait_count=$((wait_count + 1))
    done
    
    # Kill any remaining processes after timeout
    for pid in "${search_pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
    done
    wait "${search_pids[@]}" 2>/dev/null || true
    
    # Read results from temp file
    if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip empty lines and lines without pipe separator
            if [ -n "$line" ] && echo "$line" | grep -q '|'; then
                # Remove any trailing whitespace
                line=$(echo "$line" | sed 's/[[:space:]]*$//')
                all_results+=("$line")
            fi
        done < "$temp_file"
    fi
    
    rm -f "$temp_file" 2>/dev/null
    
    # Remove duplicates (same magnet link)
    if [ ${#all_results[@]} -gt 0 ]; then
        local unique_results=()
        local seen_hashes=()
        for result in "${all_results[@]}"; do
            IFS='|' read -r source name magnet quality size extra <<< "$result"
            # Extract hash from magnet link
            local hash=$(echo "$magnet" | grep -oE 'btih:[a-fA-F0-9]+' | cut -d: -f2 | tr '[:upper:]' '[:lower:]')
            if [ -n "$hash" ]; then
                # Check if we've seen this hash before
                local seen=false
                for seen_hash in "${seen_hashes[@]}"; do
                    if [ "$hash" = "$seen_hash" ]; then
                        seen=true
                        break
                    fi
                done
                if [ "$seen" = false ]; then
                    unique_results+=("$result")
                    seen_hashes+=("$hash")
                fi
            else
                # If no hash, just add it (shouldn't happen but be safe)
                unique_results+=("$result")
            fi
        done
        all_results=("${unique_results[@]}")
    fi
    
    if [ ${#all_results[@]} -eq 0 ]; then
        echo -e "${RED}No results found${RESET}"
        echo
        echo "Try:"
        echo "  - Check your internet connection"
        echo "  - Install jq: ${CYAN}brew install jq${RESET}"
        echo "  - Install python3: ${CYAN}brew install python3${RESET} (for YTSRS search)"
        echo "  - Try a different search query"
        echo "  - The search APIs may be temporarily unavailable"
        return 1
    fi
    
    # Display results
    echo -e "${BOLD}${GREEN}Found ${#all_results[@]} results:${RESET}\n"
    
    local index=0
    for result in "${all_results[@]}"; do
        if [ -z "$result" ]; then
            continue
        fi
        
        IFS='|' read -r source name magnet quality size <<< "$result"
        
        if [ -z "$name" ] || [ -z "$magnet" ]; then
            continue
        fi
        
        index=$((index + 1))
        
        local source_color="$CYAN"
        case "$source" in
            YTS) source_color="$GREEN" ;;
            TPB) source_color="$YELLOW" ;;
            EZTV) source_color="$BLUE" ;;
            1337x) source_color="$MAGENTA" ;;
        esac
        
        echo -e "${BOLD}[$index]${RESET} ${source_color}[$source]${RESET} ${BOLD}$name${RESET}"
        if [ "$quality" != "N/A" ] && [ -n "$quality" ] && [ "$quality" != "" ]; then
            echo -e "     Quality: $quality | Size: $size"
        fi
        echo -e "     ${CYAN}$magnet${RESET}"
        echo
    done
    
    # Interactive selection
    if [ -t 0 ]; then
        echo -e "${YELLOW}Select a torrent (1-$index) or press Enter to cancel:${RESET} "
        read -r selection
        
        if [ -n "$selection" ] && [ "$selection" -ge 1 ] && [ "$selection" -le "$index" ] 2>/dev/null; then
            local selected_result="${all_results[$((selection - 1))]}"
            IFS='|' read -r source name magnet quality size <<< "$selected_result"
            
            # Validate magnet link
            magnet=$(echo "$magnet" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [ -z "$magnet" ] || [[ ! "$magnet" =~ ^magnet: ]]; then
                echo -e "${RED}Error:${RESET} Invalid or missing magnet link for selected torrent"
                echo -e "${YELLOW}Debug info:${RESET}"
                echo "  Source: $source"
                echo "  Name: $name"
                echo "  Magnet: '$magnet'"
                exit 1
            fi
            
            # Debug output
            if [ "$TORRENT_DEBUG" = true ]; then
                echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                echo -e "${CYAN}DEBUG MODE${RESET}"
                echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                echo -e "${YELLOW}Selected torrent:${RESET}"
                echo "  Index: $selection"
                echo "  Source: $source"
                echo "  Name: $name"
                echo "  Quality: $quality"
                echo "  Size: $size"
                echo -e "${YELLOW}Magnet link:${RESET}"
                echo "  $magnet"
                echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                echo
            fi
            
            echo
            echo -e "${GREEN}Streaming:${RESET} $name"
            echo
            
            # Ensure dependencies are checked before streaming
            if [ -z "$TORRENT_TOOL" ]; then
                check_deps
            fi
            
            # Stream the selected torrent (subtitles auto-detected)
            stream_torrent "$magnet" "" false false
            local exit_code=$?
            
            # Exit code 2 means player closed normally - just return (search results don't have pagination to return to)
            if [ $exit_code -eq 2 ]; then
                # Player closed, just return
                return 0
            elif [ $exit_code -ne 0 ]; then
                # Other error occurred
                echo
                echo -e "${YELLOW}Playback failed.${RESET}"
                echo -e "${YELLOW}Would you like to search for alternative versions of \"$name\"? (y/n)${RESET} "
                read -r answer
                if [[ "$answer" =~ ^[Yy]$ ]]; then
                    # Clean up name for search
                    local search_query=$(echo "$name" | tr '.' ' ')
                    search_query=$(echo "$search_query" | sed -E 's/ (1080p|720p|4k|2160p|WEB-DL|BluRay|HDRip|x265|HEVC).*//i')
                    search_query=$(echo "$search_query" | sed -E 's/ \([0-9]{4}\)//')
                    
                    echo -e "${CYAN}Searching for: $search_query${RESET}"
                    search_torrent "$search_query"
                fi
            fi
        else
            echo "Cancelled."
        fi
    else
        echo -e "${YELLOW}Non-interactive mode. Use:${RESET}"
        echo "  torrent \"<magnet_link>\""
    fi
}

# Check if torrent has subtitle files and return info
has_subtitles() {
    local source="$1"
    
    # List files and check for subtitle extensions
    local file_list=$(peerflix "$source" --list 2>/dev/null || echo "")
    
    if [ -z "$file_list" ]; then
        return 1
    fi
    
    # Check for common subtitle file extensions and extract subtitle file names
    local subtitle_files=$(echo "$file_list" | grep -iE '\.(srt|vtt|ass|ssa|sub|idx)$' || echo "")
    
    if [ -n "$subtitle_files" ]; then
        # Count and list subtitle files found
        local sub_count=$(echo "$subtitle_files" | wc -l | tr -d ' ')
        echo -e "${GREEN}Subtitle found!${RESET} ($sub_count file(s))" >&2
        
        # Print subtitle file names (limit to first 3 to avoid clutter)
        echo "$subtitle_files" | head -3 | while IFS= read -r line; do
            if [ -n "$line" ]; then
                # Extract filename (usually the last part after spaces/tabs)
                # peerflix list format: "index  size  filename"
                local sub_file=$(echo "$line" | awk '{for(i=3;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//' 2>/dev/null || echo "$line")
                if [ -n "$sub_file" ]; then
                    echo -e "  ${CYAN}‚Üí${RESET} $sub_file" >&2
                fi
            fi
        done
        
        local total_subs=$(echo "$subtitle_files" | wc -l | tr -d ' ')
        if [ "$total_subs" -gt 3 ]; then
            local remaining=$((total_subs - 3))
            echo -e "  ${CYAN}... and $remaining more${RESET}" >&2
        fi
        
        return 0
    fi
    
    return 1
}

# Stream with peerflix - use peerflix's --subtitles flag properly
stream_peerflix() {
    local source="$1"
    local index="${2:-}"
    local enable_subtitles="${3:-false}"
    
    # Get player preference (will ask if first time, but with timeout to prevent hanging)
    local player=$(get_player_preference)
    
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo -e "${GREEN}Streaming with peerflix to $player...${RESET}"
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo
    
    # Validate source is a valid magnet link or file
    source=$(echo "$source" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    # Normalize magnet link: ensure hash is lowercase (peerflix may have issues with uppercase)
    if [[ "$source" =~ ^magnet: ]]; then
        # Extract and lowercase the hash
        local hash=$(echo "$source" | grep -oE 'btih:[a-fA-F0-9]+' | cut -d: -f2 | head -1)
        if [ -n "$hash" ]; then
            local hash_lower=$(echo "$hash" | tr '[:upper:]' '[:lower:]')
            # Replace uppercase hash with lowercase
            if [ "$hash" != "$hash_lower" ]; then
                 source="${source/btih:$hash/btih:$hash_lower}"
            fi
        fi
        # Ensure proper magnet link format
        if [[ ! "$source" =~ ^magnet:\?xt=urn:btih: ]]; then
            # Try to fix common issues
            source=$(echo "$source" | sed 's/^magnet:/magnet:?xt=urn:btih:/' | sed 's/btih:\([^&]*\)/btih:\1/')
        fi
        
        # Add common trackers if not present (helps peerflix connect to peers)
        # Some magnet links work with transmission but not peerflix because they lack trackers
        if ! echo "$source" | grep -q "&tr="; then
            local common_trackers=(
                "udp://tracker.openbittorrent.com:80/announce"
                "udp://tracker.opentrackr.org:1337/announce"
                "udp://tracker.coppersurfer.tk:6969/announce"
                "udp://tracker.leechers-paradise.org:6969/announce"
                "udp://tracker.internetwarriors.net:1337/announce"
                "udp://9.rarbg.to:2710/announce"
                "udp://9.rarbg.me:2710/announce"
                "udp://exodus.desync.com:6969/announce"
            )
            
            for tracker in "${common_trackers[@]}"; do
                # URL encode the tracker (magnet links need URL-encoded trackers)
                local encoded_tracker=$(echo "$tracker" | sed 's/:/%3A/g' | sed 's/\//%2F/g' | sed 's/ /%20/g')
                source="${source}&tr=${encoded_tracker}"
            done
        fi
    fi
    
    # Debug output
    if [ "$TORRENT_DEBUG" = true ]; then
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo -e "${CYAN}DEBUG: stream_peerflix${RESET}"
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo -e "${YELLOW}Source (raw):${RESET} '$source'"
        echo -e "${YELLOW}Source (cleaned):${RESET} '$(echo "$source" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')'"
        echo -e "${YELLOW}Source length:${RESET} ${#source} characters"
        echo -e "${YELLOW}Is magnet link:${RESET} $([[ "$source" =~ ^magnet: ]] && echo "yes" || echo "no")"
        echo -e "${YELLOW}Is file:${RESET} $([ -f "$source" ] && echo "yes" || echo "no")"
        if [[ "$source" =~ ^magnet: ]]; then
            local hash_debug=$(echo "$source" | grep -oE 'btih:[a-fA-F0-9]+' | cut -d: -f2 | head -1)
            echo -e "${YELLOW}Magnet hash:${RESET} $hash_debug"
            echo -e "${YELLOW}Normalized magnet:${RESET} $source"
        fi
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo
    fi
    
    if [[ ! "$source" =~ ^magnet: ]] && [ ! -f "$source" ]; then
        echo -e "${RED}Error:${RESET} Invalid torrent source: '$source'"
        echo -e "${YELLOW}Expected:${RESET} magnet link (magnet:?xt=...) or path to .torrent file"
        return 1
    fi
    
    local args=("-p" "0")
    
    if [ -n "$index" ]; then
        args+=("-i" "$index")
    fi
    
    # Add quiet flag to reduce verbose output
    args+=("-q")
    
    # Check for subtitles and find the subtitle file path
    local subtitle_file=""
    if [ "$enable_subtitles" = true ] || has_subtitles "$source" >/dev/null 2>&1; then
        echo -e "${CYAN}Checking for subtitles in torrent...${RESET}"
        
        # We need to get the torrent path first to find subtitle files
        # Run peerflix briefly to get the path, then restart with subtitles
        local temp_output=$(mktemp 2>/dev/null || echo "/tmp/peerflix_output_$$")
        
        # Start peerflix briefly to get the path (without auto-launch)
        # This will start downloading the torrent files including subtitles
        peerflix "$source" "${args[@]}" > "$temp_output" 2>&1 &
        local temp_pid=$!
        
        # Wait for peerflix to start and show the path
        echo -e "${YELLOW}Waiting for peerflix to initialize and start downloading...${RESET}"
        sleep 3
        
        # Extract the path from peerflix output
        local torrent_path=""
        local max_wait=15
        local waited=0
        while [ $waited -lt $max_wait ]; do
            if [ -f "$temp_output" ]; then
                # Try multiple patterns to find the path
                torrent_path=$(grep "info path" "$temp_output" 2>/dev/null | head -1 | sed 's/.*info path //' | tr -d '\r\n')
                
                # If not found, try looking for path patterns in the output
                if [ -z "$torrent_path" ]; then
                    torrent_path=$(grep -iE "(path|downloaded|stream)" "$temp_output" 2>/dev/null | grep -oE "/tmp/[^[:space:]]+" | head -1)
                fi
                
                if [ -n "$torrent_path" ] && [ -d "$torrent_path" ]; then
                    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    echo -e "${GREEN}‚úì TORRENT PATH FOUND:${RESET}"
                    echo -e "${CYAN}$torrent_path${RESET}"
                    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    echo
                    echo -e "${YELLOW}You can manually verify subtitle files with:${RESET}"
                    echo -e "${CYAN}ls -la \"$torrent_path\"${RESET}"
                    echo -e "${CYAN}find \"$torrent_path\" -name '*.srt'${RESET}"
                    echo
                    break
                fi
            fi
            sleep 1
            waited=$((waited + 1))
        done
        
        # If still not found, show the raw output for debugging
        if [ -z "$torrent_path" ] || [ ! -d "$torrent_path" ]; then
            echo -e "${YELLOW}Warning:${RESET} Could not extract torrent path from peerflix output"
            echo -e "${YELLOW}Peerflix output (last 20 lines):${RESET}"
            tail -20 "$temp_output" 2>/dev/null | while IFS= read -r line; do
                echo "  $line"
            done
        fi
        
        # Wait a bit more for files to actually download (especially subtitle files)
        # Search recursively for subtitle files
        if [ -n "$torrent_path" ] && [ -d "$torrent_path" ]; then
            echo -e "${YELLOW}Waiting for subtitle files to download...${RESET}"
            echo -e "${CYAN}Searching recursively in:${RESET} $torrent_path"
            echo
            
            local download_wait=0
            local max_download_wait=15  # Increased wait time
            
            while [ $download_wait -lt $max_download_wait ]; do
                # List all files in the directory for debugging (recursively)
                if [ $download_wait -eq 0 ] || [ $((download_wait % 3)) -eq 0 ]; then
                    echo -e "${YELLOW}Files in torrent (attempt $((download_wait + 1))):${RESET}"
                    find "$torrent_path" -type f 2>/dev/null | head -10 | while IFS= read -r file; do
                        if [ -n "$file" ]; then
                            local fname=$(basename "$file")
                            local fsize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                            local rel_path="${file#$torrent_path/}"
                            echo -e "  ${CYAN}‚Üí${RESET} $fname (${fsize} bytes) [${rel_path}]"
                        fi
                    done
                    echo
                fi
                
                # Check if any subtitle files exist and have content (search recursively)
                local found_sub=$(find "$torrent_path" -type f -iname "*.srt" 2>/dev/null | head -1)
                if [ -z "$found_sub" ]; then
                    found_sub=$(find "$torrent_path" -type f \( -iname "*.vtt" -o -iname "*.ass" -o -iname "*.ssa" \) 2>/dev/null | head -1)
                fi
                
                if [ -n "$found_sub" ] && [ -f "$found_sub" ] && [ -s "$found_sub" ]; then
                    # File exists and has content - it's downloaded
                    subtitle_file=$(realpath "$found_sub" 2>/dev/null || echo "$found_sub")
                    local file_size=$(stat -f%z "$subtitle_file" 2>/dev/null || stat -c%s "$subtitle_file" 2>/dev/null || echo "0")
                    
                    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    echo -e "${GREEN}‚úì SRT FOUND!${RESET}"
                    echo -e "  ${CYAN}File:${RESET} $(basename "$subtitle_file")"
                    echo -e "  ${CYAN}Location:${RESET} $subtitle_file"
                    echo -e "  ${CYAN}Size:${RESET} ${file_size} bytes"
                    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    break
                fi
                
                sleep 1
                download_wait=$((download_wait + 1))
            done
            
            if [ -z "$subtitle_file" ]; then
                echo -e "${YELLOW}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                echo -e "${YELLOW}‚ö† NO SUBTITLE FILE FOUND${RESET}"
                echo -e "${YELLOW}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                echo -e "${YELLOW}Torrent path:${RESET} $torrent_path"
                echo -e "${YELLOW}All files in torrent (recursive):${RESET}"
                find "$torrent_path" -type f 2>/dev/null | while IFS= read -r file; do
                    local rel_path="${file#$torrent_path/}"
                    echo -e "  ${CYAN}‚Üí${RESET} $rel_path"
                done
                echo
            fi
        fi
        
        # Kill the temp peerflix process
        echo -e "${YELLOW}Stopping temporary peerflix instance...${RESET}"
        kill $temp_pid 2>/dev/null || true
        wait $temp_pid 2>/dev/null || true
        sleep 1  # Give it a moment to clean up
        
        rm -f "$temp_output" 2>/dev/null
    fi
    
    # Don't use peerflix auto-launch - play file directly from local directory
    # Start peerflix in background to download files
    # Note: Remove -q temporarily to get path info, or check output more carefully
    local temp_output=$(mktemp 2>/dev/null || echo "/tmp/peerflix_output_$$")
    local peerflix_pid
    
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo -e "${YELLOW}Starting peerflix to download torrent files...${RESET}"
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    # Remove quiet flag temporarily to see path output (we need "info path" line)
    local temp_args=()
    for arg in "${args[@]}"; do
        if [ "$arg" != "-q" ]; then
            temp_args+=("$arg")
        fi
    done
    peerflix "$source" "${temp_args[@]}" > "$temp_output" 2>&1 &
    peerflix_pid=$!
    
    # Check if peerflix started successfully (wait a moment, then check if process is still running)
    sleep 2
    if ! kill -0 "$peerflix_pid" 2>/dev/null; then
        # Process died - check error output
        if [ -f "$temp_output" ]; then
            local error_output=$(cat "$temp_output" 2>/dev/null)
            if echo "$error_output" | grep -q "Invalid data\|Missing delimiter\|parse-torrent\|bencode\|Error\|Failed"; then
                echo -e "${RED}Error:${RESET} peerflix failed to handle this magnet link"
                echo ""
                
                # Automatically use transmission-cli as fallback if available
                if command -v transmission-cli &> /dev/null; then
                    echo -e "${CYAN}Switching to transmission-cli fallback...${RESET}"
                    echo ""
                    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    echo -e "${CYAN}Streaming with transmission-cli...${RESET}"
                    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    echo ""
                    
                    # Extract hash from magnet link to create unique subdirectory
                    local torrent_hash=""
                    if [[ "$source" =~ ^magnet: ]]; then
                        torrent_hash=$(echo "$source" | grep -oE 'btih:[a-fA-F0-9]+' | cut -d: -f2 | tr '[:upper:]' '[:lower:]' | head -1)
                    fi
                    
                    # If no hash found (shouldn't happen for magnet links), use a timestamp-based hash
                    if [ -z "$torrent_hash" ]; then
                        torrent_hash=$(echo "$source" | shasum -a 256 | cut -d' ' -f1 | cut -c1-40)
                    fi
                    
                    # Create hash-based subdirectory for this specific torrent (easier to search files)
                    local base_dir="/tmp/torrent-stream"
                    local download_dir="$base_dir/$torrent_hash"
                    mkdir -p "$download_dir" 2>/dev/null
                    
                    # Get player preference
                    local player=$(get_player_preference)
                    
                    echo -e "${CYAN}Download directory:${RESET} $download_dir"
                    echo -e "${CYAN}Torrent hash:${RESET} $torrent_hash"
                    echo -e "${CYAN}Player:${RESET} $player"
                    echo -e "${YELLOW}Note:${RESET} It may take a while to connect to peers and start downloading..."
                    echo ""
                    
                    # Capture transmission output to parse progress
                    local transmission_output=$(mktemp 2>/dev/null || echo "/tmp/transmission_output_$$")
                    
                    # Record start time to filter out old files from previous downloads
                    local start_time=$(date +%s)
                    
                    # Run transmission-cli with --download-dir flag using hash-based subdirectory
                    # Use --download-dir explicitly to ensure it's used (transmission-cli may have config file defaults)
                    # Note: transmission-cli may create subdirectories within the download directory
                    # We'll search recursively to find the actual video files
                    # Check for transmission config and temporarily override download directory if needed
                    local transmission_config="$HOME/.config/transmission/settings.json"
                    local config_backup=""
                    local original_download_dir=""
                    
                    if [ -f "$transmission_config" ]; then
                        # Backup the config file
                        config_backup=$(mktemp 2>/dev/null || echo "/tmp/transmission_config_backup_$$.json")
                        cp "$transmission_config" "$config_backup" 2>/dev/null
                        
                        # Read current download-dir setting
                        if command -v jq &> /dev/null; then
                            original_download_dir=$(jq -r '.["download-dir"] // empty' "$transmission_config" 2>/dev/null)
                            
                            # Temporarily set download-dir to our hash-based directory
                            jq --arg dir "$download_dir" '.["download-dir"] = $dir' "$transmission_config" > "${transmission_config}.tmp" 2>/dev/null && \
                                mv "${transmission_config}.tmp" "$transmission_config" 2>/dev/null
                        elif command -v python3 &> /dev/null; then
                            # Fallback to Python if jq is not available
                            python3 << EOF 2>/dev/null
import json
import sys
try:
    with open("$transmission_config", 'r') as f:
        config = json.load(f)
    original_download_dir = config.get('download-dir', '')
    config['download-dir'] = '$download_dir'
    with open("$transmission_config", 'w') as f:
        json.dump(config, f, indent=4)
    print(original_download_dir)
except:
    pass
EOF
                            original_download_dir=$(python3 -c "import json; f=open('$transmission_config'); d=json.load(f); print(d.get('download-dir', ''))" 2>/dev/null || echo "")
                        else
                            # Fallback: use sed to modify JSON (less reliable but works for simple cases)
                            original_download_dir=$(grep -oE '"download-dir"[[:space:]]*:[[:space:]]*"[^"]*"' "$transmission_config" 2>/dev/null | cut -d'"' -f4 || echo "")
                            # Escape the directory path for sed
                            local escaped_dir=$(echo "$download_dir" | sed 's/[[\.*^$()+?{|]/\\&/g')
                            sed -i.bak "s|\"download-dir\"[[:space:]]*:[[:space:]]*\"[^\"]*\"|\"download-dir\": \"$escaped_dir\"|g" "$transmission_config" 2>/dev/null
                            rm -f "${transmission_config}.bak" 2>/dev/null
                        fi
                        
                        echo -e "${CYAN}Note:${RESET} Temporarily overriding transmission config download directory"
                    fi
                    
                    transmission-cli --download-dir "$download_dir" "$source" > "$transmission_output" 2>&1 &
                    local transmission_pid=$!
                    
                    # Wait a moment for transmission-cli to start and check if it's still running
                    sleep 2
                    
                    # Verify the download directory exists and is writable
                    if [ ! -d "$download_dir" ] || [ ! -w "$download_dir" ]; then
                        echo -e "${YELLOW}Warning:${RESET} Download directory may not be accessible: $download_dir"
                        echo -e "${CYAN}Creating directory...${RESET}"
                        mkdir -p "$download_dir" 2>/dev/null || {
                            echo -e "${RED}Error:${RESET} Cannot create download directory"
                            kill $transmission_pid 2>/dev/null || true
                            # Restore original transmission config if we modified it
                            if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                                cp "$config_backup" "$transmission_config" 2>/dev/null
                                rm -f "$config_backup" 2>/dev/null
                            fi
                            rm -f "$transmission_output" 2>/dev/null
                            rm -f "$temp_output" 2>/dev/null
                            return 1
                        }
                    fi
                    
                    # Check if transmission-cli process is still running
                    if ! kill -0 "$transmission_pid" 2>/dev/null; then
                        echo -e "${RED}Error:${RESET} transmission-cli failed to start"
                        if [ -f "$transmission_output" ]; then
                            echo -e "${YELLOW}Transmission output:${RESET}"
                            cat "$transmission_output" | head -20
                        fi
                        # Restore original transmission config if we modified it
                        if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                            cp "$config_backup" "$transmission_config" 2>/dev/null
                            rm -f "$config_backup" 2>/dev/null
                        fi
                        rm -f "$transmission_output" 2>/dev/null
                        rm -f "$temp_output" 2>/dev/null
                        return 1
                    fi
                    
                    # Check for immediate errors in output
                    if [ -f "$transmission_output" ]; then
                        local error_check=$(grep -iE "(error|failed|cannot|unable)" "$transmission_output" 2>/dev/null | head -3)
                        if [ -n "$error_check" ]; then
                            echo -e "${YELLOW}Warning:${RESET} Possible errors detected:"
                            echo "$error_check" | while IFS= read -r line; do
                                echo -e "  ${YELLOW}‚Üí${RESET} $line"
                            done
                            echo ""
                        fi
                    fi
                    
                    echo -e "${GREEN}Transmission started (PID: $transmission_pid)${RESET}"
                    echo -e "${CYAN}Connecting to peers and downloading metadata...${RESET}"
                    echo -e "${CYAN}This typically takes 8-30 seconds depending on tracker response.${RESET}"
                    echo ""
                    
                    # Wait a bit for transmission to recognize the torrent and start downloading
                    # Based on user testing: ~4s to recognize torrent, ~8s to show progress
                    echo -e "${CYAN}Waiting for transmission to initialize...${RESET}"
                    sleep 5
                    
                    # Wait for video file to appear - transmission-cli takes time to connect to peers
                    # Increased timeout significantly: 5 minutes (600 iterations * 0.5s)
                    # User testing shows ~32s total startup time, so 5 minutes is safe
                    local video_file=""
                    local video_wait=0
                    local max_video_wait=600  # 5 minutes * 60 / 0.5
                    
                    # Also check if transmission process is still running during the wait
                    
                    while [ $video_wait -lt $max_video_wait ]; do
                        # Find the largest video file in the hash-specific directory
                        # This ensures we only find files from this specific torrent
                        video_file=$(find "$download_dir" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.mov" -o -iname "*.webm" -o -iname "*.m4v" \) 2>/dev/null | \
                            while IFS= read -r file; do
                                if [ -f "$file" ] && [ -s "$file" ]; then
                                    # Check if file was modified after transmission started
                                    # Use modification time (mtime) - on macOS use stat -f %m, on Linux use stat -c %Y
                                    local file_mtime=$(stat -f %m "$file" 2>/dev/null || stat -c %Y "$file" 2>/dev/null || echo "0")
                                    
                                    # Only consider files created/modified after transmission started
                                    # Allow 2 seconds buffer for file system timing
                                    if [ "$file_mtime" -ge $((start_time - 2)) ]; then
                                        local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                                        echo "$size|$file"
                                    fi
                                fi
                            done | sort -t'|' -k1 -rn | head -1 | cut -d'|' -f2)
                        
                        if [ -n "$video_file" ] && [ -f "$video_file" ] && [ -s "$video_file" ]; then
                            local file_size=$(stat -f%z "$video_file" 2>/dev/null || stat -c%s "$video_file" 2>/dev/null || echo "0")
                            if [ "$file_size" -gt 1048576 ]; then  # 1MB minimum
                                break
                            fi
                        fi
                        
                        local spin_idx=$((video_wait % 4))
                        case $spin_idx in
                            0) local spin_char='|' ;;
                            1) local spin_char='/' ;;
                            2) local spin_char='-' ;;
                            3) local spin_char='\' ;;
                        esac
                        # Show progress with elapsed time (every 0.5 seconds = 2 iterations per second)
                        local elapsed_secs=$((video_wait / 2))
                        printf "\r${CYAN}Waiting for video file...${RESET} [%c] (%ds)" "$spin_char" "$elapsed_secs"
                        
                        # Check if transmission process is still running
                            if ! kill -0 "$transmission_pid" 2>/dev/null; then
                                echo ""
                                echo -e "${RED}Error:${RESET} transmission-cli process died unexpectedly"
                                if [ -f "$transmission_output" ]; then
                                    echo -e "${YELLOW}Last transmission output:${RESET}"
                                    tail -30 "$transmission_output" | while IFS= read -r line; do
                                        echo "  $line"
                                    done
                                fi
                                # Restore original transmission config if we modified it
                                if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                                    cp "$config_backup" "$transmission_config" 2>/dev/null
                                    rm -f "$config_backup" 2>/dev/null
                                fi
                                rm -f "$transmission_output" 2>/dev/null
                                rm -f "$temp_output" 2>/dev/null
                                return 1
                            fi
                        
                        sleep 0.5
                        video_wait=$((video_wait + 1))
                    done
                    
                    if [ -z "$video_file" ] || [ ! -f "$video_file" ]; then
                        echo ""
                        echo -e "${RED}Error:${RESET} Could not find video file after 5 minutes"
                        
                        # Check if transmission is still running
                        if ! kill -0 "$transmission_pid" 2>/dev/null; then
                            echo -e "${YELLOW}Transmission process is not running.${RESET}"
                            if [ -f "$transmission_output" ]; then
                                echo -e "${YELLOW}Transmission output:${RESET}"
                                tail -50 "$transmission_output" | while IFS= read -r line; do
                                    echo "  $line"
                                done
                            fi
                        else
                            echo -e "${CYAN}Transmission is still running. Checking download directory...${RESET}"
                            echo -e "${CYAN}Directory:${RESET} $download_dir"
                            if [ -d "$download_dir" ]; then
                                echo -e "${CYAN}Files in directory:${RESET}"
                                find "$download_dir" -type f 2>/dev/null | head -10 | while IFS= read -r file; do
                                    if [ -n "$file" ]; then
                                        local fname=$(basename "$file")
                                        local fsize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                                        echo "  ‚Üí $fname (${fsize} bytes)"
                                    fi
                                done
                            else
                                echo -e "${YELLOW}Directory does not exist:${RESET} $download_dir"
                            fi
                            
                            # Show recent transmission output
                            if [ -f "$transmission_output" ]; then
                                echo ""
                                echo -e "${CYAN}Recent transmission output:${RESET}"
                                tail -20 "$transmission_output" | while IFS= read -r line; do
                                    echo "  $line"
                                done
                            fi
                        fi
                        
                        kill $transmission_pid 2>/dev/null || true
                        # Restore original transmission config if we modified it
                        if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                            cp "$config_backup" "$transmission_config" 2>/dev/null
                            rm -f "$config_backup" 2>/dev/null
                        fi
                        rm -f "$transmission_output" 2>/dev/null
                        rm -f "$temp_output" 2>/dev/null
                        return 1
                    fi
                    
                    local video_path=$(realpath "$video_file" 2>/dev/null || echo "$video_file")
                    local video_dir=$(dirname "$video_path")
                    local video_name=$(basename "$video_path")
                    
                    echo ""
                    echo -e "${GREEN}‚úì Video file found:${RESET} $video_name"
                    echo ""
                    
                    # Wait for buffer (10% progress or 50MB, whichever comes first)
                    echo -e "${CYAN}Buffering video (waiting for 10% progress)...${RESET}"
                    local target_progress=10  # 10% progress
                    local target_buffer_size=52428800  # 50MB fallback
                    local buffer_wait=0
                    local max_buffer_wait=300  # 5 minutes max
                    local last_size=0
                    local current_progress=0
                    local connected_peers=0
                    local total_peers=0
                    local download_speed=""
                    
                    while [ $buffer_wait -lt $max_buffer_wait ]; do
                        # Parse progress from transmission output
                        if [ -f "$transmission_output" ]; then
                            # Look for "Progress: X.X%" pattern
                            local progress_line=$(grep "Progress:" "$transmission_output" 2>/dev/null | tail -1)
                            if [ -n "$progress_line" ]; then
                                # Extract percentage: "Progress: 18.0%" -> 18.0
                                current_progress=$(echo "$progress_line" | grep -oE "Progress: [0-9]+\.[0-9]+%" | grep -oE "[0-9]+\.[0-9]+" | head -1)
                                # Extract peers: "dl from 18 of 49 peers" -> 18 and 49
                                local peer_match=$(echo "$progress_line" | grep -oE "dl from [0-9]+ of [0-9]+ peers" 2>/dev/null)
                                if [ -n "$peer_match" ]; then
                                    connected_peers=$(echo "$peer_match" | grep -oE "[0-9]+" | head -1)
                                    total_peers=$(echo "$peer_match" | grep -oE "[0-9]+" | tail -1)
                                fi
                                # Extract download speed: "(1.38 MB/s)" or "(3.63 MB/s)"
                                download_speed=$(echo "$progress_line" | grep -oE "\([0-9]+\.[0-9]+ [A-Z]+/s\)" | head -1)
                            fi
                        fi
                        
                        # Also check file size as fallback
                        local current_size=$(stat -f%z "$video_path" 2>/dev/null || stat -c%s "$video_path" 2>/dev/null || echo "0")
                        
                        # Show progress
                        if [ -n "$current_progress" ] && [ "$current_progress" != "0" ]; then
                            local progress_int=$(echo "$current_progress" | cut -d. -f1)
                            
                            local width=20
                            local filled=$((progress_int * width / 100))
                            if [ "$filled" -gt "$width" ]; then
                                filled=$width
                            fi
                            
                            local bar=""
                            local i=0
                            while [ $i -lt $filled ]; do
                                bar="${bar}üü©"
                                i=$((i + 1))
                            done
                            while [ $i -lt $width ]; do
                                bar="${bar}‚¨ú"
                                i=$((i + 1))
                            done
                            
                            local progress_display="${current_progress}%"
                            if [ -n "$download_speed" ]; then
                                progress_display="${progress_display} $download_speed"
                            fi
                            if [ "$total_peers" -gt 0 ]; then
                                progress_display="${progress_display} (${connected_peers}/${total_peers} peers)"
                            fi
                            
                            printf "\r${CYAN}Buffering:${RESET} %s %s " "$bar" "$progress_display"
                            
                            # Check if we have 10% progress
                            if [ "$progress_int" -ge "$target_progress" ]; then
                                echo ""
                                echo -e "${GREEN}‚úì Buffer ready (${current_progress}% progress)${RESET}"
                                if [ "$total_peers" -gt 0 ]; then
                                    echo -e "${CYAN}Connected to ${connected_peers}/${total_peers} peers${RESET}"
                                fi
                                break
                            fi
                        elif [ "$current_size" -gt 0 ]; then
                            # Fallback to size-based buffering if progress not available
                            local progress_percent=$((current_size * 100 / target_buffer_size))
                            if [ $progress_percent -gt 100 ]; then
                                progress_percent=100
                            fi
                            
                            local width=20
                            local filled=$((progress_percent * width / 100))
                            if [ "$filled" -gt "$width" ]; then
                                filled=$width
                            fi
                            
                            local bar=""
                            local i=0
                            while [ $i -lt $filled ]; do
                                bar="${bar}üü©"
                                i=$((i + 1))
                            done
                            while [ $i -lt $width ]; do
                                bar="${bar}‚¨ú"
                                i=$((i + 1))
                            done
                            
                            printf "\r${CYAN}Buffering:${RESET} %s %d%% (${current_size} bytes) " "$bar" "$progress_percent"
                            
                            # Check if we have enough buffer
                            if [ "$current_size" -ge $target_buffer_size ]; then
                                echo ""
                                echo -e "${GREEN}‚úì Buffer ready (${current_size} bytes)${RESET}"
                                break
                            fi
                            
                            # Check if stalled but have minimum buffer
                            if [ "$current_size" -eq "$last_size" ] && [ "$current_size" -gt 0 ]; then
                                if [ "$current_size" -ge 20971520 ]; then  # 20MB minimum
                                    echo ""
                                    echo -e "${YELLOW}‚ö† Proceeding with available buffer (${current_size} bytes)${RESET}"
                                    break
                                fi
                            fi
                        else
                            printf "\r${CYAN}Buffering...${RESET} [0%%]"
                        fi
                        
                        last_size=$current_size
                        sleep 1
                        buffer_wait=$((buffer_wait + 1))
                    done
                    echo ""
                    
                    # Find subtitle file (same logic as peerflix)
                    local subtitle_file=""
                    local subtitle_arg=""
                    
                    if [ "$enable_subtitles" = true ] || has_subtitles "$source" >/dev/null 2>&1; then
                        echo -e "${CYAN}Searching for subtitle file...${RESET}"
                        
                        # Search for subtitle files in the same directory as video
                        subtitle_file=$(find "$video_dir" -type f \( -iname "*.srt" -o -iname "*.vtt" -o -iname "*.ass" -o -iname "*.ssa" \) 2>/dev/null | head -1)
                        
                        if [ -n "$subtitle_file" ] && [ -f "$subtitle_file" ]; then
                            local sub_abs=$(realpath "$subtitle_file" 2>/dev/null || echo "$subtitle_file")
                            local sub_name=$(basename "$sub_abs")
                            local sub_dir=$(dirname "$sub_abs")
                            
                            echo -e "${GREEN}‚úì Subtitle found:${RESET} $sub_name"
                            
                            if [ "$sub_dir" = "$video_dir" ]; then
                                subtitle_arg="$sub_name"
                            else
                                subtitle_arg="$sub_abs"
                            fi
                        fi
                    fi
                    
                    # Launch player (same as peerflix)
                    echo ""
                    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    echo -e "${GREEN}Launching $player from local directory...${RESET}"
                    echo -e "  ${CYAN}Directory:${RESET} $video_dir"
                    echo -e "  ${CYAN}Video:${RESET} $video_name"
                    if [ -n "$subtitle_arg" ]; then
                        echo -e "  ${CYAN}Subtitle:${RESET} $subtitle_arg"
                    fi
                    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    echo ""
                    
                    local player_pid=""
                    cd "$video_dir" || {
                        echo -e "${RED}Error:${RESET} Could not change to video directory"
                        kill $transmission_pid 2>/dev/null || true
                        # Restore original transmission config if we modified it
                        if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                            cp "$config_backup" "$transmission_config" 2>/dev/null
                            rm -f "$config_backup" 2>/dev/null
                        fi
                        rm -f "$transmission_output" 2>/dev/null
                        rm -f "$temp_output" 2>/dev/null
                        return 1
                    }
                    
                    if [ "$player" = "vlc" ]; then
                        if [ -n "$subtitle_arg" ]; then
                            vlc "$video_name" --sub-file="$subtitle_arg" >/dev/null 2>&1 &
                        else
                            vlc "$video_name" >/dev/null 2>&1 &
                        fi
                        player_pid=$!
                    else
                        # mpv
                        local mpv_args=("$video_name")
                        if [ -n "$subtitle_arg" ]; then
                            mpv_args+=("--sub-file=$subtitle_arg")
                            mpv_args+=("--sid=1")
                            mpv_args+=("--sub-visibility=yes")
                        fi
                        mpv "${mpv_args[@]}" >/dev/null 2>&1 &
                        player_pid=$!
                    fi
                    
                    if [ -z "$player_pid" ] || ! kill -0 "$player_pid" 2>/dev/null; then
                        echo -e "${RED}Error:${RESET} Failed to launch player"
                        kill $transmission_pid 2>/dev/null || true
                        # Restore original transmission config if we modified it
                        if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                            cp "$config_backup" "$transmission_config" 2>/dev/null
                            rm -f "$config_backup" 2>/dev/null
                        fi
                        rm -f "$transmission_output" 2>/dev/null
                        rm -f "$temp_output" 2>/dev/null
                        return 1
                    fi
                    
                    echo -e "${CYAN}Player started (PID: $player_pid). Transmission running (PID: $transmission_pid)${RESET}"
                    echo ""
                    
                    # Monitor player (same as peerflix)
                    local player_running=true
                    local check_count=0
                    
                    trap 'echo -e "\n${YELLOW}Interrupted. Stopping transmission...${RESET}"; kill $transmission_pid 2>/dev/null || true; kill $player_pid 2>/dev/null || true; if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then cp "$config_backup" "$transmission_config" 2>/dev/null; rm -f "$config_backup" 2>/dev/null; fi; rm -f "$transmission_output" 2>/dev/null; return 2' INT TERM
                    
                    while [ "$player_running" = true ]; do
                        local player_processes=""
                        if [ "$player" = "vlc" ]; then
                            player_processes=$(pgrep -i "vlc" 2>/dev/null | head -1 || echo "")
                            if [ -z "$player_processes" ]; then
                                player_processes=$(ps aux | grep -i "[V]LC" | grep -v grep | awk '{print $2}' | head -1 || echo "")
                            fi
                        else
                            player_processes=$(pgrep "mpv" 2>/dev/null | head -1 || echo "")
                        fi
                        
                        if [ -z "$player_processes" ]; then
                            sleep 1
                            if [ "$player" = "vlc" ]; then
                                player_processes=$(pgrep -i "vlc" 2>/dev/null | head -1 || echo "")
                            else
                                player_processes=$(pgrep "mpv" 2>/dev/null | head -1 || echo "")
                            fi
                            
                            if [ -z "$player_processes" ]; then
                                player_running=false
                                break
                            fi
                        fi
                        
                        sleep 1
                        check_count=$((check_count + 1))
                        
                        if [ $check_count -gt 600 ]; then
                            echo -e "${YELLOW}Warning:${RESET} Monitoring timeout, stopping transmission anyway"
                            player_running=false
                            break
                        fi
                    done
                    
                    trap - INT TERM
                    
                    # Player closed, stop transmission
                    echo -e "${CYAN}Player closed. Stopping transmission...${RESET}"
                    kill $transmission_pid 2>/dev/null || true
                    sleep 1
                    kill -9 $transmission_pid 2>/dev/null || true
                    wait $transmission_pid 2>/dev/null &>/dev/null || true
                    
                    # Restore original transmission config if we modified it
                    if [ -n "$config_backup" ] && [ -f "$config_backup" ]; then
                        cp "$config_backup" "$transmission_config" 2>/dev/null
                        rm -f "$config_backup" 2>/dev/null
                        echo -e "${CYAN}Restored transmission config${RESET}"
                    fi
                    
                    rm -f "$transmission_output" 2>/dev/null
                    rm -f "$temp_output" 2>/dev/null
                    return 2  # Return to catalog
                else
                    # transmission-cli not available, show error and exit
                    echo -e "${RED}Error:${RESET} peerflix failed and transmission-cli is not installed"
                    echo ""
                    echo "Please install transmission-cli:"
                    echo "  ${GREEN}brew install transmission-cli${RESET}"
                    rm -f "$temp_output" 2>/dev/null
                    return 1
                fi
                
                echo -e "${CYAN}Solutions:${RESET}"
                echo "  1. Try selecting a different torrent from the list"
                if ! command -v transmission-cli &> /dev/null; then
                    echo "  2. Install transmission-cli for download fallback:"
                    echo "     ${GREEN}brew install transmission-cli${RESET}"
                    echo "     Then use: ${GREEN}transmission-cli --download-dir \"/tmp/torrent-stream\" \"$source\"${RESET}"
                fi
                echo "  3. Use webtorrent (if installed):"
                echo "     ${GREEN}webtorrent \"$source\" --mpv${RESET}"
                echo "  4. Or add to transmission-daemon:"
                echo "     ${GREEN}transmission-remote -a \"$source\"${RESET}"
                echo -e "${RED}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                rm -f "$temp_output" 2>/dev/null
                return 1
            fi
        fi
    fi
    
    # Wait for peerflix to start and show the path
    sleep 4
    
    # Extract the torrent path from peerflix output
    local torrent_path=""
        local max_wait=125 # 25 seconds * 5
        local waited=0
    
        echo -e "${CYAN}Waiting for peerflix to show torrent path...${RESET}"
        while [ $waited -lt $max_wait ]; do
            if [ -f "$temp_output" ] && [ -s "$temp_output" ]; then
                # Read the file content (handle potential buffering)
                local output_content=$(cat "$temp_output" 2>/dev/null)
                
                # Try multiple patterns to find the path - "info path" followed by path
                # Pattern: "info path /tmp/torrent-stream/..."
                torrent_path=$(echo "$output_content" | grep "info path" 2>/dev/null | head -1 | sed -E 's/.*info path[[:space:]]+//' | awk '{print $1}' | tr -d '\r\n')
                
                # If not found, try extracting from "info path" line more carefully
                if [ -z "$torrent_path" ]; then
                    torrent_path=$(echo "$output_content" | grep "info path" 2>/dev/null | head -1 | awk '{for(i=3;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//' | awk '{print $1}')
                fi
                
                # Try finding /tmp/torrent-stream/ pattern (more flexible regex)
                if [ -z "$torrent_path" ]; then
                    torrent_path=$(echo "$output_content" | grep -oE "/tmp/torrent-stream/[a-zA-Z0-9]+" "$temp_output" 2>/dev/null | head -1)
                fi
                
                # Try finding any /tmp path after "info path"
                if [ -z "$torrent_path" ]; then
                    torrent_path=$(echo "$output_content" | grep "info path" 2>/dev/null | grep -oE "/tmp/[^[:space:]]+" | head -1)
                fi
                
                # Verify it's a directory
                if [ -n "$torrent_path" ] && [ -d "$torrent_path" ]; then
                    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    echo -e "${GREEN}‚úì TORRENT PATH:${RESET}"
                    echo -e "${CYAN}$torrent_path${RESET}"
                    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
                    break
                fi
            fi
            # Show spinner
            local spin_idx=$((waited % 4))
            case $spin_idx in
                0) local spin_char='|' ;;
                1) local spin_char='/' ;;
                2) local spin_char='-' ;;
                3) local spin_char='\' ;;
            esac
            printf "\r${CYAN}Waiting for torrent path...${RESET} [%c]" "$spin_char"
            
            sleep 0.2
            waited=$((waited + 1))
            if [ $((waited % 15)) -eq 0 ]; then
                printf "\r${YELLOW}Still waiting... ($((waited / 5))s)${RESET}    \n"
                # Show what we've found so far for debugging
                if [ -f "$temp_output" ] && [ -s "$temp_output" ]; then
                    local found_line=$(grep "info path" "$temp_output" 2>/dev/null | head -1)
                    if [ -n "$found_line" ]; then
                        echo -e "${CYAN}Found 'info path' line:${RESET} $found_line"
                        # Try to extract path from this line
                        local test_path=$(echo "$found_line" | sed -E 's/.*info path[[:space:]]+//' | awk '{print $1}')
                        if [ -n "$test_path" ]; then
                            echo -e "${CYAN}Extracted path:${RESET} $test_path"
                            if [ -d "$test_path" ]; then
                                echo -e "${GREEN}Path exists and is a directory!${RESET}"
                                torrent_path="$test_path"
                                break
                            else
                                echo -e "${YELLOW}Path does not exist yet or is not a directory${RESET}"
                            fi
                        fi
                    fi
                fi
            fi
        done
    
    # If still not found, show debug output
    if [ -z "$torrent_path" ] || [ ! -d "$torrent_path" ]; then
        echo -e "${RED}Error:${RESET} Could not determine torrent path"
        echo -e "${YELLOW}Peerflix output for debugging:${RESET}"
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        if [ -f "$temp_output" ]; then
            cat "$temp_output" 2>/dev/null | tail -30
        else
            echo "  (no output file found)"
        fi
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        kill $peerflix_pid 2>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        return 1
    fi
    
    # Wait for video file to be available (search recursively)
    # Give peerflix time to start downloading files first
    echo -e "${CYAN}Waiting for files to download...${RESET}"
    sleep 3  # Give peerflix time to create directory structure and start downloading
    
    echo -e "${CYAN}Searching for video file...${RESET}"
    local video_file=""
    local video_wait=0
    local max_video_wait=150  # 30 seconds * 5
    
    while [ $video_wait -lt $max_video_wait ]; do
        # First, check if directory exists and has any files at all
        if [ ! -d "$torrent_path" ]; then
            sleep 0.2
            video_wait=$((video_wait + 1))
            continue
        fi
        
        # List all files first to see what we have
        local all_files=$(find "$torrent_path" -type f 2>/dev/null)
        if [ -z "$all_files" ]; then
            # No files yet, wait longer
            local spin_idx=$((video_wait % 4))
            case $spin_idx in
                0) local spin_char='|' ;;
                1) local spin_char='/' ;;
                2) local spin_char='-' ;;
                3) local spin_char='\' ;;
            esac
            printf "\r${CYAN}Waiting for files to download...${RESET} [%c] ($((video_wait / 5))s)" "$spin_char"
            sleep 0.2
            video_wait=$((video_wait + 1))
            continue
        fi
        
        # Debug: show what files we found
        if [ "$TORRENT_DEBUG" = true ] && [ $((video_wait % 25)) -eq 0 ]; then
            echo ""
            echo -e "${CYAN}Files found so far:${RESET}"
            echo "$all_files" | head -5 | while IFS= read -r file; do
                if [ -n "$file" ]; then
                    local rel_path="${file#$torrent_path/}"
                    local fsize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                    echo -e "  ${CYAN}‚Üí${RESET} $rel_path (${fsize} bytes)"
                fi
            done
            echo ""
        fi
        
        # Find the largest video file recursively (usually the main movie file)
        # Use find to get all video files, then sort by size
        video_file=$(find "$torrent_path" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.mov" -o -iname "*.webm" -o -iname "*.m4v" -o -iname "*.flv" -o -iname "*.wmv" \) 2>/dev/null | \
            while IFS= read -r file; do
                if [ -f "$file" ] && [ -s "$file" ]; then
                    local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                    echo "$size|$file"
                fi
            done | sort -t'|' -k1 -rn | head -1 | cut -d'|' -f2)
        
        if [ -n "$video_file" ] && [ -f "$video_file" ] && [ -s "$video_file" ]; then
            # Check if file is large enough (at least 1MB) to be a real video
            local file_size=$(stat -f%z "$video_file" 2>/dev/null || stat -c%s "$video_file" 2>/dev/null || echo "0")
            if [ "$file_size" -gt 1048576 ]; then  # 1MB
                printf "\r${GREEN}‚úì Video file found${RESET}\n"
                break
            fi
        fi
        
        # Show spinner
        local spin_idx=$((video_wait % 4))
        case $spin_idx in
            0) local spin_char='|' ;;
            1) local spin_char='/' ;;
            2) local spin_char='-' ;;
            3) local spin_char='\' ;;
        esac
        printf "\r${CYAN}Searching for video file...${RESET} [%c] ($((video_wait / 5))s)" "$spin_char"
        
        sleep 0.2
        video_wait=$((video_wait + 1))
    done
    
    if [ -z "$video_file" ] || [ ! -f "$video_file" ]; then
        echo ""
        echo -e "${RED}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo -e "${RED}Error:${RESET} Could not find video file in torrent"
        echo -e "${RED}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo -e "${YELLOW}Torrent path:${RESET} $torrent_path"
        echo ""
        echo -e "${YELLOW}Directory structure:${RESET}"
        ls -la "$torrent_path" 2>/dev/null | head -20 || echo "  (directory listing failed)"
        echo ""
        echo -e "${YELLOW}All files found (recursive):${RESET}"
        local found_any=false
        find "$torrent_path" -type f 2>/dev/null | while IFS= read -r file; do
            if [ -n "$file" ]; then
                found_any=true
                local rel_path="${file#$torrent_path/}"
                local fsize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                local fname=$(basename "$file")
                echo -e "  ${CYAN}‚Üí${RESET} $rel_path"
                echo -e "    ${YELLOW}Size:${RESET} ${fsize} bytes | ${YELLOW}Name:${RESET} $fname"
            fi
        done
        if [ "$found_any" = false ]; then
            echo -e "  ${YELLOW}(no files found - torrent may still be downloading)${RESET}"
            echo ""
            echo -e "${CYAN}Note:${RESET} This torrent may not have any video files, or files are still downloading."
            echo -e "${CYAN}Try:${RESET} Wait a moment and try again, or check the torrent contents manually."
        fi
        echo -e "${RED}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        kill $peerflix_pid 2>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        return 1
    fi
    
    local video_path=$(realpath "$video_file" 2>/dev/null || echo "$video_file")
    local video_dir=$(dirname "$video_path")
    local video_name=$(basename "$video_path")
    
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo -e "${GREEN}‚úì Video file found:${RESET} $video_name"
    echo -e "${CYAN}Video directory:${RESET} $video_dir"
    echo -e "${CYAN}Full path:${RESET} $video_path"
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo
    
    # Buffer video before starting player (wait for 3-4 minutes of content)
    # Estimate: assume average bitrate of 2-3 Mbps for 1080p, so 3-4 minutes = ~45-60 MB
    # We'll wait for at least 50MB to be downloaded
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo -e "${CYAN}Buffering video...${RESET}"
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    local target_buffer_size=52428800  # 50MB (3-4 minutes at ~2Mbps)
    local buffer_wait=0
    local max_buffer_wait=300  # 5 minutes max wait
    local last_size=0
    local stalled_count=0
    local connected_peers=0
    local total_peers=0
    
    while [ $buffer_wait -lt $max_buffer_wait ]; do
        if [ ! -f "$video_path" ]; then
            sleep 1
            buffer_wait=$((buffer_wait + 1))
            continue
        fi
        
        local current_size=$(stat -f%z "$video_path" 2>/dev/null || stat -c%s "$video_path" 2>/dev/null || echo "0")
        
        # Extract peer information from peerflix output
        if [ -f "$temp_output" ] && [ -s "$temp_output" ]; then
            local peer_info=$(grep "info streaming" "$temp_output" 2>/dev/null | tail -1)
            if [ -n "$peer_info" ]; then
                # Extract "from X/Y peers" pattern: "info streaming ... from 5/10 peers"
                # Pattern can be: "from 5/10 peers" or "from 5/10"
                local peer_match=$(echo "$peer_info" | grep -oE "from [0-9]+/[0-9]+" 2>/dev/null | head -1)
                if [ -n "$peer_match" ]; then
                    # Extract connected peers (first number)
                    connected_peers=$(echo "$peer_match" | sed -E 's/from ([0-9]+)\/[0-9]+/\1/' 2>/dev/null)
                    # Extract total peers (second number)
                    total_peers=$(echo "$peer_match" | sed -E 's/from [0-9]+\/([0-9]+)/\1/' 2>/dev/null)
                fi
            fi
        fi
        
        # Check if file is growing (not stalled)
        if [ "$current_size" -eq "$last_size" ] && [ "$current_size" -gt 0 ]; then
            stalled_count=$((stalled_count + 1))
            if [ $stalled_count -gt 10 ]; then
                # File hasn't grown in 10 seconds, might be stalled or complete
                # If we have enough buffer, proceed anyway
                if [ "$current_size" -ge $target_buffer_size ]; then
                    break
                fi
            fi
        else
            stalled_count=0
        fi
        
        last_size=$current_size
        
        # Show progress with peer information
        if [ "$current_size" -gt 0 ]; then
            # Calculate progress as percentage of target buffer
            local progress_percent=$((current_size * 100 / target_buffer_size))
            if [ $progress_percent -gt 100 ]; then
                progress_percent=100
            fi
            
            # Build progress bar
            local width=20
            local filled=$((progress_percent * width / 100))
            if [ "$filled" -gt "$width" ]; then
                filled=$width
            fi
            
            local bar=""
            local i=0
            while [ $i -lt $filled ]; do
                bar="${bar}üü©"
                i=$((i + 1))
            done
            while [ $i -lt $width ]; do
                bar="${bar}‚¨ú"
                i=$((i + 1))
            done
            
            # Show peers if available, otherwise show percentage
            if [ "$total_peers" -gt 0 ]; then
                printf "\r${CYAN}Buffering:${RESET} %s %d%% (%d/%d peers) " "$bar" "$progress_percent" "$connected_peers" "$total_peers"
            else
                printf "\r${CYAN}Buffering:${RESET} %s %d%% " "$bar" "$progress_percent"
            fi
        else
            if [ "$total_peers" -gt 0 ]; then
                printf "\r${CYAN}Buffering...${RESET} [0%%] (%d/%d peers) " "$connected_peers" "$total_peers"
            else
                printf "\r${CYAN}Buffering...${RESET} [0%%]"
            fi
        fi
        
        # If we have enough buffer, proceed
        if [ "$current_size" -ge $target_buffer_size ]; then
            echo ""  # New line after progress bar
            echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
            echo -e "${GREEN}‚úì Buffer ready (${current_size} bytes)${RESET}"
            if [ "$total_peers" -gt 0 ]; then
                echo -e "${CYAN}Connected to ${connected_peers}/${total_peers} peers${RESET}"
            fi
            echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
            break
        fi
        
        sleep 1
        buffer_wait=$((buffer_wait + 1))
    done
    
    # Final check
    local final_size=$(stat -f%z "$video_path" 2>/dev/null || stat -c%s "$video_path" 2>/dev/null || echo "0")
    if [ "$final_size" -lt $target_buffer_size ]; then
        echo ""  # New line after progress bar
        echo -e "${YELLOW}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo -e "${YELLOW}‚ö† Warning:${RESET} Buffer not fully ready (${final_size} bytes), but proceeding..."
        if [ "$total_peers" -gt 0 ]; then
            echo -e "${CYAN}Connected to ${connected_peers}/${total_peers} peers${RESET}"
        fi
        echo -e "${YELLOW}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    fi
    echo
    
    # Prepare subtitle file path (relative to video file directory)
    local subtitle_arg=""
    if [ -n "$subtitle_file" ] && [ -f "$subtitle_file" ]; then
        local sub_abs=$(realpath "$subtitle_file" 2>/dev/null || echo "$subtitle_file")
        local sub_name=$(basename "$sub_abs")
        local sub_dir=$(dirname "$sub_abs")
        
        echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo -e "${GREEN}‚úì SRT File Found:${RESET} $sub_abs"
        echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
        echo
        
        # Check if subtitle is in the same directory as video
        if [ "$sub_dir" = "$video_dir" ]; then
            # Same directory - use relative path (just filename)
            subtitle_arg="$sub_name"
        else
            # Different directory - use absolute path
            subtitle_arg="$sub_abs"
        fi
    fi
    
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo -e "${GREEN}Launching $player from local directory...${RESET}"
    echo -e "  ${CYAN}Directory:${RESET} $video_dir"
    echo -e "  ${CYAN}Video:${RESET} $video_name"
    if [ -n "$subtitle_arg" ]; then
        echo -e "  ${CYAN}Subtitle:${RESET} $subtitle_arg"
    fi
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${RESET}"
    echo
    
    # Launch player from the video directory
    local player_pid=""
    cd "$video_dir" || {
        echo -e "${RED}Error:${RESET} Could not change to video directory"
        kill $peerflix_pid 2>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        return 1
    }
    
    if [ "$player" = "vlc" ]; then
        if [ -n "$subtitle_arg" ]; then
            echo -e "${YELLOW}Command:${RESET} vlc \"$video_name\" --sub-file=\"$subtitle_arg\""
            vlc "$video_name" --sub-file="$subtitle_arg" >/dev/null 2>&1 &
            player_pid=$!
        else
            vlc "$video_name" >/dev/null 2>&1 &
            player_pid=$!
        fi
    else
        # mpv
        local mpv_args=("$video_name")
        if [ -n "$subtitle_arg" ]; then
            echo -e "${YELLOW}Command:${RESET} mpv \"$video_name\" --sub-file=\"$subtitle_arg\" --sid=1 --sub-visibility=yes"
            mpv_args+=("--sub-file=$subtitle_arg")
            mpv_args+=("--sid=1")
            mpv_args+=("--sub-visibility=yes")
        fi
        mpv "${mpv_args[@]}" >/dev/null 2>&1 &
        player_pid=$!
    fi
    
    if [ -z "$player_pid" ] || ! kill -0 "$player_pid" 2>/dev/null; then
        echo -e "${RED}Error:${RESET} Failed to launch player"
        kill $peerflix_pid 2>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        return 1
    fi
    
    echo -e "${CYAN}Player started (PID: $player_pid). Peerflix running (PID: $peerflix_pid)${RESET}"
    echo
    
    # Monitor player process - VLC/mpv may fork, so we need to check by process name
    # Use a trap to handle Ctrl+C gracefully
    cleanup_and_exit() {
        echo -e "\n${YELLOW}Interrupted. Stopping peerflix...${RESET}"
        kill $peerflix_pid 2>/dev/null || true
        sleep 1
        kill -9 $peerflix_pid 2>/dev/null || true
        wait $peerflix_pid 2>/dev/null &>/dev/null || true
        rm -f "$temp_output" 2>/dev/null
        exit 0
    }
    trap cleanup_and_exit INT TERM
    
    # Wait a moment for the process to potentially fork (especially VLC)
    sleep 2
    
    # Monitor player by checking if any player process is running
    # Escape the video name for use in pgrep
    local escaped_video_name=$(echo "$video_name" | sed 's/[[\.*^$()+?{|]/\\&/g')
    local player_running=true
    local check_count=0
    
    while [ "$player_running" = true ]; do
        # Check if any player process is running (by name, not just PID)
        # This handles cases where VLC/mpv fork and the original PID exits
        local player_processes=""
        if [ "$player" = "vlc" ]; then
            # Check for VLC processes - VLC on macOS might be "VLC" or "vlc" or in an app bundle
            # Try multiple methods: pgrep, ps, and check if video file is open
            player_processes=$(pgrep -i "vlc" 2>/dev/null | head -1 || echo "")
            if [ -z "$player_processes" ]; then
                # Try ps to find VLC (might be case-sensitive)
                player_processes=$(ps aux | grep -i "[V]LC" | grep -v grep | awk '{print $2}' | head -1 || echo "")
            fi
            # Also check if video file is open (lsof on macOS)
            if [ -z "$player_processes" ] && command -v lsof &> /dev/null; then
                local open_by=$(lsof "$video_path" 2>/dev/null | grep -i vlc | head -1 || echo "")
                if [ -n "$open_by" ]; then
                    player_processes="open"  # Mark as running
                fi
            fi
        else
            # Check for mpv processes
            player_processes=$(pgrep "mpv" 2>/dev/null | head -1 || echo "")
            if [ -z "$player_processes" ] && command -v lsof &> /dev/null; then
                local open_by=$(lsof "$video_path" 2>/dev/null | grep -i mpv | head -1 || echo "")
                if [ -n "$open_by" ]; then
                    player_processes="open"  # Mark as running
                fi
            fi
        fi
        
        # If no player processes found, player has exited
        if [ -z "$player_processes" ]; then
            # Double-check: wait a moment and check again (in case of brief process switch)
            sleep 1
            if [ "$player" = "vlc" ]; then
                player_processes=$(pgrep -i "vlc" 2>/dev/null | head -1 || echo "")
                if [ -z "$player_processes" ]; then
                    player_processes=$(ps aux | grep -i "[V]LC" | grep -v grep | awk '{print $2}' | head -1 || echo "")
                fi
            else
                player_processes=$(pgrep "mpv" 2>/dev/null | head -1 || echo "")
            fi
            
            if [ -z "$player_processes" ]; then
                player_running=false
                break
            fi
        fi
        
        # Player still running, continue monitoring
        sleep 1
        check_count=$((check_count + 1))
        
        # Safety: if we've been checking for too long (10 minutes), break
        if [ $check_count -gt 600 ]; then
            echo -e "${YELLOW}Warning:${RESET} Monitoring timeout, stopping peerflix anyway"
            player_running=false
            break
        fi
    done
    
    # Clear the trap
    trap - INT TERM
    
    # Player exited, kill peerflix
    echo -e "${CYAN}Player closed. Stopping peerflix...${RESET}"
    kill $peerflix_pid 2>/dev/null || true
    sleep 1
    kill -9 $peerflix_pid 2>/dev/null || true
    wait $peerflix_pid 2>/dev/null &>/dev/null || true
    
    rm -f "$temp_output" 2>/dev/null
    
    # Return special exit code to indicate player closed (not an error)
    # This allows the calling code to return to catalog view
    return 2
}


# Main streaming function
stream_torrent() {
    local source="$1"
    local index="${2:-}"
    local list_only="${3:-false}"
    local enable_subtitles="${4:-false}"
    
    # Validate source (must be magnet link or file path)
    if [ -z "$source" ]; then
        echo -e "${RED}Error:${RESET} No torrent source provided"
        return 1
    fi
    
    # Clean up source (remove whitespace, newlines)
    source=$(echo "$source" | tr -d '\r\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    # Check if it's a magnet link or file path
    if [[ ! "$source" =~ ^magnet: ]] && [ ! -f "$source" ]; then
        echo -e "${RED}Error:${RESET} Invalid torrent source: '$source'"
        echo -e "${YELLOW}Expected:${RESET} magnet link (magnet:?xt=...) or path to .torrent file"
        return 1
    fi
    
    # Ensure TORRENT_TOOL is set (should always be peerflix now)
    if [ -z "$TORRENT_TOOL" ]; then
        check_deps
    fi
    
    # Only use peerflix
    if [ "$list_only" = true ]; then
        peerflix "$source" --list
    else
        stream_peerflix "$source" "$index" "$enable_subtitles"
    fi
}

# Auto-select best quality
select_best_quality() {
    local source="$1"
    
    echo -e "${YELLOW}Analyzing available files...${RESET}"
    
    # List files and find the largest video file
    # Use peerflix to list files
    local file_list=$(peerflix "$source" --list 2>/dev/null || echo "")
    
    if [ -z "$file_list" ]; then
        echo -e "${YELLOW}Could not list files, playing default...${RESET}"
        return 0
    fi
    
    # Find video files and select the largest one
    local best_file=$(echo "$file_list" | grep -iE '\.(mp4|mkv|avi|mov|webm|m4v)' | \
        awk '{print $1, $2}' | sort -k2 -rn | head -1 | awk '{print $1}')
    
    if [ -n "$best_file" ]; then
        echo -e "${GREEN}Selected best quality file (index $best_file)${RESET}"
        echo "$best_file"
    else
        echo -e "${YELLOW}No video files found, using default...${RESET}"
        echo "0"
    fi
}

# Global debug flag
TORRENT_DEBUG=false

# Main function
main() {
    local source=""
    local index=""
    local list_only=false
    local search_mode=false
    local auto_quality=false
    local enable_subtitles=false
    local args=("$@")
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -l|--list)
                list_only=true
                shift
                ;;
            -i|--index)
                index="$2"
                shift 2
                ;;
            -q|--quality)
                auto_quality=true
                shift
                ;;
            -s|--subtitles)
                enable_subtitles=true
                shift
                ;;
            -v|--verbose)
                set -x
                shift
                ;;
            --debug)
                TORRENT_DEBUG=true
                export TORRENT_DEBUG
                shift
                ;;
            player)
                # Change player preference
                if [ -z "$2" ]; then
                    echo -e "${RED}Error:${RESET} Please specify a player (mpv or vlc)"
                    echo "Usage: termflix player <mpv|vlc>"
                    exit 1
                fi
                local new_player="$2"
                if [[ "$new_player" =~ ^(mpv|vlc)$ ]]; then
                    init_termflix_dirs
                    local config_file=$(get_termflix_config_file)
                    echo "PLAYER=$new_player" > "$config_file"
                    echo -e "${GREEN}Player preference changed to:${RESET} $new_player"
                    echo -e "${CYAN}Config saved to:${RESET} $config_file"
                    exit 0
                else
                    echo -e "${RED}Error:${RESET} Invalid player. Use 'mpv' or 'vlc'"
                    exit 1
                fi
                ;;
            search)
                search_mode=true
                shift
                ;;
            *)
                if [ -z "$source" ]; then
                    source="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Wrapper functions for YTSRS (defined before use)
    get_ytsrs_latest_wrapper() {
        get_ytsrs_movies "" "1080p" "year" "$1" "$2"
    }
    get_ytsrs_trending_wrapper() {
        get_ytsrs_movies "" "1080p" "seeds" "$1" "$2"
    }
    get_ytsrs_popular_wrapper() {
        get_ytsrs_movies "" "1080p" "rating" "$1" "$2"
    }
    get_ytsrs_genre_wrapper() {
        local genre="$1"
        shift
        get_ytsrs_movies "$genre" "1080p" "seeds" "$1" "$2"
    }
    
    # Filter args for routing (remove --debug)
    local routing_args=()
    for arg in "${args[@]}"; do
        [[ "$arg" != "--debug" ]] && routing_args+=("$arg")
    done
    
    # Handle catalog modes FIRST (doesn't need streaming tool)
    case "${routing_args[0]}" in
        latest)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # Show results from both TPB and YTSRS
                    display_catalog "üé¨ Latest Movies" get_latest_movies 25 get_ytsrs_latest_wrapper 25
                    ;;
                shows)
                    display_catalog "üì∫ Latest TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "üé¨ Latest Movies & Shows" get_latest_movies 15 get_ytsrs_latest_wrapper 15 get_latest_shows 20
                    ;;
            esac
            exit $?
            ;;
        trending)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # Show results from both TPB and YTSRS
                    display_catalog "üî• Trending Movies" get_trending_movies 25 get_ytsrs_trending_wrapper 25
                    ;;
                shows)
                    display_catalog "üî• Trending TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "üî• Trending Content" get_trending_movies 15 get_ytsrs_trending_wrapper 15 get_latest_shows 20
                    ;;
            esac
            exit $?
            ;;
        popular)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # Show results from both TPB and YTSRS
                    display_catalog "‚≠ê Popular Movies" get_popular_movies 25 get_ytsrs_popular_wrapper 25
                    ;;
                shows)
                    display_catalog "‚≠ê Popular TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "‚≠ê Popular Content" get_popular_movies 15 get_ytsrs_popular_wrapper 15 get_latest_shows 20
                    ;;
            esac
            exit $?
            ;;
        catalog)
            check_jq
            local genre="${routing_args[1]:-}"
            if [ -z "$genre" ]; then
                echo -e "${BOLD}Available Genres:${RESET}"
                echo "  action, adventure, animation, comedy, crime, documentary,"
                echo "  drama, family, fantasy, horror, mystery, romance,"
                echo "  sci-fi, thriller, war, western"
                echo
                echo "Usage: torrent catalog <genre>"
                exit 1
            fi
            # Show results from both YTS/TPB and YTSRS
            # Create genre-specific wrapper
            eval "get_ytsrs_${genre}_wrapper() {
                get_ytsrs_movies \"$genre\" \"1080p\" \"seeds\" \"\$1\" \"\$2\"
            }"
            display_catalog "üìö $genre Movies" get_catalog_by_genre "$genre" 25 "get_ytsrs_${genre}_wrapper" 25
            exit $?
            ;;
        search)
            check_jq
            local query="${routing_args[1]:-}"
            if [ -z "$query" ]; then
                echo -e "${RED}Error:${RESET} Please provide a search query"
                echo "Usage: termflix search <query>"
                exit 1
            fi
            search_torrent "$query"
            exit $?
            ;;
    esac
    
    # If we get here and no source, default to "latest all"
    if [ -z "$source" ] && [ "$list_only" = false ] && [ "$search_mode" = false ]; then
        # Default behavior: show latest movies and shows
        check_jq
        display_catalog "üé¨ Latest Movies & Shows" get_latest_movies 15 get_ytsrs_latest_wrapper 15 get_latest_shows 20
        exit $?
    fi
    
    # Check dependencies for streaming (only needed when actually streaming)
    check_deps
    check_jq
    
    # Get source from clipboard if not provided
    if [ -z "$source" ]; then
        if command -v pbpaste &> /dev/null; then
            # BSD grep compatible (no -P flag)
            source=$(pbpaste | grep -oE 'magnet:\?[^[:space:]]+' | head -1)
            if [ -n "$source" ]; then
                echo -e "${GREEN}Using magnet link from clipboard${RESET}"
            fi
        fi
        
        if [ -z "$source" ]; then
            echo -e "${RED}Error:${RESET} No magnet link or torrent file provided"
            echo "Usage: termflix <magnet_link|torrent_file>"
            echo "   or: termflix --help"
            exit 1
        fi
    fi
    
    # Handle auto-quality selection
    if [ "$auto_quality" = true ] && [ -z "$index" ]; then
        index=$(select_best_quality "$source")
    fi
    
    # Stream the torrent
    stream_torrent "$source" "$index" "$list_only" "$enable_subtitles"
}

# Run main function
# Run main function if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
