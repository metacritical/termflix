#!/usr/bin/env bash
#
# Termflix - Torrent Streaming Tool - Stream torrents directly to mpv/vlc
# Usage: termflix [command] or termflix <magnet_link|torrent_file>
#

# Don't exit on error - we handle errors gracefully
set +e
# Suppress job control messages (like "Terminated: 15")
set +H 2>/dev/null || true

# Cleanup function for poster images and temp files
cleanup_on_exit() {
    # Kill background jobs
    jobs -p | xargs kill 2>/dev/null || true
    
    # Cleanup temp files
    rm -f /tmp/termflix_poster_* 2>/dev/null
    rm -f /tmp/termflix_search_* 2>/dev/null
    rm -rf /tmp/termflix_posters_* 2>/dev/null
    rm -f /tmp/torrent_* 2>/dev/null
    
    # Reset terminal
    tput cnorm 2>/dev/null || true
}
trap cleanup_on_exit EXIT INT TERM

# Resolve script directory (works even when called via PATH or symlinks)
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
TERMFLIX_SCRIPTS_DIR="$SCRIPT_DIR/scripts"
export TERMFLIX_SCRIPTS_DIR

# ============================================================
# MODULE LOADING
# ============================================================

# Core Modules
source "$SCRIPT_DIR/modules/core/colors.sh"
source "$SCRIPT_DIR/modules/core/config.sh"
source "$SCRIPT_DIR/modules/core/deps.sh"

# UI Modules
source "$SCRIPT_DIR/modules/ui/status.sh"

source "$SCRIPT_DIR/modules/ui/help.sh"
source "$SCRIPT_DIR/modules/ui/fzf_catalog.sh"

# Feature Modules
source "$SCRIPT_DIR/modules/posters.sh"
source "$SCRIPT_DIR/modules/search.sh"
source "$SCRIPT_DIR/modules/catalog.sh"
source "$SCRIPT_DIR/modules/torrent.sh"

# Initialize directories
init_termflix_dirs

# Export API keys for external scripts (required for get_poster.py)
export TMDB_API_KEY=$(get_tmdb_api_key)
export TMDB_READ_TOKEN=$(get_tmdb_read_token)
export OMDB_API_KEY=$(config_get "OMDB_API_KEY" "")

# ============================================================
# COMPATIBILITY & HELPERS
# ============================================================

# Wrapper for check_all_deps that sets TORRENT_TOOL global
check_deps() {
    check_all_deps
    TORRENT_TOOL=$(check_torrent_client)
    export TORRENT_TOOL
}
export -f check_deps

# Global debug flag
TORRENT_DEBUG=false

# ============================================================
# MAIN FUNCTION
# ============================================================

main() {
    local source=""
    local index=""
    local list_only=false
    local search_mode=false
    local auto_quality=false
    local enable_subtitles=false
    local args=("$@")
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -l|--list)
                list_only=true
                shift
                ;;
            -i|--index)
                index="$2"
                shift 2
                ;;
            -q|--quality)
                auto_quality=true
                shift
                ;;
            -s|--subtitles)
                enable_subtitles=true
                shift
                ;;
            -v|--verbose)
                set -x
                shift
                ;;
            --debug)
                TORRENT_DEBUG=true
                export TORRENT_DEBUG
                shift
                ;;
            -g|--grid)
                USE_GUM_MODE=true
                export USE_GUM_MODE
                shift
                ;;
            --clear)
                local cache_dir="$HOME/.config/termflix/cache"
                if [ -d "$cache_dir" ]; then
                    local deleted_count=$(find "$cache_dir" -name "catalog_*.txt" -type f | wc -l | tr -d ' ')
                    rm -rf "$cache_dir"/catalog_*.txt 2>/dev/null
                    if [ "$deleted_count" -gt 0 ]; then
                        echo -e "${GREEN}‚úì Cleared ${deleted_count} cache file(s)${RESET}"
                    else
                        echo -e "${YELLOW}No cache files found to clear${RESET}"
                    fi
                else
                    echo -e "${YELLOW}Cache directory does not exist${RESET}"
                fi
                exit 0
                ;;
            player)
                # Change player preference
                if [ -z "$2" ]; then
                    echo -e "${RED}Error:${RESET} Please specify a player (mpv or vlc)"
                    echo "Usage: termflix player <mpv|vlc>"
                    exit 1
                fi
                local new_player="$2"
                if [[ "$new_player" =~ ^(mpv|vlc)$ ]]; then
                    init_termflix_dirs
                    local config_file=$(get_termflix_config_file)
                    echo "PLAYER=$new_player" > "$config_file"
                    echo -e "${GREEN}Player preference changed to:${RESET} $new_player"
                    echo -e "${CYAN}Config saved to:${RESET} $config_file"
                    exit 0
                else
                    echo -e "${RED}Error:${RESET} Invalid player. Use 'mpv' or 'vlc'"
                    exit 1
                fi
                ;;
            search)
                search_mode=true
                shift
                ;;
            *)
                if [ -z "$source" ]; then
                    source="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Wrapper functions for YTSRS (defined before use)
    get_ytsrs_latest_wrapper() {
        get_ytsrs_movies "" "1080p" "year" "$1" "$2"
    }
    get_ytsrs_trending_wrapper() {
        get_ytsrs_movies "" "1080p" "seeds" "$1" "$2"
    }
    get_ytsrs_popular_wrapper() {
        get_ytsrs_movies "" "1080p" "rating" "$1" "$2"
    }
    get_ytsrs_genre_wrapper() {
        local genre="$1"
        shift
        get_ytsrs_movies "$genre" "1080p" "seeds" "$1" "$2"
    }
    
    # Filter args for routing (remove --debug)
    local routing_args=()
    for arg in "${args[@]}"; do
        [[ "$arg" != "--debug" ]] && routing_args+=("$arg")
    done
    
    # Handle catalog modes FIRST (doesn't need streaming tool)
    case "${routing_args[0]}" in
        latest)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # TPB only - YTS disabled
                    display_catalog "üé¨ Latest Movies" get_latest_movies 50
                    ;;
                shows)
                    display_catalog "üì∫ Latest TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "üé¨ Latest Movies" get_latest_movies 50
                    ;;
            esac
            exit $?
            ;;
        trending)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # TPB only - YTS disabled
                    display_catalog "üî• Trending Movies" get_latest_movies 50
                    ;;
                shows)
                    display_catalog "üî• Trending TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "üî• Trending Content" get_latest_movies 50
                    ;;
            esac
            exit $?
            ;;
        popular)
            check_jq
            local type="${routing_args[1]:-all}"
            case "$type" in
                movies)
                    # TPB only - YTS disabled
                    display_catalog "‚≠ê Popular Movies" get_latest_movies 50
                    ;;
                shows)
                    display_catalog "‚≠ê Popular TV Shows" get_latest_shows 50
                    ;;
                all|*)
                    display_catalog "‚≠ê Popular Content" get_latest_movies 50
                    ;;
            esac
            exit $?
            ;;
        catalog)
            check_jq
            local genre="${routing_args[1]:-}"
            if [ -z "$genre" ]; then
                echo -e "${BOLD}Available Genres:${RESET}"
                echo "  action, adventure, animation, comedy, crime, documentary,"
                echo "  drama, family, fantasy, horror, mystery, romance,"
                echo "  sci-fi, thriller, war, western"
                echo
                echo "Usage: torrent catalog <genre>"
                exit 1
            fi
            # TPB only - YTS disabled for genre search
            display_catalog "üìö $genre Movies" get_latest_movies 50
            exit $?
            ;;
        search)
            check_jq
            local query="${routing_args[1]:-}"
            if [ -z "$query" ]; then
                echo -e "${RED}Error:${RESET} Please provide a search query"
                echo "Usage: termflix search <query>"
                exit 1
            fi
            search_torrent "$query"
            exit $?
            ;;
    esac
    
    # If we get here and no source, default to "latest movies" with category switching
    if [ -z "$source" ] && [ "$list_only" = false ] && [ "$search_mode" = false ]; then
        check_jq
        
        # Category switching loop - NEW DESIGN
        local current_category="movies"
        local current_sort="latest"
        local current_genre=""
        local current_min_rating=0
        local current_query=""
        
        while true; do
            # Export context for fetch functions
            export CURRENT_GENRE="$current_genre"
            export CURRENT_MIN_RATING="$current_min_rating"
            export CURRENT_QUERY="$current_query"
            
            # Map sort friendly name to API sort key if needed
            case "$current_sort" in
                 latest)   export CURRENT_SORT="date_added" ;;
                 trending) export CURRENT_SORT="download_count" ;;
                 popular)  export CURRENT_SORT="rating" ;;
                 seeds)    export CURRENT_SORT="seeds" ;; # "peers"
                 rating)   export CURRENT_SORT="rating" ;;
                 *)        export CURRENT_SORT="date_added" ;;
            esac

            # Build title based on current filters
            local title_prefix=""
            local data_func=""
            
            case "$current_category" in
                movies)
                    title_prefix="üé¨"
                    case "$current_sort" in
                        trending|seeds) data_func="get_trending_movies" ;;
                        popular|rating) data_func="get_popular_movies" ;;
                        new)            data_func="get_new_48h_movies" ;;
                        *)              data_func="get_latest_movies" ;;
                    esac
                    
                    # Update title display
                    case "$current_sort" in
                        latest)   title_prefix="$title_prefix Latest" ;;
                        trending) title_prefix="$title_prefix Trending" ;;
                        seeds)    title_prefix="$title_prefix Most Seeded" ;;
                        popular)  title_prefix="$title_prefix Popular" ;;
                        rating)   title_prefix="$title_prefix Rated ${current_min_rating}+" ;;
                        new)      title_prefix="$title_prefix New (48h)" ;;
                    esac
                    
                    if [[ -n "$current_query" ]]; then
                        title_prefix="$title_prefix [Year: ${current_query}]"
                    fi
                    
                    if [[ -n "$current_genre" ]]; then
                        title_prefix="$title_prefix ‚Ä¢ $current_genre"
                    fi

                    display_catalog "$title_prefix" "$data_func" 50
                    ;;
                shows)
                    display_catalog "üì∫ TV Shows" get_latest_shows 50
                    ;;
                watchlist)
                    # Placeholder for future Watchlist feature
                    clear
                    echo -e "\n${BOLD}${YELLOW}üìö Watchlist${RESET}\n"
                    echo -e "${CYAN}Coming Soon!${RESET}"
                    echo -e "\nThis feature will allow you to:"
                    echo -e "  ‚Ä¢ Save movies and shows to watch later"
                    echo -e "  ‚Ä¢ Get notified when new episodes arrive"
                    echo -e "  ‚Ä¢ Track your watch history"
                    echo -e "\n${GRAY}Press any key to go back...${RESET}"
                    read -n 1 -s
                    current_category="movies"
                    continue
                    ;;
            esac
            
            local ret=$?
            
            # Reset refresh flag immediately after usage so it doesn't persist
            if [[ "$FORCE_REFRESH" == "true" ]]; then
                export FORCE_REFRESH=false
            fi
            
            case $ret in
                101) current_category="movies" ;;
                102) current_category="shows" ;;
                103) current_category="watchlist" ;;
                104) 
                    # Type dropdown: toggle between movies and shows
                    [[ "$current_category" == "movies" ]] && current_category="shows" || current_category="movies"
                    ;;
                105)
                    # Sort dropdown (^V)
                    # Add "Rating" and "Peers" to sort options
                    local sort_options="Latest (newest)\nTrending (most seeded)\nPopular (best rated)\nRating (high->low)\nPeers (seeds)\nNew (last 48h)"
                    local selected_sort
                    selected_sort=$(echo -e "$sort_options" | fzf --height=15 --layout=reverse --border --prompt="Sort by: " --header="Select sorting method" 2>/dev/null)
                    
                    if [[ -n "$selected_sort" ]]; then
                        case "$selected_sort" in
                            "Latest (newest)") current_sort="latest" ;;
                            "Trending (most seeded)") current_sort="trending" ;;
                            "Popular (best rated)") current_sort="popular" ;;
                            "Rating (high->low)") 
                                 current_sort="rating" 
                                 # Show rating picker
                                 local rating_opts="9+ Stars\n8+ Stars\n7+ Stars\n6+ Stars\n5+ Stars\n4+ Stars\nAny Rating"
                                 local sel_rat
                                 sel_rat=$(echo -e "$rating_opts" | fzf --height=10 --layout=reverse --border --prompt="Min Rating: " --header="Filter by Rating" 2>/dev/null)
                                 case "$sel_rat" in
                                     "9+ Stars") current_min_rating=9 ;;
                                     "8+ Stars") current_min_rating=8 ;;
                                     "7+ Stars") current_min_rating=7 ;;
                                     "6+ Stars") current_min_rating=6 ;;
                                     "5+ Stars") current_min_rating=5 ;;
                                     "4+ Stars") current_min_rating=4 ;;
                                     *) current_min_rating=0 ;;
                                 esac
                                 ;;
                            "Peers (seeds)") current_sort="seeds" ;;
                            "New (last 48h)") current_sort="new" ;;
                        esac
                    fi
                    continue
                    ;;
                106)
                    # Genre dropdown: show FZF popup with genre list
                    local genre_list="All Genres\nAction\nAdventure\nAnimation\nComedy\nCrime\nDocumentary\nDrama\nFamily\nFantasy\nHorror\nMusic\nMystery\nRomance\nSci-Fi\nThriller\nWar\nWestern"
                    local selected_genre
                    selected_genre=$(echo -e "$genre_list" | fzf --height=15 --layout=reverse --border --prompt="Genre: " --header="Filter by genre" 2>/dev/null)
                    
                    if [[ -n "$selected_genre" && "$selected_genre" != "All Genres" ]]; then
                        current_genre="$selected_genre"
                    else
                        current_genre=""
                    fi
                    continue
                    ;;
                110)
                    # Year dropdown (^Y)
                    # Generate years from current year down to 1950
                    local current_yr=$(date +%Y)
                    local year_list=$(seq "$current_yr" -1 1950)
                    local selected_year
                    selected_year=$(echo "$year_list" | fzf --height=15 --layout=reverse --border --prompt="Year: " --header="Filter by Year" 2>/dev/null)
                    
                    if [[ -n "$selected_year" ]]; then
                        current_query="$selected_year"
                    fi
                    continue
                    ;;
                109)
                    # Refresh: Force reload of catalog data
                    export FORCE_REFRESH=true
                    continue
                    ;;
                *)   break ;;  # User cancelled or streamed
            esac
        done
        
        exit 0
    fi
    
    # Check dependencies for streaming (only needed when actually streaming)
    check_deps
    check_jq
    
    # Get source from clipboard if not provided
    if [ -z "$source" ]; then
        if command -v pbpaste &> /dev/null; then
            # BSD grep compatible (no -P flag)
            source=$(pbpaste | grep -oE 'magnet:\?[^[:space:]]+' | head -1)
            if [ -n "$source" ]; then
                echo -e "${GREEN}Using magnet link from clipboard${RESET}"
            fi
        fi
        
        if [ -z "$source" ]; then
            echo -e "${RED}Error:${RESET} No magnet link or torrent file provided"
            echo "Usage: termflix <magnet_link|torrent_file>"
            echo "   or: termflix --help"
            exit 1
        fi
    fi
    
    # Handle auto-quality selection
    if [ "$auto_quality" = true ] && [ -z "$index" ]; then
        index=$(select_best_quality "$source")
    fi
    
    # Stream the torrent
    stream_torrent "$source" "$index" "$list_only" "$enable_subtitles"
}

# Run main function
# Run main function if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
